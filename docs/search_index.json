[["index.html", "ENG 792 - Análise e visualização de dados com R (RStudio) Capítulo 1 Apresentação 1.1 Hello World! - Sejam Bem Vindos!", " ENG 792 - Análise e visualização de dados com R (RStudio) Jackson Rodrigues 2021-08-31 Capítulo 1 Apresentação 1.1 Hello World! - Sejam Bem Vindos! Assista este conteúdo em Cap 1 - Hello World! - Sejam Bem Vindos! no PVANet. Este é o material para os alunos matriculados na disciplina ENG 792 - Análise e Visualização de dados com R (RStudio) ofertada pelo programa de pós-graduação em Meteorologia Aplicada da Universidade Federal de Viçosa (UFV). Este curso foi criado e é ministrado por Jackson Rodrigues, professor da Universidade Federal Fluminense (UFF), mas também professor no programa de pós-graduação em Meteorologia Aplicada do Departamento de Engenharia Agrícola (DEA) da Universidade Federal de Viçosa (UFV). Este curso foi construído pensando em minha saga para aprender algo utilizando o R em meu doutorado. Foi bastante dolorido, principalmente no começo quando eu nunca havia tido contato com a liguagem, na verdade, sabia quase nada em programação. Desta forma, o público alvo é aquele que tem conhecimento zero sobre o assunto. Mas se você já sabe algo em qualquer nível, seja bem vindo também! Podemos aprender juntos, você ensina o que você sabe e eu ensino o que eu sei. A ideia principal deste curso é que o(a) aluno(a) que nada sabe de R seja exposto(a) a grande quantidade de conceitos e métodos para que o gelo seja quebrado e possa se virar sozinho ao término do curso. Desta forma, não é um curso de estatística, não é um curso de produção gráfica nem um curso produção de conteúdo (eg. modelagem), mas um curso de exposição, quase um how to. Vamos levantar demandas do dia a dia e tentar resolver os problemas comuns enfrentados pelo estudante na condução de suas análises. Eventualmente algum especialista será convidado para dar uma aula, bater um papo, fazer uma apresentação e etc sobre um assunto específico. O R é uma ferramenta espetacular para análise e produção de dados, bem como produção gráfica! Vamos começar devagar e ao poucos vocês vão se tornando autossuficientes. Muitas dúvidas surgem em fóruns, grupos e tanto outros canais de comunicação da comunidade de usuários de R. Muitas vezes surgem perguntas como:\"Tem como fazer isso no R? A resposta imediada, devido à sua versatilidade, é: A pergunta não é se tem jeito, mas como fazer. Vamos dar uma passeio por muitas coisas legais que o R pode fazer e que vão ajudar a tornar sua vida bem melhor. Com tempo ganho na otimização das suas tarefas por utilização do R sobrará tempo para você escrever um paper a mais na pós-graduação, dormir no final de semana sem culpa, tomar uma cerveja na sexta com a turma e ir ao culto domingo sem pedidos. Vamos fazer tudo isso nos divertindo. É legal! Vocês verão. Por isso não se procupem comigo (professor), será muito pior para mim por ter que corrigir trabalhos enquanto vocês produzem mais um paper, dormem, tomam um cerveja com a turma e/ou rezam como foi na véspera de natal de 2020 quando estava corrigindo trabalhos. Véspera de Natal 2020 Lets ride to Metal Land! Não se sintam pressionados ou intimidados, façam as perguntas que quiserem. Eu também não sei tudo, o R é uma ferramenta que está em constante desenvolvimento tornando impossível acompanhar cada novidade. Caso eu não saiba uma resposta não tenho problemas em dizer que não sei, mas vou me esforçar para buscar a resposta. Por isso: Vamos aprender e tentar nos divertir; Pensei nesse curso como uma forma de lutar contra a dor que senti quando comecei a trabalhar no R sozinho; Então sou um usuário e não um programador; A verdade é que o R tem uma curva de aprendizado muito íngreme que uma vez vencido o primeiro obstáculo as coisas deslancham; Vamos trabalhar de maneira que esse curso atenda superficialmente suas demandas e que te habilitem a se virarem sozinhos; Então vamos seguir passo-a-passo para um aprendizado gradual com vários exemplos; Tudo que você aprender em determinando momento não será descartado, você deverá guardar aquele conhecimento para utilização em próximo trabalho ou tarefa; Ou ainda, este conhecimento inicial será utilizado para sedimentar o caminho para um próximo passo; Aplicar o máximo possível nosso conhecimento a problemas reais, do mundo real. Para finalizar gostaria de deixar algumas coisas claras. Este curso conta com vasto material encontrado em artigos, livros, blogs especializados, grupos de discussões e etc. Desta forma, caso encontre por aí algo que ofertei em aula não precisa me chamar de picareta. Provavelmente foi tirado de lá mesmo. O curso funciona como um How to. Não teremos tempo de nos aprofundar nas teorias dos assuntos aqui apresentados (nem é a intenção), por isso, vou mostrar o que é, como usar e como fazer. Ao término de cada aula será mostrada uma bibliografia básica sobre o conteúdo. Como são conteúdos diversificados, acho melhor separar as bibliografias por aula. 1.1.1 Sobre Este é um material de apoio compilado e criado para os alunos da disciplina ENG 792 - Análise e visualização de dados com R (RStudio). Importante mencionar que o conteúdo aqui apresentado é um compilado de vários anos de materiais estudados disponíveis online ou em livros e artigos especialzados. Desta forma, caso identifique algum conteúdo apresentado aqui que não esteja devidamente referenciado fique à vontade para solicitar os devidos créditos aos autores originais. Não tenho a intenção de ter crédito que não é meu. 1.1.2 Utilização Cada capítulo é referente ao conteúdo de mais ou menos uma semana de curso. Cada semama trata de um assunto diferente e complementar ao conteúdo da semana anterior. Desta forma, fique livre para ir e vir no conteúdo caso algo não esteja claro o suficiente. Teremos aulas gravadas e aulas síncronas através de alguma plataforma. Apenas os alunos matriculados na disciplina terão acesso ao conteúdo gravado. A distribuição e/ou compartilhamento do conteúdo gravado por qualquer meio é proibido. 1.1.3 Códigos e Dados Todo o material necessário para acompanhar a disciplina será oferecido via github. Os códigos com alguma explicação neste material online (explicação completa nas aulas) e os dados onde forem possíveis de serem armazenados. 1.1.4 Cronograma de aulas As aulas serão ofertadas por material gravado e presencial às quintas e sextas entre 14:00 e 15:30. Semana Conteúdo 1.1 Apresentação do Conteúdo e Instalação do R 1.2 Funcionamento do R, tipo e estrutura dos objetos 2.1 Manipulação de dados 1 2.2 Manipulação de dados 2, testes lógicos e simbolos, condicionais e interações 3.1 Pacotes e Funções 3.2 Entrando/Importando dados. definição de diretórios 4.1 Produção gráfica com Rbase 4.2 Produção gráfica com ggplot 2 5.1 Elementos de estatística básica 1 (Est. Descritiva, Med. Tend. Central, Medi. de variabilidade) 5.2 Elementos de estatítica básica 2 (Dife. Entre médias, T-Student, Teste F, Testes de normalidade) 6.1 Elementos de estatítica básica 3 (ANOVA, delineamento, comparaçõe múltiplas, Regressão, Resíduos, Homocedasticidade, Normalidade dos resíduos, regressão múltipla, superfície de resposta) 7.1 Análise Multivariada (Análise de agrupamento, medidas de (dis)similaridade, métodos de conexão, número de clusters, produção de dendogramas, árvores de decisão) 7.2 Métodos de Ordenação (Ana. Componentes Principais, Análise Canônica, Análise de fatores, Análise de Mahalanobis) 8 - 15 Será preenchido em breve 1.1.5 Métodos de avaliação Faremos pelo menos 3 listas de exercícios distribuídas pelo semestre. O trabalho final será a confecção de um atrabalho autoral com o conteúdo do curso que poderá ser feito em grupo (isso será definido ainda em conversa com vocês). Este trabalho será apresentado na forma de seminário ao término do curso. "],["vamos-ao-que-interesa.html", "Capítulo 2 Vamos ao que interesa 2.1 Conhecendo o R 2.2 Como R funciona", " Capítulo 2 Vamos ao que interesa 2.1 Conhecendo o R 2.1.1 O que é o R? É uma linguagem de programação voltada para resolução de problemas estatísticos, tratamento e visualização de dados. Para Peng (2020b) essa resposta é simples, R é um dialeto do S. De acordo com Perlin (2018) O código base do R foi inicialmente criado no laboratório da Bell/ AT&amp; T por John Chambers e seus colegas, com base na linguagem S. Esse código foi reaproveitado por dois acadêmicos, Ross Ihaka e Robert Gentleman, resultando na plataforma de programação que temos hoje. Para os curiosos, o nome R foi escolhido devido ao compartilhamento da primeira letra do nome de seus criadores. O R está em constante desenvolvimento por um grupo chamado R Team Core e conta com colaboração gratuita de centenas de milhares de usuários e desenvolvedores ao redor do mundo. Por isso, atualmente o R é utilizado por diversas áreas do conhecimento variando das ciências humanas até exatas, naquelas ciências que poderíamos imaginar pouco ou nada relacionadas. Por isso não se limite a procurar informações apenas no seu nicho, abra sua mente e busque aprender de outras ciências também. Eu, particularmente, busco muita coisa na econometria. Embora presente em todo tipo de livro sobre R, esta citação acima (Perlin (2018)) é de um livro de econometria. Veremos mais conteúdos desse material em breve. R é um software livre de análise de dados (não só estatística) que funciona em diversos sistemas operacionais: GNU Linux, MicrosoftWindows, Mac OS X e outros. O aprendizado do R é difícil no início devido à necessidade de se adaptar à sua lógica de funcionamento, se acostumar com a estrutura dos seus documentos de ajuda e memorizar alguns comandos básicos. eq = function(x){x*x} plot(eq(1:1000), type=&quot;l&quot;,lwd=3,col=&quot;red&quot;, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, xlab=&quot;Tempo&quot;, ylab=&quot;Aprendizado&quot;, main=&quot;Curva de Aprendizado&quot;) É preciso bastante perseverança e motivação para aprender os comandos básicos, e disposição para ler as páginas de ajuda e os manuais. Entretanto, depois de um certo tempo, ele possibilita que se trabalhe com grande produtividade e, o que é mais importante, eficácia e independência. Leia também sobre o mito da curva de aprendizado do R. 2.1.2 Instalação do R O R é um software gratuito para análises estatísticas e além. Pode ser baixado de The R Project for Statistical Computing. Clique em download R. Escolha o espelho.Escolha o mais próximo de você. Escolha o seu sistema operacional. Caso você seja usuário de windows clique em Download R for Windows em seguinda em install R for the first time e finalmente em Download R 4.1.0 for Windows. Veja que no momento que este tutorial foi feito a versão mais recente é a 4.1.0. No vídeo abaixo a versão é uma anterior, mas a lógica é a mesma. Assista este conteúdo em Cap 1 - Instalação do R no Windows no PVANet. Eu não tenho um sistema operacional de cada para mostrar a instalação, por isso deixo este vídeo para instalação no linux e este para instalação no mac. Caso você não consiga instalar me procure. 2.1.3 Primeiro contato Assista este conteúdo em Cap 1 - Primeiro contato no PVANet. Temos 1 arquivo Cap_1_P2-Mispriced-Diamonds.csv PVANet no PVANet com mais de 50.000 linhas referentes a transações de venda de diamantes dividida em 3 colunas clarity, carat e price. Quanto mais claro mais caro, certo? Ou há sub ou super valorização? Vamos investigar se essa relação é verdadeira como sugerido em ecapitaladvisors. Abaixo vamos apenas dar uma olhada no potencial de análise e produção gráfica do R. Não precisa se preocupar se não conseguir fazer tudo funcionar. Vamos aos poucos aprender cada comando apresentado. mydata&lt;-read.csv(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_1_P2-Mispriced-Diamonds.csv&quot;) library(&quot;ggplot2&quot;) ggplot(data=mydata, aes(x=carat, y=price))+ geom_point() Faz algum sentido. Mas está difícil de visualizar então vamos fazer um tratamento, vamos atribuir cores de acordo com a classificação do atributo clarity. ggplot(data=mydata, aes(x=carat, y=price, colour=clarity))+ geom_point() Os pontos estão sobrepostos impossibilitando a visualização. Vamos mexer na transparência. ggplot(data=mydata, aes(x=carat, y=price, colour=clarity))+ geom_point(alpha=0.1) Temos pontos que não são estatisticamente significantes à direita. Vamos nos livrar dos pontos não significativos, aqueles que são carat menores que 2.5. Vamos também adicionar algumas linhas através dos dados para avaliar o comportamento das variáveis em conjunto. brown é a melhor claridade, vejam que temos mispricing onde as linhas se cruzam. ggplot(data=mydata[mydata$carat&lt;2.5,], aes(x=carat, y=price, colour=clarity))+ geom_point(alpha=0.1) + geom_smooth() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; Vamos agora reproduzir um ourto exemplo muito legal do pacote rayshader. Executando o código abaixo você produzirá uma Modelo Digital do Terreno em 3D em uma janela pop up. library(rayrender) library(rayshader) library(magick) #Vamos carregar o mapa com o pacote raster. loadzip = tempfile() download.file(&quot;https://tylermw.com/data/dem_01.tif.zip&quot;, loadzip) localtif = raster::raster(unzip(loadzip, &quot;dem_01.tif&quot;)) unlink(loadzip) # convertê-lo para matriz: elmat = raster_to_matrix(localtif) #Usar uma outra textura do rayshader elmat %&gt;% sphere_shade(texture = &quot;desert&quot;) %&gt;% add_water(detect_water(elmat), color = &quot;desert&quot;) %&gt;% plot_3d(elmat, zscale = 10, fov = 0, theta = 60, zoom = 0.75, phi = 45, windowsize = c(1000, 800)) Agora vamos adicionar mais algumas infromações como escala e indicador de norte. render_scalebar(limits=c(0, 5, 10),label_unit = &quot;km&quot;,position = &quot;W&quot;, y=50,scale_length = c(0.33,1)) render_compass(position = &quot;E&quot;) Sys.sleep(0.2) render_highquality(samples=200, scale_text_size = 24,clear=TRUE) 2.2 Como R funciona Assista este conteúdo em Cap 1 - Como R Funciona no PVANet. Diferentemente de outras linguagens, todos os comandos escritos são diretamente executados, desta forma o R não precisa de um compilador para executar os comandos como Fortran. Por isso, torna-se uma linguagem muito mais amigável e acessível para não programadores. A linguagem é muito intuitiva (quase uma sintaxe lógica). Por exemplo uma regressão linear pode ser executada como lm(x~y) ( lm vem de linear model). Como no exemplo do modelo linear acima, sempre que formos executar um comando temos que seguir da seguinte forma função(dados e demais ajustes ou parâmetros), ou seja chame a função e coloque o resto dentro de parênteses. Tudo que é executado pelo R fica armazenado na memória ativa (RAM) do computador na forma de objetos que possuem um nome. Os objetos, que variam em tipos e estruturas, podem ser funções criadas pelo próprio usuário, dados criados ou importados de uma memória, expressões e etc. Antes de entrarmos em detalhes sobre funções ou expressões, vamos nos ater aos objetos enquanto tipo e, na sequência, suas estruturas. Dica de livro de cabeceira sobre R Mello and Peternelli (2013). Antes de avançarmos para os objetos é necessário fazer algumas recomendações e ressalvas. Para criar um objeto qualquer podemos utilizar &lt;- ou =. As boas práticas recomendam o uso de &lt;- para evitar confusão já que o sinal = tem outras funções. Um objeto é criado da seguinte forma nome_do_objeto &lt;- atribuição. nome_do_objeto &lt;- &quot;atribuição&quot; nome_do_objeto ## [1] &quot;atribuição&quot; Contudo, evitem nomes longos, que comecem com numerais ou caracteres especiais ou letras maiúsculas (R é case-sensitive). Caso sua linha de comando esteja ficando longa demais opte por quebrar a linha veremos isso mais adiante). 2.2.1 Tipos de objetos (mode ou type) Os objetos no R podem ser do tipo lógico, inteiro, simples, dupla, complexo, função ou caractere. mode() Armazenamento Exemplo logical lógico TRUE or FALSE numeric inteiro, simples ou dupla Números 1, 3.14, 2e-308 etc complex complexo 3+2i function função Soma&lt;-function() name caractere média Tabela 1: Tipos de modos para objetos no R. #logical q1 &lt;-T mode(q1);typeof(q1) ## [1] &quot;logical&quot; ## [1] &quot;logical&quot; q2 &lt;- FALSE #pode ser a palavra toda mas em maiúsculas mode(q2);typeof(q2) ## [1] &quot;logical&quot; ## [1] &quot;logical&quot; #integer x&lt;-2L #L garante que 2 será integer mode(x);typeof(x) ## [1] &quot;numeric&quot; ## [1] &quot;integer&quot; #double y&lt;-2.5 mode(y);typeof(y) ## [1] &quot;numeric&quot; ## [1] &quot;double&quot; #Complex z&lt;-3+2i mode(z);typeof(z) ## [1] &quot;complex&quot; ## [1] &quot;complex&quot; #function Soma&lt;-function(x,y){ x+y } mode(Soma);typeof(Soma) ## [1] &quot;function&quot; ## [1] &quot;closure&quot; #Character a &lt;-&quot;h&quot; #Para colocar uma letra em uma variável é preciso colocar entre &quot;&quot;) mode(a);typeof(a) ## [1] &quot;character&quot; ## [1] &quot;character&quot; média&lt;-&quot;média&quot; mode(a);typeof(a) ## [1] &quot;character&quot; ## [1] &quot;character&quot; Saber as diferenças entre os diversos objetos é importante para uma exploração mais adequada dos dados, utilização eficiente de funções ou operações lógicas, artiméticas, estatísticas e etc. Veja que no caso acima em integer (x &lt;- 2L) optamos por adicionar L após o número 2, pois o R por padrão decide onde e como aloca/aloja/armazena um operador. A informação será preferencialmente salva como double e isso faz sentido caso você queira mais adiante realizar operações com números decimais ou realizar operações que resultem em números decimais. No entanto, caso queira saber que tipo de dado está manipulando você pode perguntar utilizando is. seguido da designação do tipo de dados quer testar ( integer, numeric, double e etc) e teremos uma resposta lógica. is.double(x) ## [1] FALSE Caso você deseje que sua variável seja de um tipo específico, você pode transformá-la utilizando as. seguido da designação desejada ( integer, numeric, double e etc). x&lt;-as.double(x) is.double(x) ## [1] TRUE Cada tipo de dado é associado com um teste e uma função de conversão conforme a tabela 2. Tipo Teste Função de conversão character is.character as.character complex is.complex as.complex double is.double as.double expression is.expression as.expression integer is.integer as.integer list is.list as.list logical is.logical as.logical numeric is.numeric as.numeric single is.single as.single raw is.raw as.raw Date is.Date as.Date Tabela 2: Tipos de dados, teste e modos de conversão. 2.2.2 Estrutura do objetos (class) As informações armazenadas em objetos no R podem ser organizadas em diferentes estruturas ou classes. No R existe uma grande variedade de classes de objetos, e sempre surgindo mais. No entanto, há classes de objetos que são mais comuns em situações em que estamos manipulando bases de dados, seja ela já existente, ou quando estamos criando com coleta usando técnicas de webscraping, por exemplo. São elas: interger, numeric, character, factor, matrix, data.frame e list. Uma coisa importante, no R não precisamos declarar qual classe vai ser o objeto unidimensional como em outras linguagem, embora possamos fazer isso, pois, o R aloca o objeto automaticamente em uma classe a partir do seu conteúdo. Meireles and Silva (2018) Figura 1: Estrutura de dados no R. Fonte: techvidvan Objeto modes descrição vector numeric, character, complex ou logical Com um ou mais elementos factor numeric ou character Vetor que representa dados categóricos matriz numeric, character, complex ou logical Um array de duas dimensões array numeric, character, complex ou logical Pode conter um, duas ou mais dimensões data frame numeric, character, complex ou logical Um array de duas dimenões que permite colunas de diferentes tipos dem mesmo objeto list numeric, character, complex, logical, function, expression,  Objeto que permite combinar diferentes estruturtas de dados num único objeto Tabela 3: Características dos tipos de objetos. 2.2.2.1 Vetores (Vectors) Vetores são os tipos de objetos mais comuns no R. Um vetor é composto de uma informação ou uma séries de informações ( arrays ) unidimensionais que podem conter informaçõs numéricas, caracteres ou dados lógicos. Mesmo quando digitamos apenas um único elemento ele se torna um vetor de comprimento um (1). Vetores com Apenas 1 elemento esquerdo&lt;-(&quot;direito&quot;) # O objeto &quot;esquerdo&quot; recebe a palavra &quot;direito&quot; esquerdo #execute o arquivo e veja seu conteúdo ## [1] &quot;direito&quot; direito=c(&quot;esquerdo&quot;) #Outra maneira de criar objeto print(direito) #Outra forma de executar o conteúdo ## [1] &quot;esquerdo&quot; b=(10) # O objeto &quot;b&quot; recebe o número 10 b ## [1] 10 (15.23)-&gt;c # O objeto &quot;c&quot; recebe o número 15.23 c ## [1] 15.23 Vetores com múltiplos elementos. d&lt;-(0:10) # Criando uma sequência de 0 até 10 d ## [1] 0 1 2 3 4 5 6 7 8 9 10 e&lt;-10.5:20.5 # criando uma sequência de 10.5 até 20.5 e ## [1] 10.5 11.5 12.5 13.5 14.5 15.5 16.5 17.5 18.5 19.5 20.5 f&lt;-(10.6:20.3) # O último elemento é descartado por nãos e encaixar na sequência f ## [1] 10.6 11.6 12.6 13.6 14.6 15.6 16.6 17.6 18.6 19.6 Podemos utilizar também a função seq para gerar uma sequêncaio de dados. seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),length.out = NULL, along.with = NULL, ) g&lt;-seq(0,10,0.5) # O objeto &quot;g&quot; recebe a sequência de 0 até 10 a cada 0.5 g ## [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 ## [12] 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 9.5 10.0 h&lt;-seq(from=10,to=20,length.out=50) # O objeto &quot;h&quot; recebe a sequência de 0 até 10 que é do compriumento 50, ou seja, há 50 número de 10 até 20 h ## [1] 10.00000 10.20408 10.40816 10.61224 10.81633 11.02041 ## [7] 11.22449 11.42857 11.63265 11.83673 12.04082 12.24490 ## [13] 12.44898 12.65306 12.85714 13.06122 13.26531 13.46939 ## [19] 13.67347 13.87755 14.08163 14.28571 14.48980 14.69388 ## [25] 14.89796 15.10204 15.30612 15.51020 15.71429 15.91837 ## [31] 16.12245 16.32653 16.53061 16.73469 16.93878 17.14286 ## [37] 17.34694 17.55102 17.75510 17.95918 18.16327 18.36735 ## [43] 18.57143 18.77551 18.97959 19.18367 19.38776 19.59184 ## [49] 19.79592 20.00000 Experimente também a função rep(). rep(x, times = 1, length.out = NA, each = 1) i&lt;-rep(0,10) # O objeto &quot;i&quot; recebe 10 números 1 i ## [1] 0 0 0 0 0 0 0 0 0 0 j&lt;-rep(c(1:3),10) # O objeto &quot;j&quot; recebe 10 vezes a sequência 1, 2 e 3 j ## [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 ## [28] 1 2 3 Um Vetor só pode conter informações de um único tipo! k&lt;-c(0,1,2,3,4, &quot;A&quot;) # O objeto &quot;k&quot; é do tipo character por causa de &quot;A&quot; typeof(k);mode(k) ## [1] &quot;character&quot; ## [1] &quot;character&quot; l&lt;-c(0,1,2,3,4) # O objeto &quot;l&quot; é do tipo numérico typeof(l);mode(l) ## [1] &quot;double&quot; ## [1] &quot;numeric&quot; 2.2.2.2 Fatores (Factors) Os fatores são vetores em que os elementos pertencem a uma ou mais categorias temáticas. As variáveis aleatórias podem ser divididas em contínuas e categóricas. As contínuas podem ser medidas nas escalas: relacional e intervalar. As categóricas nas escalas: nominal e ordinal. No R, as variáveis categóricas medidas nas escalas nominal e ordinal são chamados fatores. A função factor() armazena os valores categóricos como um vetor de inteiros [1..k] e um vetor interno de strings referentes ao nomes. Em outras palavras, um factor é um vetor objeto usado para especificar uma classsificação discreta (agrupamento) dos componentes de outros vetores de mesmo tamanho. factor(x = character(), levels, labels = levels,exclude = NA, ordered = is.ordered(x), nmax = NA) ou gl(n, k, length = n X k, labels = seq_len(n), ordered = FALSE) m&lt;-factor(c(&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;M&quot;,&quot;M&quot;)) # O objeto &quot;k&quot; recebe 3 H&#39;s e 2 M&#39;s m ## [1] H H H M M ## Levels: H M as.integer(m) ## [1] 1 1 1 2 2 n&lt;-gl(n=2,k=3,labels=c(&quot;M&quot;,&quot;F&quot;)) n ## [1] M M M F F F ## Levels: M F Podemos verificar os níveis de um fator usando o comando levels(). levels(m) ## [1] &quot;H&quot; &quot;M&quot; levels(n) ## [1] &quot;M&quot; &quot;F&quot; 2.2.2.3 Matriz (Matrix) É o tipo de dado mais comum que encontramos do dia a dia. A maioria dos dados que analisamos estão organizados em matrizes que são dados combinados em 2 dimensões (linhas e colunas). Existem várias maneiras de criar uma matriz como utilizando o comando matrix(). matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,dimnames = NULL) Assim como os vetores, as matrizes só aceitam dados do mesmo tipo. o&lt;-1:10 # cria um vetor de 1 a 10 o_matriz1&lt;-matrix(o,ncol=5)# Organiza o vetor &quot;o&quot; e 5 colunas o_matriz1 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 o_matriz2&lt;-matrix(o,nrow=5)# Organiza o vetor &quot;o&quot; e 5 linhas o_matriz2 ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 Podemos utilizar também o argumento byrow=, que, diferente do exemplo acima, preenche a tabela por linha. p&lt;-1:10 # cria um vetor de 1 a 10 p_matriz1&lt;-matrix(o,nrow=5,byrow=T)# Organiza o vetor &quot;o&quot; e 5 colunas p_matriz1; o_matriz2 # compare os 2 modos ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 ## [4,] 7 8 ## [5,] 9 10 ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 As dimensões de uma matriz podem ser acessadas através do comando dim(): dim(o_matriz1);dim(o_matriz2) # Leia o o resultado como linha e coluna ## [1] 2 5 ## [1] 5 2 Também é interessante usar o comando summary(). summary(o_matriz1);summary(o_matriz2) # Mostra informações por coluna ## V1 V2 V3 ## Min. :1.00 Min. :3.00 Min. :5.00 ## 1st Qu.:1.25 1st Qu.:3.25 1st Qu.:5.25 ## Median :1.50 Median :3.50 Median :5.50 ## Mean :1.50 Mean :3.50 Mean :5.50 ## 3rd Qu.:1.75 3rd Qu.:3.75 3rd Qu.:5.75 ## Max. :2.00 Max. :4.00 Max. :6.00 ## V4 V5 ## Min. :7.00 Min. : 9.00 ## 1st Qu.:7.25 1st Qu.: 9.25 ## Median :7.50 Median : 9.50 ## Mean :7.50 Mean : 9.50 ## 3rd Qu.:7.75 3rd Qu.: 9.75 ## Max. :8.00 Max. :10.00 ## V1 V2 ## Min. :1 Min. : 6 ## 1st Qu.:2 1st Qu.: 7 ## Median :3 Median : 8 ## Mean :3 Mean : 8 ## 3rd Qu.:4 3rd Qu.: 9 ## Max. :5 Max. :10 Outras formas de construir matrizes é juntando objetos existentes através dos comandos cbind() e rbind() que concatenam objetos por colunas e linhas, respectivamente. Vamos juntar as matrizes já criadas. o_matriz3&lt;-rbind(o_matriz1,o_matriz1) # concatena por linhas (row) o_matriz3 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [3,] 1 3 5 7 9 ## [4,] 2 4 6 8 10 o_matriz4&lt;-cbind(o_matriz2,o_matriz2) # concatena por colunas (column) o_matriz4 ## [,1] [,2] [,3] [,4] ## [1,] 1 6 1 6 ## [2,] 2 7 2 7 ## [3,] 3 8 3 8 ## [4,] 4 9 4 9 ## [5,] 5 10 5 10 2.2.2.4 Array O array é um conjunto de matrizes ou vetores que podem ter qualquer número de dimensões. Estas dimensões podem receber nomes. Podemos criar arrays atribuindo dimensções a um vetor com o comando dim() ou usando array(). array(data = NA, dim = length(data), dimnames = NULL) q_array&lt;-1:12 # cria um vetor dim(q_array)&lt;-c(2,3,2) # atribuindo 3 dimensões a q_array q_array ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 r_array&lt;-array(1:12,c(2,3,2)) # cria um array de 3 dimensões r_array ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 2.2.2.5 Data Frame Tão comum quanto a matriz, o data frame também um modo bidimensional de organização dos dados (linhas e colunas) que, diferentemente da matriz, permite objetos de tipos diferentes (character, numeric, logical e etc) sejam armazenados. Normalmente, nos data frames temos nas linhas as observações e nas colunas temos as variáveis. No entanto, é importante que cada coluna tenha o mesmo tamanho. data.frame(, row.names = NULL, check.rows = FALSE,check.names = TRUE, fix.empty.names = TRUE,stringsAsFactors = default.stringsAsFactors()) Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores Sao Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 10 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana Bahia 38 12 13 13 44 43 49 1 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 -6 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana Botafogo 38 13 4 21 31 45 43 -14 38 NA Ceará 38 10 9 19 36 41 39 -5 34 NA Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado CSA 38 8 8 22 24 58 32 -34 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado Tabela 3: Data frame do resultados final do Campeonato Brasileiro de 2019. Nome&lt;-c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) Idade&lt;-c(25, 32, 28) Sexo&lt;-c(&quot;M&quot;,&quot;M&quot;, &quot;F&quot;) Nome;Idade;Sexo ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## [1] 25 32 28 ## [1] &quot;M&quot; &quot;M&quot; &quot;F&quot; Ficha&lt;-data.frame(Nome,Idade,Sexo) attributes(Ficha) # exibe os atributos do data frame ## $names ## [1] &quot;Nome&quot; &quot;Idade&quot; &quot;Sexo&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] 1 2 3 Nome Idade Sexo A 25 M B 32 M C 28 F Tabela 4: Tabela com dados fictícios. 2.2.2.6 Lista (list) List permite combinar diferentes estruturas de dados em um mesmo objeto, ou seja, vetores, matrizes, arrays, data.frames e até outras listas. As listas são construídas utilizando o comando list(). Os componentes da lista são criados da mesma maneira como para data.frame. list() Nome&lt;-c(&quot;A&quot;) Idade&lt;-c(25) Sexo&lt;-c(&quot;M&quot;) Notas&lt;-c(55,42,50,35) Nome;Idade;Sexo;Notas ## [1] &quot;A&quot; ## [1] 25 ## [1] &quot;M&quot; ## [1] 55 42 50 35 Desempenho&lt;-list(nome=&quot;A&quot;, idade=25, Sexo=&quot;M&quot;,Notas=c(55,42,50,35)) Desempenho ## $nome ## [1] &quot;A&quot; ## ## $idade ## [1] 25 ## ## $Sexo ## [1] &quot;M&quot; ## ## $Notas ## [1] 55 42 50 35 is.list(Desempenho) ## [1] TRUE Existem também alguns comandos/funções que mostram resultados como listas. s&lt;-c(1:30) t&lt;-c(30:59) teste.t&lt;-t.test(s,t, var.equal = T) # calcula o test t para 2 amostras de variâncias iguais teste.t ## ## Two Sample t-test ## ## data: s and t ## t = -12.758, df = 58, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -33.54996 -24.45004 ## sample estimates: ## mean of x mean of y ## 15.5 44.5 is.list(teste.t);mode(teste.t) ## [1] TRUE ## [1] &quot;list&quot; Para finalizar por hoje preste atenção no seu Global Environment. Veja que há uma grande quantidade de objetos lá. Agora execute o comando abaixo: rm(Desempenho) rm(list=ls()) Voilà! Sumiu tudo. References "],["references.html", "References", " References "],["acessando-e-manipulação-de-dados.html", "Capítulo 3 Acessando e manipulação de dados 3.1 Organização 3.2 Operadores 3.3 Dica de leitura 3.4 Exercícios", " Capítulo 3 Acessando e manipulação de dados 3.1 Organização Assista este conteúdo em Cap 2 - Organização Partes 1 e 2 no PVANet Como mencionado anteriormente, vector é uma das principais estruturas do R. Um vetor é uma sequência de elementos (1n) do mesmo tipo organizados tal qual livros em uma prateleira. No caso abaixo temos um vetor numérico que pode ser integer ou double. a&lt;-c(25,17,55,3,12,315,10,2,3,11) a ## [1] 25 17 55 3 12 315 10 2 3 11 Posição 1 2 3 4 5 6 7 8 9 10 Elementos 25 17 55 3 12 315 10 2 3 11 Um vetor também pode armazernar caracteres. Neste caso eles devem estar entre aspas duplas (\"\"). b&lt;-c(&quot;Z&quot;,&quot;f&quot;, &quot;7&quot;,&quot;2a&quot;,&quot;Yes&quot;,&quot;A&quot;,&quot;Ab&quot;) b;typeof(b) ## [1] &quot;Z&quot; &quot;f&quot; &quot;7&quot; &quot;2a&quot; &quot;Yes&quot; &quot;A&quot; &quot;Ab&quot; ## [1] &quot;character&quot; Embora tenhamos o número 7 entre os nossos elementos do vetor acima, por estar entre aspas o número 7 não é numéric, mas caractere. Lembrem-se que um vector é um banco de dados da mesmo tipo Logo, se você colocar um número 7 dentro dele, o R vai automaticamente convertê-lo em caractere independente de estar entre \"\" ou não. Posição 1 2 3 4 5 6 7 Elementos Z f 7 2a Yes A Ab Mesmo que você tenha apenas um único numeral ele será armazenado como vector, vector de comprimento = 1. Então um único número ou um único caractere será um vector. c&lt;-(1) c;typeof(c);is.vector(c) ## [1] 1 ## [1] &quot;double&quot; ## [1] TRUE Posição 1 Elemento 1 Entender a posição de cada elemento dentro de um vector é crucial! Saber a posição correta onde determinado(s) elemento(s) está(estão) facilita em muito nossa limpeza, nosso tratamento e demais passos para uma eficiente manipulação dos dados. seq(100,50,-1) ## [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 ## [14] 87 86 85 84 83 82 81 80 79 78 77 76 75 ## [27] 74 73 72 71 70 69 68 67 66 65 64 63 62 ## [40] 61 60 59 58 57 56 55 54 53 52 51 50 Atenção para os números dentro dos colchetes [1] [17] [33] [49]. Como mencionado em aulas passadas, eles, os colchetes, indicam a posição de determinados elementos dentro de um banco de dados. Especificamente o [1] informa que o número 100 é o primeiro elemento, [17] informa que o número 84 é o vigésimo elemento, [33] informa que o número 68 é o trigésimo nono elemento, [49] informa que o número 52 é o trigésimo nono elemento. 3.1.1 Usando [ ] - Subscribing ou indexing 3.1.1.1 Vetores Podemos extrapolar esta ideia de utilização de [] para acessar informações dentros dos objetos que criamos ou importamos. d&lt;-c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) d ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; Posição 1 2 3 4 5 Elementos a b c d e No vector d temos cada um dos elementos em sua respectiva posição. Para acessar um elemento específico podemos inserir o número refere à sua posição dentro de []. Por exemplo: d[1] ## [1] &quot;a&quot; d[2] ## [1] &quot;b&quot; d[3] ## [1] &quot;c&quot; d[4] ## [1] &quot;d&quot; d[5] ## [1] &quot;e&quot; Importante saber que [] é muito versátil. d[-1] # Acessa todos elementos exceto o primeiro ## [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; d1&lt;-d[3] # Atribuir o(s) elemento(s) de um vetor a outro vetor, ou criar um novo objeto de elementos já de objetos já existentes d1 ## [1] &quot;c&quot; d[1:3] # Acessar um intervalo de elementos ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; d[3:5] ## [1] &quot;c&quot; &quot;d&quot; &quot;e&quot; d[c(1,3:5)] # Acessar utilizando combinações ## [1] &quot;a&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; d[c(-2,-4)] # Exceto o segundo e quanto elementos ## [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; d[-3:-5] # Exceto o intervalo entre 3 e 5 ## [1] &quot;a&quot; &quot;b&quot; Vamos dar mais uma olhada na importância do []. Considere os seguintes vetores. Posição 1 2 3 4 5 6 7 8 9 10 Elemento 50 34 11 7 24 631 20 4 7 21 Posição 1 2 3 4 5 6 7 8 9 10 Elemento 100 2 56 12 0 65 93 10 244 1 Vamos somar os dois vetores e observe que são adicionados o primeiro elemento com primeiro elemento, segundo elemento com segundo elemento e assim por diante. Em algumas outras linguagens se você quiser fazer esse procedimento, você vai provavelmente usar um loop. Mas em R você pode simplesmente adicioná-los. Esse é o motivo do R ser linguagem vetorizada. Você pode testar qualquer método matemático (soma, divisão, booleana, lógica). e&lt;-c(50,34,11,7,24,631,20,4,7,21) f&lt;-c(100,2,56,12,0,65,93,10,244,1) e;f ## [1] 50 34 11 7 24 631 20 4 7 21 ## [1] 100 2 56 12 0 65 93 10 244 1 e+f ## [1] 150 36 67 19 24 696 113 14 251 22 Neste caso funcionou tudo perfeitamente, pois nossos vetores são do mesmo tamanho. No entanto, caso tenhamos vetores de tamanho diferentes o R vai fazer um procedimento chamado recycling of vector. O R vai fazer com que os dois vetores se encaixarem no mesmo tamanho caso sejam múltiplos. Basicamente, o R vai copiar os elementos do começo do vetor menor e adicionar ao seu fim até que fiqque do mesmo tamanho do outro vetor para, então, fazer a operação. Posição 1 2 3 4 5 Elemento 50 34 11 7 24 Posição 1 2 3 4 5 6 7 8 9 10 Elemento 100 2 56 12 0 65 93 10 244 1 h&lt;-c( 50,34,11, 7,24) i&lt;-c(100, 2,56,12, 0,65,93,10,244,1) h+i ## [1] 150 36 67 19 24 115 127 21 251 25 h;i ## [1] 50 34 11 7 24 ## [1] 100 2 56 12 0 65 93 10 244 1 h+i ## [1] 150 36 67 19 24 115 127 21 251 25 E se não forem múltiplos? Nesse caso vamos ter uma aviso, em que o R ao fazer o preenchimento dos valores faltantes vai querer saber se está certo o que estamos fazendo e emitindo um warning. j&lt;-c(50,34,11,7,24,631) k&lt;-c(100,2,56,12,0,65,93,10,244,1) j+k ## Warning in j + k: longer object length is not a multiple of ## shorter object length ## [1] 150 36 67 19 24 696 143 44 255 8 3.1.1.2 Matrizes Da mesma forma que utilizamos [ ] para acessar elementos específicos em um vetor, estes podem ser utilizados para acessar elementos de matrizes. Lembrando que as matrizes possuem duas dimensões e que as dimensões são organizadas na sequência de linhas e colunas. l&lt;-cbind(matrix(14:1, ncol=2),matrix(1:14, ncol=2)) l ## [,1] [,2] [,3] [,4] ## [1,] 14 7 1 8 ## [2,] 13 6 2 9 ## [3,] 12 5 3 10 ## [4,] 11 4 4 11 ## [5,] 10 3 5 12 ## [6,] 9 2 6 13 ## [7,] 8 1 7 14 As linhas e colunas [linhas, colunas] são numeradas sequencialmente [x...n,y] e [x,y...n]. Podemos desta forma selecionar uma ou várias linhas e colunas de uma só vez. Para isto basta apenas numerar a linhas ou coluna requerida. l[1,] # Apenas a primeira linhas ## [1] 14 7 1 8 l[,1] # Apenas a primeira coluna ## [1] 14 13 12 11 10 9 8 l[1:3,] # O intervalo de linhas entre 1 a 3 ## [,1] [,2] [,3] [,4] ## [1,] 14 7 1 8 ## [2,] 13 6 2 9 ## [3,] 12 5 3 10 l[,1:3] # O intervalo de colunas entre 1 e 3 ## [,1] [,2] [,3] ## [1,] 14 7 1 ## [2,] 13 6 2 ## [3,] 12 5 3 ## [4,] 11 4 4 ## [5,] 10 3 5 ## [6,] 9 2 6 ## [7,] 8 1 7 l[-3,] # Exceto a terceira linha ## [,1] [,2] [,3] [,4] ## [1,] 14 7 1 8 ## [2,] 13 6 2 9 ## [3,] 11 4 4 11 ## [4,] 10 3 5 12 ## [5,] 9 2 6 13 ## [6,] 8 1 7 14 l[,-3] # Exceto a terceira coluna ## [,1] [,2] [,3] ## [1,] 14 7 8 ## [2,] 13 6 9 ## [3,] 12 5 10 ## [4,] 11 4 11 ## [5,] 10 3 12 ## [6,] 9 2 13 ## [7,] 8 1 14 l[-1:-3,] # Exceto o intervalo de linhas entre 1 a 3 ## [,1] [,2] [,3] [,4] ## [1,] 11 4 4 11 ## [2,] 10 3 5 12 ## [3,] 9 2 6 13 ## [4,] 8 1 7 14 l[,-1:-3] # Exceto o intervalo de colunas entre 1 e 3 ## [1] 8 9 10 11 12 13 14 Podemos também acessar elementos específicos de uma matriz definindo o endereço do elemento nas linhas e colunas. l[2,3] # Acessa apenas o elemento do cruzamento da linha 2 e coluna 3 ## [1] 2 Para facilitar a manipulação das matrizes podemos nomear as linhas e colunas. Para isso podemos utilizar as funções colnames() e rownames(). nrow(l) # Retorna o número de linhas ## [1] 7 ncol(l) # Retorna o número de colunas ## [1] 4 dim(l) # Retorna as dimnesões (n° de linhas e colunas) ## [1] 7 4 l ## [,1] [,2] [,3] [,4] ## [1,] 14 7 1 8 ## [2,] 13 6 2 9 ## [3,] 12 5 3 10 ## [4,] 11 4 4 11 ## [5,] 10 3 5 12 ## [6,] 9 2 6 13 ## [7,] 8 1 7 14 rownames(l)&lt;-letters[1:7] # Atribui 7 letras minúsculas sequenciais de &quot;a&quot; até &quot;g&quot; como nomes das linhas l ## [,1] [,2] [,3] [,4] ## a 14 7 1 8 ## b 13 6 2 9 ## c 12 5 3 10 ## d 11 4 4 11 ## e 10 3 5 12 ## f 9 2 6 13 ## g 8 1 7 14 colnames(l)&lt;-LETTERS[1:ncol(l)] # Atribui letras maiúsculas sequenciais obedecendo o número de colunas como nomes das colunas l ## A B C D ## a 14 7 1 8 ## b 13 6 2 9 ## c 12 5 3 10 ## d 11 4 4 11 ## e 10 3 5 12 ## f 9 2 6 13 ## g 8 1 7 14 Agora podemos acessar via nomes das linhas e colunas também. l[&quot;a&quot;,] # Apenas a primeira linhas ## A B C D ## 14 7 1 8 l[,&quot;A&quot;] # Apenas a primeira coluna ## a b c d e f g ## 14 13 12 11 10 9 8 l[letters[1:3],] # O intervalo de linhas entre &quot;a&quot; a &quot;c&quot; ## A B C D ## a 14 7 1 8 ## b 13 6 2 9 ## c 12 5 3 10 l[,LETTERS[1:3]] # O intervalo de colunas entre &quot;A&quot; e &quot;C&quot; ## A B C ## a 14 7 1 ## b 13 6 2 ## c 12 5 3 ## d 11 4 4 ## e 10 3 5 ## f 9 2 6 ## g 8 1 7 l[c(&quot;a&quot;,&quot;c&quot;,&quot;d&quot;),] # Seleciona as linhas &quot;a&quot;, &quot;c&quot; e &quot;d&quot; ## A B C D ## a 14 7 1 8 ## c 12 5 3 10 ## d 11 4 4 11 l[,c(&quot;A&quot;,&quot;C&quot;,&quot;D&quot;)] # Seleciona as colunas &quot;a&quot;, &quot;c&quot; e &quot;d&quot; ## A C D ## a 14 1 8 ## b 13 2 9 ## c 12 3 10 ## d 11 4 11 ## e 10 5 12 ## f 9 6 13 ## g 8 7 14 3.1.1.3 Arrays Sendo muito similares aos vetores e matrizes, os arrays podem ter n dimensões. m&lt;-1:24 dim(m)&lt;-c(4,3,2) m ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 # ou m&lt;-array(1:24,c(4,3,2)) m ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 m[1,,] # Retorna as primeiras linhas do array ## [,1] [,2] ## [1,] 1 13 ## [2,] 5 17 ## [3,] 9 21 m[,2,] # Retorna as segundas colunas do array ## [,1] [,2] ## [1,] 5 17 ## [2,] 6 18 ## [3,] 7 19 ## [4,] 8 20 m[1,2,] # Retorna as intersecções entre as primeiras linhas com as segundas colunas ## [1] 5 17 m[1,2,2] # Retorna as intersecções entre a primeira linha com segunda coluna da sugunda camada ## [1] 17 3.1.1.4 Data Frame Sendo semelhantes às matrizes, os data frames pode serm acessados pelo número das linhas ou colunas. Equipes&lt;-c(&quot;Flamengo&quot;, &quot;Santos&quot;, &quot;Palmeiras&quot;, &quot;Grêmio&quot;, &quot;Athletico Paranaense&quot;, &quot;So Paulo&quot;, &quot;Internacional&quot;, &quot;Corinthians&quot;, &quot;Fortaleza&quot;, &quot;Goiás&quot;, &quot;Bahia&quot;, &quot;Vasco da Gama&quot;, &quot;Atlético Mineiro&quot;, &quot;Fluminense&quot;, &quot;Botafogo&quot;, &quot;Ceará&quot;, &quot;Cruzeiro&quot;, &quot;CSA&quot;, &quot;Chapecoense&quot;, &quot;Avaí&quot;) Jogos&lt;-c(&quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;) Vitórias&lt;-c(&quot;28&quot;, &quot;22&quot;, &quot;21&quot;, &quot;19&quot;, &quot;18&quot;, &quot;17&quot;, &quot;16&quot;, &quot;14&quot;, &quot;15&quot;, &quot;15&quot;, &quot;12&quot;, &quot;12&quot;, &quot;13&quot;, &quot;12&quot;, &quot;13&quot;, &quot;10&quot;, &quot;7&quot;, &quot;8&quot;, &quot;7&quot;, &quot;3&quot;) Empates&lt;-c(&quot;6&quot;, &quot;8&quot;, &quot;11&quot;, &quot;8&quot;, &quot;10&quot;, &quot;12&quot;, &quot;9&quot;, &quot;14&quot;, &quot;8&quot;, &quot;7&quot;, &quot;13&quot;, &quot;13&quot;, &quot;9&quot;, &quot;10&quot;, &quot;4&quot;, &quot;9&quot;, &quot;15&quot;, &quot;8&quot;, &quot;11&quot;, &quot;11&quot;) Derrotas&lt;-c(&quot;4&quot;, &quot;8&quot;, &quot;6&quot;, &quot;11&quot;, &quot;10&quot;, &quot;9&quot;, &quot;13&quot;, &quot;10&quot;, &quot;15&quot;, &quot;16&quot;, &quot;13&quot;, &quot;13&quot;, &quot;16&quot;, &quot;16&quot;, &quot;21&quot;, &quot;19&quot;, &quot;16&quot;, &quot;22&quot;, &quot;20&quot;, &quot;24&quot;) Gols.Pró&lt;-c(&quot;86&quot;, &quot;60&quot;, &quot;61&quot;, &quot;64&quot;, &quot;51&quot;, &quot;39&quot;, &quot;44&quot;, &quot;42&quot;, &quot;50&quot;, &quot;46&quot;, &quot;44&quot;, &quot;39&quot;, &quot;45&quot;, &quot;38&quot;, &quot;31&quot;, &quot;36&quot;, &quot;27&quot;, &quot;24&quot;, &quot;31&quot;, &quot;18&quot;) Gols.Contra&lt;-c(&quot;37&quot;, &quot;33&quot;, &quot;32&quot;, &quot;39&quot;, &quot;32&quot;, &quot;30&quot;, &quot;39&quot;, &quot;34&quot;, &quot;49&quot;, &quot;64&quot;, &quot;43&quot;, &quot;45&quot;, &quot;49&quot;, &quot;46&quot;, &quot;45&quot;, &quot;41&quot;, &quot;46&quot;, &quot;58&quot;, &quot;52&quot;, &quot;62&quot;) Pontos&lt;-c(&quot;90&quot;, &quot;74&quot;, &quot;74&quot;, &quot;65&quot;, &quot;64&quot;, &quot;63&quot;, &quot;57&quot;, &quot;56&quot;, &quot;53&quot;, &quot;52&quot;, &quot;49&quot;, &quot;49&quot;, &quot;48&quot;, &quot;46&quot;, &quot;43&quot;, &quot;39&quot;, &quot;36&quot;, &quot;32&quot;, &quot;32&quot;, &quot;20&quot;) Saldo.de.Gols&lt;-c(&quot;49&quot;, &quot;27&quot;, &quot;29&quot;, &quot;25&quot;, &quot;19&quot;, &quot;9&quot;, &quot;5&quot;, &quot;8&quot;, &quot;1&quot;, &quot;-18&quot;, &quot;1&quot;, &quot;-6&quot;, &quot;-4&quot;, &quot;-8&quot;, &quot;-14&quot;, &quot;-5&quot;, &quot;-19&quot;, &quot;-34&quot;, &quot;-21&quot;, &quot;-44&quot;) Aprov.&lt;-c(&quot;79&quot;, &quot;65&quot;, &quot;65&quot;, &quot;57&quot;, &quot;56&quot;, &quot;55&quot;, &quot;5&quot;, &quot;49&quot;, &quot;46&quot;, &quot;46&quot;, &quot;43&quot;, &quot;43&quot;, &quot;42&quot;, &quot;4&quot;, &quot;38&quot;, &quot;34&quot;, &quot;32&quot;, &quot;28&quot;, &quot;28&quot;, &quot;18&quot;) Destino&lt;-c(&quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;NA&quot;, &quot;NA&quot;, &quot;Rebaixado&quot;, &quot;Rebaixado&quot;, &quot;Rebaixado&quot;, &quot;Rebaixado&quot;) Campeonato.Brasileiro.2019&lt;-as.data.frame(cbind(Equipes,Jogos,Vitórias,Empates,Derrotas,Gols.Pró,Gols.Contra,Pontos,Saldo.de.Gols, Aprov., Destino)) Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores Sao Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 10 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana Bahia 38 12 13 13 44 43 49 1 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 -6 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana Botafogo 38 13 4 21 31 45 43 -14 38 NA Ceará 38 10 9 19 36 41 39 -5 34 NA Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado CSA 38 8 8 22 24 58 32 -34 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado Campeonato.Brasileiro.2019[1,] # Retorna a primeira linha do data frame ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró ## 1 Flamengo 38 28 6 4 86 ## Gols.Contra Pontos Saldo.de.Gols Aprov. Destino ## 1 37 90 49 79 Libertadores Campeonato.Brasileiro.2019[,1] # Retorna a primeira coluna do data frame ## [1] &quot;Flamengo&quot; &quot;Santos&quot; ## [3] &quot;Palmeiras&quot; &quot;Grêmio&quot; ## [5] &quot;Athletico Paranaense&quot; &quot;Sao Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; ## [9] &quot;Fortaleza&quot; &quot;Goiás&quot; ## [11] &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atlético Mineiro&quot; &quot;Fluminense&quot; ## [15] &quot;Botafogo&quot; &quot;Ceará&quot; ## [17] &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; Todas as outras combinações utilizadas nas matrizes podem ser utilizadas aqui nos data frames. No entanto, os data frames possuem uma outra vantagem sobre as matrizes. Além de armazenar elementos de diferentes tipos (numeric, character, logical e etc), eles também podemser acessados utilizando $. Campeonato.Brasileiro.2019$Equipes # Retorna os elementos da coluna &quot;Equipes&quot; ## [1] &quot;Flamengo&quot; &quot;Santos&quot; ## [3] &quot;Palmeiras&quot; &quot;Grêmio&quot; ## [5] &quot;Athletico Paranaense&quot; &quot;Sao Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; ## [9] &quot;Fortaleza&quot; &quot;Goiás&quot; ## [11] &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atlético Mineiro&quot; &quot;Fluminense&quot; ## [15] &quot;Botafogo&quot; &quot;Ceará&quot; ## [17] &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; Campeonato.Brasileiro.2019$Vitórias # Retorna os elementos da coluna &quot;Vitórias&quot; ## [1] &quot;28&quot; &quot;22&quot; &quot;21&quot; &quot;19&quot; &quot;18&quot; &quot;17&quot; &quot;16&quot; &quot;14&quot; &quot;15&quot; &quot;15&quot; &quot;12&quot; ## [12] &quot;12&quot; &quot;13&quot; &quot;12&quot; &quot;13&quot; &quot;10&quot; &quot;7&quot; &quot;8&quot; &quot;7&quot; &quot;3&quot; Campeonato.Brasileiro.2019$Gols.Pró # Retorna os elementos da coluna &quot;Gols.Pró&quot; ## [1] &quot;86&quot; &quot;60&quot; &quot;61&quot; &quot;64&quot; &quot;51&quot; &quot;39&quot; &quot;44&quot; &quot;42&quot; &quot;50&quot; &quot;46&quot; &quot;44&quot; ## [12] &quot;39&quot; &quot;45&quot; &quot;38&quot; &quot;31&quot; &quot;36&quot; &quot;27&quot; &quot;24&quot; &quot;31&quot; &quot;18&quot; Campeonato.Brasileiro.2019$Saldo.de.Gols # Retorna os elementos da coluna &quot;Saldo.de.Gols&quot; ## [1] &quot;49&quot; &quot;27&quot; &quot;29&quot; &quot;25&quot; &quot;19&quot; &quot;9&quot; &quot;5&quot; &quot;8&quot; &quot;1&quot; ## [10] &quot;-18&quot; &quot;1&quot; &quot;-6&quot; &quot;-4&quot; &quot;-8&quot; &quot;-14&quot; &quot;-5&quot; &quot;-19&quot; &quot;-34&quot; ## [19] &quot;-21&quot; &quot;-44&quot; Campeonato.Brasileiro.2019$Destino # Retorna os elementos da coluna &quot;Destino&quot; ## [1] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; ## [4] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; ## [7] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Sulamericana&quot; ## [10] &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;Sulamericana&quot; ## [13] &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;NA&quot; ## [16] &quot;NA&quot; &quot;Rebaixado&quot; &quot;Rebaixado&quot; ## [19] &quot;Rebaixado&quot; &quot;Rebaixado&quot; Campeonato.Brasileiro.2019$Equipes[2] # Retorna o segundo elemento da coluna &quot;Nome&quot; ## [1] &quot;Santos&quot; Campeonato.Brasileiro.2019$Vitórias[5] # Retorna o quinto elemento da coluna &quot;Vitórias&quot; ## [1] &quot;18&quot; Campeonato.Brasileiro.2019$Gols.Pró[3] # Retorna os elementos da coluna &quot;Gols.Pró&quot; ## [1] &quot;61&quot; Campeonato.Brasileiro.2019$Saldo.de.Gols[1] # Retorna os elementos da coluna &quot;Nivel.deR&quot; ## [1] &quot;49&quot; Campeonato.Brasileiro.2019$Destino[10] # Retorna os elementos da décima coluna &quot;Destino&quot; ## [1] &quot;Sulamericana&quot; Outra maneira de acessar informações pode através []. Campeonato.Brasileiro.2019[Campeonato.Brasileiro.2019$Equipes==&quot;Flamengo&quot;,] # Retorna apenas as informações da coluna &quot;Equipes&quot; que atendem o critério &quot;Flamengo&quot; ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró ## 1 Flamengo 38 28 6 4 86 ## Gols.Contra Pontos Saldo.de.Gols Aprov. Destino ## 1 37 90 49 79 Libertadores split(Campeonato.Brasileiro.2019,Destino) # Retorna apenas as informações da coluna &quot;Destino&quot; ## $Libertadores ## Equipes Jogos Vitórias Empates Derrotas ## 1 Flamengo 38 28 6 4 ## 2 Santos 38 22 8 8 ## 3 Palmeiras 38 21 11 6 ## 4 Grêmio 38 19 8 11 ## 5 Athletico Paranaense 38 18 10 10 ## 6 Sao Paulo 38 17 12 9 ## 7 Internacional 38 16 9 13 ## 8 Corinthians 38 14 14 10 ## Gols.Pró Gols.Contra Pontos Saldo.de.Gols Aprov. ## 1 86 37 90 49 79 ## 2 60 33 74 27 65 ## 3 61 32 74 29 65 ## 4 64 39 65 25 57 ## 5 51 32 64 19 56 ## 6 39 30 63 9 55 ## 7 44 39 57 5 5 ## 8 42 34 56 8 49 ## Destino ## 1 Libertadores ## 2 Libertadores ## 3 Libertadores ## 4 Libertadores ## 5 Libertadores ## 6 Libertadores ## 7 Libertadores ## 8 Libertadores ## ## $`NA` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró ## 15 Botafogo 38 13 4 21 31 ## 16 Ceará 38 10 9 19 36 ## Gols.Contra Pontos Saldo.de.Gols Aprov. Destino ## 15 45 43 -14 38 NA ## 16 41 39 -5 34 NA ## ## $Rebaixado ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró ## 17 Cruzeiro 38 7 15 16 27 ## 18 CSA 38 8 8 22 24 ## 19 Chapecoense 38 7 11 20 31 ## 20 Avaí 38 3 11 24 18 ## Gols.Contra Pontos Saldo.de.Gols Aprov. Destino ## 17 46 36 -19 32 Rebaixado ## 18 58 32 -34 28 Rebaixado ## 19 52 32 -21 28 Rebaixado ## 20 62 20 -44 18 Rebaixado ## ## $Sulamericana ## Equipes Jogos Vitórias Empates Derrotas ## 9 Fortaleza 38 15 8 15 ## 10 Goiás 38 15 7 16 ## 11 Bahia 38 12 13 13 ## 12 Vasco da Gama 38 12 13 13 ## 13 Atlético Mineiro 38 13 9 16 ## 14 Fluminense 38 12 10 16 ## Gols.Pró Gols.Contra Pontos Saldo.de.Gols Aprov. ## 9 50 49 53 1 46 ## 10 46 64 52 -18 46 ## 11 44 43 49 1 43 ## 12 39 45 49 -6 43 ## 13 45 49 48 -4 42 ## 14 38 46 46 -8 4 ## Destino ## 9 Sulamericana ## 10 Sulamericana ## 11 Sulamericana ## 12 Sulamericana ## 13 Sulamericana ## 14 Sulamericana Vou criar alguns verores aleatórios. gr1 &lt;- rep(letters[1:4],each=5) gr1 ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; &quot;c&quot; ## [14] &quot;c&quot; &quot;c&quot; &quot;d&quot; &quot;d&quot; &quot;d&quot; &quot;d&quot; &quot;d&quot; gr2 &lt;- c(rep(1:2,each=5),rep(2:3,each=5)) gr2 ## [1] 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 fc1 &lt;- factor(rep(letters[1:4],each=5)) fc1 ## [1] a a a a a b b b b b c c c c c d d d d d ## Levels: a b c d fc2 &lt;- factor(c(rep(1:2,each=5),rep(2:3,each=5))) fc2 ## [1] 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 ## Levels: 1 2 3 split(Campeonato.Brasileiro.2019,f=(gr1)) # Divide o Campeonato.Brasileiro.2019 de acordo com os vetores informados ## $a ## Equipes Jogos Vitórias Empates Derrotas ## 1 Flamengo 38 28 6 4 ## 2 Santos 38 22 8 8 ## 3 Palmeiras 38 21 11 6 ## 4 Grêmio 38 19 8 11 ## 5 Athletico Paranaense 38 18 10 10 ## Gols.Pró Gols.Contra Pontos Saldo.de.Gols Aprov. ## 1 86 37 90 49 79 ## 2 60 33 74 27 65 ## 3 61 32 74 29 65 ## 4 64 39 65 25 57 ## 5 51 32 64 19 56 ## Destino ## 1 Libertadores ## 2 Libertadores ## 3 Libertadores ## 4 Libertadores ## 5 Libertadores ## ## $b ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró ## 6 Sao Paulo 38 17 12 9 39 ## 7 Internacional 38 16 9 13 44 ## 8 Corinthians 38 14 14 10 42 ## 9 Fortaleza 38 15 8 15 50 ## 10 Goiás 38 15 7 16 46 ## Gols.Contra Pontos Saldo.de.Gols Aprov. Destino ## 6 30 63 9 55 Libertadores ## 7 39 57 5 5 Libertadores ## 8 34 56 8 49 Libertadores ## 9 49 53 1 46 Sulamericana ## 10 64 52 -18 46 Sulamericana ## ## $c ## Equipes Jogos Vitórias Empates Derrotas ## 11 Bahia 38 12 13 13 ## 12 Vasco da Gama 38 12 13 13 ## 13 Atlético Mineiro 38 13 9 16 ## 14 Fluminense 38 12 10 16 ## 15 Botafogo 38 13 4 21 ## Gols.Pró Gols.Contra Pontos Saldo.de.Gols Aprov. ## 11 44 43 49 1 43 ## 12 39 45 49 -6 43 ## 13 45 49 48 -4 42 ## 14 38 46 46 -8 4 ## 15 31 45 43 -14 38 ## Destino ## 11 Sulamericana ## 12 Sulamericana ## 13 Sulamericana ## 14 Sulamericana ## 15 NA ## ## $d ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró ## 16 Ceará 38 10 9 19 36 ## 17 Cruzeiro 38 7 15 16 27 ## 18 CSA 38 8 8 22 24 ## 19 Chapecoense 38 7 11 20 31 ## 20 Avaí 38 3 11 24 18 ## Gols.Contra Pontos Saldo.de.Gols Aprov. Destino ## 16 41 39 -5 34 NA ## 17 46 36 -19 32 Rebaixado ## 18 58 32 -34 28 Rebaixado ## 19 52 32 -21 28 Rebaixado ## 20 62 20 -44 18 Rebaixado split(Campeonato.Brasileiro.2019,f=(gr2)) # Divide o Campeonato.Brasileiro.2019 de acordo com os vetores informados ## $`1` ## Equipes Jogos Vitórias Empates Derrotas ## 1 Flamengo 38 28 6 4 ## 2 Santos 38 22 8 8 ## 3 Palmeiras 38 21 11 6 ## 4 Grêmio 38 19 8 11 ## 5 Athletico Paranaense 38 18 10 10 ## Gols.Pró Gols.Contra Pontos Saldo.de.Gols Aprov. ## 1 86 37 90 49 79 ## 2 60 33 74 27 65 ## 3 61 32 74 29 65 ## 4 64 39 65 25 57 ## 5 51 32 64 19 56 ## Destino ## 1 Libertadores ## 2 Libertadores ## 3 Libertadores ## 4 Libertadores ## 5 Libertadores ## ## $`2` ## Equipes Jogos Vitórias Empates Derrotas ## 6 Sao Paulo 38 17 12 9 ## 7 Internacional 38 16 9 13 ## 8 Corinthians 38 14 14 10 ## 9 Fortaleza 38 15 8 15 ## 10 Goiás 38 15 7 16 ## 11 Bahia 38 12 13 13 ## 12 Vasco da Gama 38 12 13 13 ## 13 Atlético Mineiro 38 13 9 16 ## 14 Fluminense 38 12 10 16 ## 15 Botafogo 38 13 4 21 ## Gols.Pró Gols.Contra Pontos Saldo.de.Gols Aprov. ## 6 39 30 63 9 55 ## 7 44 39 57 5 5 ## 8 42 34 56 8 49 ## 9 50 49 53 1 46 ## 10 46 64 52 -18 46 ## 11 44 43 49 1 43 ## 12 39 45 49 -6 43 ## 13 45 49 48 -4 42 ## 14 38 46 46 -8 4 ## 15 31 45 43 -14 38 ## Destino ## 6 Libertadores ## 7 Libertadores ## 8 Libertadores ## 9 Sulamericana ## 10 Sulamericana ## 11 Sulamericana ## 12 Sulamericana ## 13 Sulamericana ## 14 Sulamericana ## 15 NA ## ## $`3` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró ## 16 Ceará 38 10 9 19 36 ## 17 Cruzeiro 38 7 15 16 27 ## 18 CSA 38 8 8 22 24 ## 19 Chapecoense 38 7 11 20 31 ## 20 Avaí 38 3 11 24 18 ## Gols.Contra Pontos Saldo.de.Gols Aprov. Destino ## 16 41 39 -5 34 NA ## 17 46 36 -19 32 Rebaixado ## 18 58 32 -34 28 Rebaixado ## 19 52 32 -21 28 Rebaixado ## 20 62 20 -44 18 Rebaixado split(Campeonato.Brasileiro.2019,f=list(gr1,gr2), drop = TRUE, sep = &quot;: &quot;) # Divide o Campeonato.Brasileiro.2019 de acordo com as listas informadas ## $`a: 1` ## Equipes Jogos Vitórias Empates Derrotas ## 1 Flamengo 38 28 6 4 ## 2 Santos 38 22 8 8 ## 3 Palmeiras 38 21 11 6 ## 4 Grêmio 38 19 8 11 ## 5 Athletico Paranaense 38 18 10 10 ## Gols.Pró Gols.Contra Pontos Saldo.de.Gols Aprov. ## 1 86 37 90 49 79 ## 2 60 33 74 27 65 ## 3 61 32 74 29 65 ## 4 64 39 65 25 57 ## 5 51 32 64 19 56 ## Destino ## 1 Libertadores ## 2 Libertadores ## 3 Libertadores ## 4 Libertadores ## 5 Libertadores ## ## $`b: 2` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró ## 6 Sao Paulo 38 17 12 9 39 ## 7 Internacional 38 16 9 13 44 ## 8 Corinthians 38 14 14 10 42 ## 9 Fortaleza 38 15 8 15 50 ## 10 Goiás 38 15 7 16 46 ## Gols.Contra Pontos Saldo.de.Gols Aprov. Destino ## 6 30 63 9 55 Libertadores ## 7 39 57 5 5 Libertadores ## 8 34 56 8 49 Libertadores ## 9 49 53 1 46 Sulamericana ## 10 64 52 -18 46 Sulamericana ## ## $`c: 2` ## Equipes Jogos Vitórias Empates Derrotas ## 11 Bahia 38 12 13 13 ## 12 Vasco da Gama 38 12 13 13 ## 13 Atlético Mineiro 38 13 9 16 ## 14 Fluminense 38 12 10 16 ## 15 Botafogo 38 13 4 21 ## Gols.Pró Gols.Contra Pontos Saldo.de.Gols Aprov. ## 11 44 43 49 1 43 ## 12 39 45 49 -6 43 ## 13 45 49 48 -4 42 ## 14 38 46 46 -8 4 ## 15 31 45 43 -14 38 ## Destino ## 11 Sulamericana ## 12 Sulamericana ## 13 Sulamericana ## 14 Sulamericana ## 15 NA ## ## $`d: 3` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró ## 16 Ceará 38 10 9 19 36 ## 17 Cruzeiro 38 7 15 16 27 ## 18 CSA 38 8 8 22 24 ## 19 Chapecoense 38 7 11 20 31 ## 20 Avaí 38 3 11 24 18 ## Gols.Contra Pontos Saldo.de.Gols Aprov. Destino ## 16 41 39 -5 34 NA ## 17 46 36 -19 32 Rebaixado ## 18 58 32 -34 28 Rebaixado ## 19 52 32 -21 28 Rebaixado ## 20 62 20 -44 18 Rebaixado Alterando elementos dentro do data frame. Campeonato.Brasileiro.2019$Destino # Retorna apenas as informações da coluna &quot;Destino&quot; ## [1] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; ## [4] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; ## [7] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Sulamericana&quot; ## [10] &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;Sulamericana&quot; ## [13] &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;NA&quot; ## [16] &quot;NA&quot; &quot;Rebaixado&quot; &quot;Rebaixado&quot; ## [19] &quot;Rebaixado&quot; &quot;Rebaixado&quot; Campeonato.Brasileiro.2019$Destino[Campeonato.Brasileiro.2019$Destino==&quot;NA&quot;]&lt;-&quot;Lugar Algum&quot; # Substitui &quot;Libertadores&quot; na coluna &quot;Destino&quot; por &quot;Liberta&quot;. Veja como ficou com a informação alterada. Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores Sao Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 10 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana Bahia 38 12 13 13 44 43 49 1 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 -6 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana Botafogo 38 13 4 21 31 45 43 -14 38 Lugar Algum Ceará 38 10 9 19 36 41 39 -5 34 Lugar Algum Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado CSA 38 8 8 22 24 58 32 -34 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado Vamos expurgar remover o Vasco da Gama da nossa lista. Campeonato.Brasileiro.2019$Equipes # Retorna apenas as informações da coluna &quot;Equipes&quot; ## [1] &quot;Flamengo&quot; &quot;Santos&quot; ## [3] &quot;Palmeiras&quot; &quot;Grêmio&quot; ## [5] &quot;Athletico Paranaense&quot; &quot;Sao Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; ## [9] &quot;Fortaleza&quot; &quot;Goiás&quot; ## [11] &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atlético Mineiro&quot; &quot;Fluminense&quot; ## [15] &quot;Botafogo&quot; &quot;Ceará&quot; ## [17] &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; Campeonato.Brasileiro.2019.SV&lt;-Campeonato.Brasileiro.2019[Campeonato.Brasileiro.2019$Equipes!=&quot;Vasco da Gama&quot;,] #Seleciona tudo exceto aquilo que for de &quot;Vasco da Gama&quot; Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino 1 Flamengo 38 28 6 4 86 37 90 49 79 Libertadores 2 Santos 38 22 8 8 60 33 74 27 65 Libertadores 3 Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores 4 Grêmio 38 19 8 11 64 39 65 25 57 Libertadores 5 Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores 6 Sao Paulo 38 17 12 9 39 30 63 9 55 Libertadores 7 Internacional 38 16 9 13 44 39 57 5 5 Libertadores 8 Corinthians 38 14 14 10 42 34 56 8 49 Libertadores 9 Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana 10 Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana 11 Bahia 38 12 13 13 44 43 49 1 43 Sulamericana 13 Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana 14 Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana 15 Botafogo 38 13 4 21 31 45 43 -14 38 Lugar Algum 16 Ceará 38 10 9 19 36 41 39 -5 34 Lugar Algum 17 Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado 18 CSA 38 8 8 22 24 58 32 -34 28 Rebaixado 19 Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado 20 Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado Atendendo a pedidos, vamos continuar brevemente com manipulação de dados em data.frame. As funções grep, grepl, regexpr, gregexpr e regexec busca por elementos de um objeto que coincidem com um argumento padrão. 3.1.2 grep() grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino) # retorna as posições de tudo no vetor Campeonato.Brasileiro.2019$Destino que coincide com Lugar Algum ## [1] 15 16 Durante a aula gravada eu me enrolei um pouco na demonstração abaixo. Acontece que Libertadores estava escrito errado, estava escrito Libetadores (sem o r). grep(&quot;Libertadores|Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino) # retorna as posições de tudo no vetor Campeonato.Brasileiro.2019$Destino que coincide com Libetadores ou Lugar Algum ## [1] 1 2 3 4 5 6 7 8 15 16 grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino) # retorna as posições de tudo no vetor Campeonato.Brasileiro.2019$Destino que coincide com Lugar Algum ## [1] 15 16 Campeonato.Brasileiro.2019$Destino[15]&lt;-&quot;lugar algum&quot; #Substitui a 15ª posição por lugar algum&quot; Execute o comando grepanterior novamente e veja as diferenças. Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores Sao Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 10 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana Bahia 38 12 13 13 44 43 49 1 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 -6 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana Botafogo 38 13 4 21 31 45 43 -14 38 lugar algum Ceará 38 10 9 19 36 41 39 -5 34 Lugar Algum Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado CSA 38 8 8 22 24 58 32 -34 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado grep(&quot;[L l]ugar [A a]lgum&quot;,Campeonato.Brasileiro.2019$Destino) # retorna as posições de tudo no vetor Campeonato.Brasileiro.2019$Destino que coincide com Lugar/lugar ou Algum/algum ## [1] 15 16 str(grep(&quot;lugar algum&quot;, Campeonato.Brasileiro.2019$Destino)) ## int 15 str(grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino)) # mostra a estrutura de um objeto ## int 16 setdiff(grep(&quot;lugar algum&quot;, Campeonato.Brasileiro.2019$Destino), grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino)) #Identifica a difença entre X e Y ## [1] 15 setdiff(grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino), grep(&quot;lugar algum&quot;, Campeonato.Brasileiro.2019$Destino)) ## [1] 16 #install.packages(&quot;prob&quot;) library(prob) S &lt;- cards() A &lt;- subset(S, suit == &quot;Heart&quot;) A ## rank suit ## 27 2 Heart ## 28 3 Heart ## 29 4 Heart ## 30 5 Heart ## 31 6 Heart ## 32 7 Heart ## 33 8 Heart ## 34 9 Heart ## 35 10 Heart ## 36 J Heart ## 37 Q Heart ## 38 K Heart ## 39 A Heart B &lt;- subset(S, rank == &quot;A&quot; ) B ## rank suit ## 13 A Club ## 26 A Diamond ## 39 A Heart ## 52 A Spade setdiff(B, A) #Identifica a difença entre X e Y ## rank suit ## 1 A Club ## 2 A Diamond ## 3 A Spade Campeonato.Brasileiro.2019$Equipes[1] ## [1] &quot;Flamengo&quot; grep(&quot;Flamengo&quot;, Campeonato.Brasileiro.2019$Equipes, value = TRUE) ## [1] &quot;Flamengo&quot; 3.1.3 grepl() grepl(&quot;Flamengo&quot;, Campeonato.Brasileiro.2019$Equipes) # Retorna valores lógicos de acordo com o critério estabelecido ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [10] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [19] FALSE FALSE 3.1.4 sub() e gsub() sub(&quot;Fla&quot;, &quot;fla&quot;, Campeonato.Brasileiro.2019$Equipes) #Substitui Fla por fla naquilo que começa com Fla ## [1] &quot;flamengo&quot; &quot;Santos&quot; ## [3] &quot;Palmeiras&quot; &quot;Grêmio&quot; ## [5] &quot;Athletico Paranaense&quot; &quot;Sao Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; ## [9] &quot;Fortaleza&quot; &quot;Goiás&quot; ## [11] &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atlético Mineiro&quot; &quot;Fluminense&quot; ## [15] &quot;Botafogo&quot; &quot;Ceará&quot; ## [17] &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; gsub(&quot;Atlé|Athle&quot;, &quot;Atle&quot;, Campeonato.Brasileiro.2019$Equipes) #Substitui Atlé ou Athle por Atlé naquilo que contém com Atlé ou Athle ## [1] &quot;Flamengo&quot; &quot;Santos&quot; ## [3] &quot;Palmeiras&quot; &quot;Grêmio&quot; ## [5] &quot;Atletico Paranaense&quot; &quot;Sao Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; ## [9] &quot;Fortaleza&quot; &quot;Goiás&quot; ## [11] &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atletico Mineiro&quot; &quot;Fluminense&quot; ## [15] &quot;Botafogo&quot; &quot;Ceará&quot; ## [17] &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; Alguns elementos especiais podem ser encontrados no R como: Infinito positivo ou negativo (-Inf e Inf), elementos não número (NaN - Not a Number) e valores ausentes (NA, Not Available). 3/0 ## [1] Inf -3/0 ## [1] -Inf x&lt;-Inf;x ## [1] Inf y&lt;-(-Inf);y ## [1] -Inf 0/0 ## [1] NaN Inf-Inf ## [1] NaN Campeonato.Brasileiro.2019[Campeonato.Brasileiro.2019&lt;=10]&lt;-NA Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 NA NA 51 32 64 19 56 Libertadores Sao Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 NA 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 NA 46 Sulamericana Goiás 38 15 7 16 46 64 52 NA 46 Sulamericana Bahia 38 12 13 13 44 43 49 NA 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 NA 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 NA 42 Sulamericana Fluminense 38 12 NA 16 38 46 46 NA 4 Sulamericana Botafogo 38 13 4 21 31 45 43 NA 38 lugar algum Ceará 38 NA 9 19 36 41 39 NA 34 Lugar Algum Cruzeiro 38 7 15 16 27 46 36 NA 32 Rebaixado CSA 38 8 8 22 24 58 32 NA 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 NA 28 Rebaixado Avaí 38 3 11 24 18 62 20 NA 18 Rebaixado any(is.na(Campeonato.Brasileiro.2019)) ## [1] TRUE Identificando onde estão os valores que atendem critérios desejados. which(is.na(Campeonato.Brasileiro.2019), arr.ind=TRUE) ## row col ## [1,] 16 3 ## [2,] 5 4 ## [3,] 14 4 ## [4,] 5 5 ## [5,] 8 5 ## [6,] 9 9 ## [7,] 10 9 ## [8,] 11 9 ## [9,] 12 9 ## [10,] 13 9 ## [11,] 14 9 ## [12,] 15 9 ## [13,] 16 9 ## [14,] 17 9 ## [15,] 18 9 ## [16,] 19 9 ## [17,] 20 9 which((Campeonato.Brasileiro.2019&lt;1), arr.ind=TRUE) ## row col 3.2 Operadores Assista este conteúdo em Cap 2 - Operadores no PVANet O R tem vários operadores, tais quais outras linguagens, que nos permitem realizar procedimentos aritiméticos, lógicos ou relacionais. Os operadores aritméticos atuam em 2 elementos (x e y) e retorna respostas lógicas. Estes elementos, pos sua vez, podem ser de modo (mode()) numéricos ou complexos e também variáveis lógicas. Símbolo Operação + adição - subtração * multiplicação / divisão ^ potência %% resto da divisão %/% divisão inteira x&lt;-2;y&lt;-3 x+y ## [1] 5 x-y ## [1] -1 x*y ## [1] 6 y/x ## [1] 1.5 y%/%x ## [1] 1 y%%x ## [1] 1 y^x ## [1] 9 Os operadores de comparações atuam em cada elemento de 2 objetos sob comparação (fazendo o recycling se necessário) retornando um objeto do mesmo tamanho. Símbolo Relação &lt; menor que &gt; maior que &lt;= menor ou igual &gt;= maior ou igual == igual != diferente x&lt;-1:3;y&lt;-1:3 x&gt;y ## [1] FALSE FALSE FALSE x&lt;y ## [1] FALSE FALSE FALSE x*y ## [1] 1 4 9 y&gt;=x ## [1] TRUE TRUE TRUE y&lt;=x ## [1] TRUE TRUE TRUE y==x ## [1] TRUE TRUE TRUE y!=x ## [1] FALSE FALSE FALSE Caso queira comparar bancos de dados completos, por inteiro de uma vez só, utilize identical(x,y) e all.equal(x,y). identicalfaz uma comparação estrita da representação dos objetos e retorna como TRUE ou FALSE. all.equal compara a igualdade próxima e retorna TRUE ou mostra as diferenças. x&lt;-0.9;y&lt;-0.9 identical(x,y) ## [1] TRUE identical(0.9, 1.1 - 0.2) ## [1] FALSE all.equal(x,y) ## [1] TRUE all.equal(0.9, 1.1 - 0.2, tolerance = 1e-16) ## [1] &quot;Mean relative difference: 1.233581e-16&quot; Operadores lógicos são utilizados para para testes lógicos entre 1 ou 2 objetos e retorna valores lógicos também. Símbolo Relação ! Logical NOT &amp; Logical AND or Exclusive OR Lembrando que temos outro operadores $, @, [, [[, :, ?, &lt;-, &lt;&lt;-, =, :: que já começamos a manipular. Existem dois tipos de pessoas: = &amp; &lt;- Com o passar do tempo vamos brincando com cada operador e, assim, assimilando o que cada uma faz. 3.2.1 Iterações 3.2.1.1 while() Essa forma de loop é menos comumente usada e potencialmente perigosa, uma vez que ela pode resultar em uma execução descontrolada. Por isso, em muitos casos iterações restritivas são mais adequadas. A função while() requer uma condição testável que continuará a resultar em declarações subsequentes a serem executadas até o resultado do teste dar falso (FALSE). Estrutura: Começa com a palavra while seguida por parênteses e colchetes while(){} A segunda parte vai dentro de parênteses e diz respeito a uma expressão lógica e a terceira parte, entre colchetes, o corpo do loop. while(abc){xyz} #Se abc for TRUE ele vai executar o resto {xyz}. Depois volta para checar se (abc) continua TRUE ou FALSE para decidir se continua no loop ou parar. while(condição){ Código a ser executado } Fonte: Guru99 Exemplo 1: Teste Ter aula na segunda-feira é bom ou não? while(FALSE){ print(&quot;Aula segunda-feira é ótimo!&quot;)} while(TRUE){ print(&quot;Aula segunda-feira é ótimo!&quot;)} Exemplo 2: Teste Num concurso de beleza Jackson desafiou qualquer um de seus alunos. Cada um recebeu uma nota. Jackson&lt;-9.5 Aluno&lt;-6 while(Aluno&lt;Jackson){ print(Jackson)} 3.2.1.2 for() É similar ao while(), mas é mais conveniente na maioria dos casos. Iterações restritas (loops) destinam-se a execução de um número fixo de vezes dos comandos usando a função for(). O loop é executado tantas vezes quanto variam os valores de i. Começa com a palavra for seguindo de por parênteses e colchetes  for(){}. () não especifica funções lógicas como no while, mas especifica as interações do loop. {} são usados para preencher com os comandos do loop for(i in conjunto_de_valores){ comandos que serão repetidos } Fonte:tutorialspoint for(i in 1:5){ print(&quot;Aula segunda-feira é ótimo!&quot;) } ## [1] &quot;Aula segunda-feira é ótimo!&quot; ## [1] &quot;Aula segunda-feira é ótimo!&quot; ## [1] &quot;Aula segunda-feira é ótimo!&quot; ## [1] &quot;Aula segunda-feira é ótimo!&quot; ## [1] &quot;Aula segunda-feira é ótimo!&quot; Significa que Aula segunda-feira é ótimo! Será mostrada 5 vezes sempre retornando como o objeto criado i. for(i in 1:5){ print((i+1)*3) } ## [1] 6 ## [1] 9 ## [1] 12 ## [1] 15 ## [1] 18 Não importa onde você começa ou o tipo de vetor que é (Caractere, número e etc). Basicamente toda vez que mudar ele vai executar o que estiver dentro do corpo do loop. 3.2.2 Condicionais 3.2.2.1 if, else A função if() é usado para conduzir uma ou mais declarações contidas dentro de [], fornecendo a condição dentro de (). Voltando para nosso concurso de beleza, temos um controle um pouco mais inteligente do resultado mostrado. Jackson&lt;-9.5 Aluno&lt;-6 if(Jackson&gt;Aluno){ print(&quot;Jackson é mais bonito que Aluno!&quot;) } ## [1] &quot;Jackson é mais bonito que Aluno!&quot; if(Aluno*2&gt;=Jackson){ print(&quot;Aluno é mais bonito!&quot;) } ## [1] &quot;Aluno é mais bonito!&quot; Adaptando a o código acima para fazer a declaração condicional FALSE simplesmente retorna nenhum comando no prompt uma vez que o código não disse como R deveria responder nesse caso. if(Aluno*2&gt;=Jackson^2){ print(&quot;Aluno é mais bonito!&quot;) } Existem 2 métodos de informar ao R como responder em casos onde a declaração de condição é retornada como FALSE: usando o modificador else ou a função ifelse(). Ao contrário de uma função qualquer, else não pode ser usado independentemente, mas apenas como um modificador (adição) ao if(). If no exemplo acima, o resultado é solicitado quando o valor retornado é FALSE, else pode ser adicionado como segue: if(Aluno*2&gt;=Jackson^2){ print(&quot;A declaração é verdadeira!&quot;) }else{ print(&quot;A declaração é falsa!&quot;) } ## [1] &quot;A declaração é falsa!&quot; Note que else foi escrito na mesma linha que conclui o if() para informar ao R que o teste condicional continua. Podemos retirar a segunda parte do teste anterior e adicionar uma nova comparação. Aluno2&lt;-7 if(Aluno2&gt;Jackson){ print(&quot;Aluno1 é mais bonito!&quot;) }else if(Aluno2&gt;Aluno){ print(&quot;Aluno2 é mais bonito que Aluno e menos bonito que Jackson.&quot;) } ## [1] &quot;Aluno2 é mais bonito que Aluno e menos bonito que Jackson.&quot; 3.2.2.2 ifelse() A função ifelse() é separada de if() e é formada de uma sintaxe mais simples e concisa. No entanto, ela pode ser usada para gerar o mesmo efeito que nas demonstrações anteriores usando if() com o modificador else. ifelse(Aluno*2&gt;=Jackson^2, &quot;Aluno é mais bonito!&quot;, &quot;Jackson é mais bonito!&quot;) ## [1] &quot;Jackson é mais bonito!&quot; Como mostrado acima, o uso de ifelse() usa a forma: ifelse(teste condicional, resultado se verdadeiro, resultado se falso) Declarações condicionais também podem ser aninhadas dentro uma outra. Adaptando o exemplo com o argumento else um outro teste é executado se o teste inicial é FALSE, onde o secundário é TRUE. ifelse(Aluno*2&gt;=Jackson^2, &quot;Aluno é mais bonito!&quot;, ifelse(Aluno*2&gt;=Jackson^0.5 ,&quot;Agora o Aluno é mais bonito!&quot;, &quot;Aluno continua feio!&quot;)) ## [1] &quot;Agora o Aluno é mais bonito!&quot; Se o teste secundário é ajustado de maneira que os resultados em um teste lógico FALSE, o seguinte resultado é retornado. ifelse(Aluno*2&gt;=Jackson^2, &quot;Aluno é mais bonito!&quot;, ifelse(Aluno*2&gt;=Jackson^3,&quot;Agora o Aluno é mais bonito!&quot;, &quot;Aluno continua feio!&quot;)) ## [1] &quot;Aluno continua feio!&quot; 3.3 Dica de leitura Mello and Peternelli (2013) Peng (2020b) Kabacoff (2015) Venables and Smith (2020) Neth (2021) Yamamoto (2020) Freire (2020) Spatial Data Science - Indexing Indexing into a data structure r-coder datamentor - R ifelse Statement 3.4 Exercícios Crie o vetor p que contenham uma sequência de 200 iniciando em 0 aumentando 0.5. Eleve o vetor p ao cubo criando o vetor o e multiplique por p. Organize p por linhas em uma matriz com 10 colunas . Crie os elementos x = 10 e y = 25. Mostre na tela A declaração é verdadeira sob a condição de x ser menor que y. Mostre 2 maneiras condicionais de executar a declaração na qual mostraria A declaração é correta se x é menor ou igual a y, ou caso contrário mostre A declaração é incorreta se não for o caso. Atribua z = 50 e construa uma função ifelse() que testa se x é maior que y, mostrando true se a condição é encontrada. Aninhe dentro disso uma segunda condição que mostre uma verdadeira, uma falsa ou ambas falsas caso x seja maior que z. Use uma iteração restrita para gerar uma sequência de números de 1 até 20. Use iteração restrita para conduzir o cálculo (i^2)-i, onde i vai de 5 até 10. Use interação não restrita para gerar uma sequência de inteiros de -10 até -20. References "],["acessando-e-criando-funções-importação-e-exportação-dados.html", "Capítulo 4 Acessando e criando Funções, Importação e exportação dados 4.1 Funções 4.2 Pacotes 4.3 Entrando com dados 4.4 Exercícios 4.5 Dica de leitura", " Capítulo 4 Acessando e criando Funções, Importação e exportação dados 4.1 Funções Assista este conteúdo em Cap 3 - Funções no PVANet Embora existam uma grande variedade de funções e pacotes disponíveis e crescendo em número, a grande versatilidade do R nos permite criar comandos/funções personalizadas. No entanto, uma dúvida que por ventura você tenha e não consiga sanar dentro das opções de ajuda do próprio R, buscar em fóruns sobre o assunto pode ser uma saída, pois geralmente a sua dúvida foi a dúvida de alguém antes de você. Vamos inicialmente dar uma olhada nas funções do próprio R. Até aqui vimos algumas funções como: c(), seq(), rep(), print(), is.numeric(), is.integer(), is.double(), is.character(), typeof(), which(), grep() e etc Para entender melhor como uma função funciona ou o que ela faz e permite fazer podemos pedir ajuda escrevendo ?nomedafunção. Por exemplo: ?rnorm #Gera um vetor de números aleatórios normalmente ditribuídos No display de ajuda da função rnorm()observamos como a função deve ser utilizada, quais parâmetros devem ser inseridos. rnorm(n, mean = 0, sd = 1) rnorm(5 ,10 , 8) #Vejam que não estão próximas de zero, mas de dez. ## [1] 14.453306 4.489954 4.340039 12.916656 16.148263 Podemos dar nomes aos parâmetros também, caso não sejam nomeados, os parâmetros seguirão a ordem estabelecida na função original inciada em n seguida de mean e sd. set.seed(1234) rnorm(n=5 ,mean=10 , sd=8) ## [1] 0.343474 12.219434 18.675529 -8.765582 13.432998 set.seed(1234) rnorm(mean=10,n=5, sd=8) # Uma vez nomeados, eles podem ser arranjados da maneira que desejar. ## [1] 0.343474 12.219434 18.675529 -8.765582 13.432998 Quando você executou ?rnorm, você deve ter percebido que existem outro comandos semelhantes: dnorm(x, mean = 0, sd = 1, log = FALSE) pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) dnorm retorna o valor da função de densidade de probabilidade para os parâmetros. fornececidos. dnorm(5, mean = 10, sd = 8) ## [1] 0.04102012 pnorm retorna a integral de -Inf até q de um pdf ( Probability density function) da distribuição normal onde q é o z-score. pnorm(5, mean = 10, sd = 8) ## [1] 0.2659855 qnorm é simplesmente o inverso do cdf ( cumulative distribution function), no qual você pode entender com o inverso de pnorm. qnorm(.2) # Responde como o z-score do vigèsimo elemento de uma distribuiçãop normal. ## [1] -0.8416212 Para mais detalhes sobre estas funções clique aqui. As funções acima e tantas outras estão disponíveis no R desde sua instalação, assim como as funções básicas abaixo. função Descrição abs(x) Valor absoluto sqrt(x) Raiz quadrada ceiling(x) Arredonda para o inteiro acima floor(x) Arredonda para o inteiro abaixo trunc(x) Trunca para um inteiro round(x,digits=n) Arredonda de acordo com número de casas decimais log(x) Logarítimo natural log10(x) Logarítmo decimal exp(x) Exponenciação de base e com expoente x sin(x) Seno em radianos cos(x) Cosseno em radianos tan(x) Tangente em radianos ## [1] 9.99 ## [1] 1.772454 ## [1] 4 ## [1] 3 ## [1] 3 ## [1] 3.14 ## [1] 1.14473 ## [1] 0.4971499 ## [1] 23.14069 ## [1] 1.224606e-16 ## [1] -1 ## [1] -1.224647e-16 Pesquise por asin(), acos(), atan(). Embora seja rico de opções, com funções dos mais variados tipos e aplicações às vezes não encontramos aquelas específicas que precisamos para algo específico. Ou, mesmo que esteja desenvolvendo uma metodologia nova com novos approaches ou um novo pacote você precisará impreterivelmente de criar suas próprias funções. As funções às vezes não são tão simples para uma primeira tentativa de uso ou criação principalmente para aqueles que estão iniciando em R ou qualquer linguagem de programação. Podemos imaginar a função dividida em 3 partes (entrada, processamento e saída) como uma caixa com muito buracos de uma lado ( inputs) e apenas um buraco do outro ( output) e a caixa atua de acordo com nossos comandos. Ou ainda como processamento de frutas para um suco. Estrutura de uma função Estrutura de uma função: * A função recebe um nome que recebe os argumentos e comandos a serem executados. O nome da função será o comando a ser executado sempre que desejado. Após o atribuidor vem o comando function seguindo de (). Dentro de () vem os argumentos (posição ou nomes) que são as variáveis ou outras informações inseridas pelo usuário. Após fechar os parênteses abre-se chaves {} onde entram as equações ou testes a serem executados e as opções de saídas com o comando return quer geralmente encontra-se ao final da função. Não há restrição sobre a estrutura ou tipo de objeto retornado (list, data.frame, matrix, numeric, logical  etc). Após o registro da função no ambiente do R (Veja o global environment), a função fica pronta para uso. minhafunção &lt;- function(arg1, arg2, ... ){ statements return(object) } Vamos criar uma função de divisão. divisao &lt;- function(x, y) { resultado &lt;- x/y print(resultado) } A função se chama divisao. Declare as variáveis x, y entre (); {} guardam os comandos a serem executados; resultado &lt;- x/y e print(resultado) são os comandos a serem executados. divisao(50,25) ## [1] 2 divisao(22,4.4) ## [1] 5 g&lt;-5 x&lt;-10 a&lt;-x divisao(g,a) ## [1] 0.5 divisao(a+g,g) ## [1] 3 Experimentem e vejam o que acontece. divisao(50,) ## Error in divisao(50, ): argument &quot;y&quot; is missing, with no default divisao(50,25,32) ## Error in divisao(50, 25, 32): unused argument (32) divisao(a,m) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 10.000000 2.000000 1.1111111 ## [2,] 5.000000 1.666667 1.0000000 ## [3,] 3.333333 1.428571 0.9090909 ## [4,] 2.500000 1.250000 0.8333333 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 0.7692308 0.5882353 0.4761905 ## [2,] 0.7142857 0.5555556 0.4545455 ## [3,] 0.6666667 0.5263158 0.4347826 ## [4,] 0.6250000 0.5000000 0.4166667 ***Escreva uma função teste chamada multiplicador que multiplica os valores 12.8, 19.2 e pi. _pi_é armazenado internamente pelo R com 6 casas decimais e pode ser chamada escrevendo pi.*** multiplicador &lt;- function(x, y, z) { resultado &lt;- x*y*z print(resultado) } # `print` mostra o resultado de um objeto ou operação multiplicador(12.8, 19.2, pi) ## [1] 772.0778 Escreva uma função teste chamada multiplicador que multiplica os valores um vetor com 50 números por outro de 50 números e armazene o resultado como G sem mostrá-los na tela s&lt;-seq(from= 1,to=10, length.out=50); length(s) ## [1] 50 s ## [1] 1.000000 1.183673 1.367347 1.551020 1.734694 ## [6] 1.918367 2.102041 2.285714 2.469388 2.653061 ## [11] 2.836735 3.020408 3.204082 3.387755 3.571429 ## [16] 3.755102 3.938776 4.122449 4.306122 4.489796 ## [21] 4.673469 4.857143 5.040816 5.224490 5.408163 ## [26] 5.591837 5.775510 5.959184 6.142857 6.326531 ## [31] 6.510204 6.693878 6.877551 7.061224 7.244898 ## [36] 7.428571 7.612245 7.795918 7.979592 8.163265 ## [41] 8.346939 8.530612 8.714286 8.897959 9.081633 ## [46] 9.265306 9.448980 9.632653 9.816327 10.000000 d&lt;-seq(from=1,to=10,length.out = length(s)) d ## [1] 1.000000 1.183673 1.367347 1.551020 1.734694 ## [6] 1.918367 2.102041 2.285714 2.469388 2.653061 ## [11] 2.836735 3.020408 3.204082 3.387755 3.571429 ## [16] 3.755102 3.938776 4.122449 4.306122 4.489796 ## [21] 4.673469 4.857143 5.040816 5.224490 5.408163 ## [26] 5.591837 5.775510 5.959184 6.142857 6.326531 ## [31] 6.510204 6.693878 6.877551 7.061224 7.244898 ## [36] 7.428571 7.612245 7.795918 7.979592 8.163265 ## [41] 8.346939 8.530612 8.714286 8.897959 9.081633 ## [46] 9.265306 9.448980 9.632653 9.816327 10.000000 multiplicador &lt;- function(x, y){ resultado &lt;- x*y assign(&quot;resultado&quot;, resultado, envir=globalenv()) } # `assign` atribui os valores de uma operação a um objeto multiplicador(s,d) resultado ## [1] 1.000000 1.401083 1.869638 2.405664 3.009163 ## [6] 3.680133 4.418576 5.224490 6.097876 7.038734 ## [11] 8.047064 9.122865 10.266139 11.476885 12.755102 ## [16] 14.100791 15.513953 16.994586 18.542691 20.158267 ## [21] 21.841316 23.591837 25.409829 27.295294 29.248230 ## [26] 31.268638 33.356518 35.511870 37.734694 40.024990 ## [31] 42.382757 44.807997 47.300708 49.860891 52.488546 ## [36] 55.183673 57.946272 60.776343 63.673886 66.638900 ## [41] 69.671387 72.771345 75.938776 79.173678 82.476052 ## [46] 85.845898 89.283215 92.788005 96.360267 100.000000 media &lt;- function( x = c( 1, 1, 1, 1)){ #Neste caso utilizamos valores default que permitem testes caso algo saia errado #Calcula média do inpout x out &lt;- sum(x)/length(x) return( out) # `return` devolve/retorna/mostra os resultado de uma operação ou objeto } minha.media &lt;- media( x = 1: 100) # print result print( my.mean) print(minha.media) ## [1] 50.5 As funções também permitem maior interação com usuário para a tomada de uma decisão por exemplo. mensagem &lt;- function( arg1=readline(prompt=&quot;escreva sua mensagem: &quot;), arg2 = readline(prompt=&quot;De novo: &quot;)){ msg1 &lt;- paste0(arg1) msg2 &lt;- paste0(arg2) cat( msg1, msg2) } mensagem() ## Olá Mundo! Hello World! 4.2 Pacotes Assista este conteúdo em Cap 3 - Pacotes no PVANet 4.2.1 O que são? De onde vem? Para onde vão? Do que se alimentam? Quando iniciamos o R pouco mais de 2000 funções e outros objetos na memória estão prontos para uso. No R temos os pacotes que são feitos para cálculos estatísticos dos mais variados, pacotes para fazer gráficos, pacotes aplicados à um determinado tipo de dado ou subdivisão da ciência e etc Eles basicamente permitem vocês expandirem a funcionalidade do R para programação, ao invés de escrever dezenas de linhas de códigos, esses códigos são preparados, empacotados e tudo que você precisa fazer e usá-lo. Os Packages são coleções de funções, dados, e códigos compilados num formato bem definido. O diretório onde os pacotes estão armazenados são chamados library. A função .libPaths() onde sua biblioteca está alojada. .libPaths() ## [1] &quot;C:/Users/jacks/Documents/R/win-library/4.1&quot; ## [2] &quot;C:/Program Files/R/R-4.1.0/library&quot; Milhares de outras funções, para as mais diversas tarefas, podem ser adicionadas por meio de pacotes (packages) disponíveis livremente na internet. No entanto, a principal fonte de pacotes para o R é o CRAN, mas também temos r-forge, github e outras fontes pela internet. CRAN now has 10,000 R packages. Heres how to find the ones you need. !!!!!!!!!! Não é porque um pacote está no CRAN que ele foi testado e funciona perfeitamente!!!!!!!!! lista de pacotes no CRAN Para instalar um novo pacote, utilize a função install.packages(\"nome do pacote\") ou Tools-&gt;Install Packages-&gt;Install from (Repository CRAN) -&gt; Packages (escreva o nome do pacote). Para carregar na memória um pacote já instalado, library(nome do pacote) ou require(nome do pacote). Ao abrir lista de pacotes vemos quais estão disponíveis. Os que estão marcados estão ativados e disponíveis para uso. Aqueles que não estão marcados podem ser ativados e suas funções utilizadas. lista de pacotes instalados Vamos deletar o pacote ggplot2, basta clicar no x no lado direito. Agora vamos reinstalar pela barra de ferramentas. Mas o que CRAN quer dizer? É o local onde os pacotes são armazenados. R é um open source software então se você quiser, pode criar um pacote ar mazená-lo no CRAN. #install.packages(&quot;analogue&quot;) library(analogue) Visite Analogue e explore o que há disponível para o pacote analogue. Use a aba packages para explorar suas funcionalidades Muitas vezes os pacotes disponíveis no CRAN não estão UpToDate por isso talvez seja mais interessante isntalar os pacotes diretamente do github. Veja o pacote packman e vamos instalá-lo pelo github. Mas antes vamos instalar o pacote devtools que , entre outras coisas, nos permite buscar os pacotes do github. #install.packages(&quot;devtools&quot;) devtools::install_github(&quot;trinker/pacman&quot;) ## Skipping install of &#39;pacman&#39; from a github remote, the SHA1 (ace09364) has not changed since last install. ## Use `force = TRUE` to force installation Ao utilizar o software R e um pacote na execução de seu trabalho você deve citá-los. citation () # citação do software R ## ## To cite R in publications use: ## ## R Core Team (2021). R: A language and environment ## for statistical computing. R Foundation for ## Statistical Computing, Vienna, Austria. URL ## https://www.R-project.org/. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {R: A Language and Environment for Statistical Computing}, ## author = {{R Core Team}}, ## organization = {R Foundation for Statistical Computing}, ## address = {Vienna, Austria}, ## year = {2021}, ## url = {https://www.R-project.org/}, ## } ## ## We have invested a lot of time and effort in ## creating R, please cite it when using it for data ## analysis. See also &#39;citation(&quot;pkgname&quot;)&#39; for citing ## R packages. citation(package = &quot;analogue&quot;) # citação do pacote Analogue ## ## To cite use of &#39;analogue&#39; in publications use: ## ## Simpson, G.L. and Oksanen, J. ( 2021 ). analogue: ## Analogue matching and Modern Analogue Technique ## transfer function models. (R package version ## 0.17-6 ). ## (https://cran.r-project.org/package=analogue). ## ## Simpson, G.L. (2007). Analogue Methods in ## Palaeoecology: Using the analogue Package Journal ## of Statistical Software, 22(2), 1--29 ## ## To see these entries in BibTeX format, use ## &#39;print(&lt;citation&gt;, bibtex=TRUE)&#39;, &#39;toBibtex(.)&#39;, or ## set &#39;options(citation.bibtex.max=999)&#39;. Aqui listo os pacotes carregados agora em meu R. (.packages()) ## [1] &quot;ggpubr&quot; &quot;forcats&quot; &quot;stringr&quot; ## [4] &quot;dplyr&quot; &quot;purrr&quot; &quot;readr&quot; ## [7] &quot;tidyr&quot; &quot;tibble&quot; &quot;tidyverse&quot; ## [10] &quot;viridis&quot; &quot;viridisLite&quot; &quot;unikn&quot; ## [13] &quot;RColorBrewer&quot; &quot;analogue&quot; &quot;vegan&quot; ## [16] &quot;lattice&quot; &quot;permute&quot; &quot;flow&quot; ## [19] &quot;prob&quot; &quot;fAsianOptions&quot; &quot;fOptions&quot; ## [22] &quot;fBasics&quot; &quot;timeSeries&quot; &quot;timeDate&quot; ## [25] &quot;combinat&quot; &quot;magrittr&quot; &quot;ggplot2&quot; ## [28] &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; ## [31] &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [34] &quot;base&quot; Aqui listo os pacotes instalados em meu R. meus.pacotes &lt;- library()$results[,1] meus.pacotes ## [1] &quot;abind&quot; &quot;analogue&quot; ## [3] &quot;askpass&quot; &quot;assertthat&quot; ## [5] &quot;audio&quot; &quot;backports&quot; ## [7] &quot;base64enc&quot; &quot;beepr&quot; ## [9] &quot;BH&quot; &quot;bibtex&quot; ## [11] &quot;bitops&quot; &quot;blob&quot; ## [13] &quot;blogdown&quot; &quot;bookdown&quot; ## [15] &quot;brew&quot; &quot;brglm&quot; ## [17] &quot;brio&quot; &quot;broom&quot; ## [19] &quot;bslib&quot; &quot;cachem&quot; ## [21] &quot;callr&quot; &quot;car&quot; ## [23] &quot;carData&quot; &quot;caret&quot; ## [25] &quot;cellranger&quot; &quot;checkmate&quot; ## [27] &quot;classInt&quot; &quot;cli&quot; ## [29] &quot;clipr&quot; &quot;coda&quot; ## [31] &quot;colorspace&quot; &quot;combinat&quot; ## [33] &quot;commonmark&quot; &quot;conquer&quot; ## [35] &quot;corrplot&quot; &quot;cowplot&quot; ## [37] &quot;cpp11&quot; &quot;crayon&quot; ## [39] &quot;credentials&quot; &quot;crosstalk&quot; ## [41] &quot;crul&quot; &quot;curl&quot; ## [43] &quot;data.table&quot; &quot;DBI&quot; ## [45] &quot;dbplyr&quot; &quot;decido&quot; ## [47] &quot;deldir&quot; &quot;desc&quot; ## [49] &quot;devtools&quot; &quot;dichromat&quot; ## [51] &quot;diffobj&quot; &quot;digest&quot; ## [53] &quot;doParallel&quot; &quot;dotCall64&quot; ## [55] &quot;dplyr&quot; &quot;dtplyr&quot; ## [57] &quot;e1071&quot; &quot;easyGgplot2&quot; ## [59] &quot;ellipsis&quot; &quot;evaluate&quot; ## [61] &quot;expm&quot; &quot;extraDistr&quot; ## [63] &quot;fansi&quot; &quot;farver&quot; ## [65] &quot;fAsianOptions&quot; &quot;fastmap&quot; ## [67] &quot;fBasics&quot; &quot;fields&quot; ## [69] &quot;flow&quot; &quot;fOptions&quot; ## [71] &quot;forcats&quot; &quot;foreach&quot; ## [73] &quot;Formula&quot; &quot;formula.tools&quot; ## [75] &quot;fs&quot; &quot;gargle&quot; ## [77] &quot;gbm&quot; &quot;gdata&quot; ## [79] &quot;generics&quot; &quot;geobr&quot; ## [81] &quot;geojsonsf&quot; &quot;geometries&quot; ## [83] &quot;geosphere&quot; &quot;gert&quot; ## [85] &quot;ggplot2&quot; &quot;ggpubr&quot; ## [87] &quot;ggrepel&quot; &quot;ggsci&quot; ## [89] &quot;ggsignif&quot; &quot;gh&quot; ## [91] &quot;gitcreds&quot; &quot;glcm&quot; ## [93] &quot;glue&quot; &quot;gmodels&quot; ## [95] &quot;goftest&quot; &quot;googledrive&quot; ## [97] &quot;googlesheets4&quot; &quot;gower&quot; ## [99] &quot;gridExtra&quot; &quot;gss&quot; ## [101] &quot;gtable&quot; &quot;gtools&quot; ## [103] &quot;haven&quot; &quot;hexbin&quot; ## [105] &quot;highr&quot; &quot;hms&quot; ## [107] &quot;htmltools&quot; &quot;htmlwidgets&quot; ## [109] &quot;httpcode&quot; &quot;httpuv&quot; ## [111] &quot;httr&quot; &quot;ids&quot; ## [113] &quot;igraph&quot; &quot;ini&quot; ## [115] &quot;ipred&quot; &quot;isoband&quot; ## [117] &quot;iterators&quot; &quot;jpeg&quot; ## [119] &quot;jquerylib&quot; &quot;jsonify&quot; ## [121] &quot;jsonlite&quot; &quot;kableExtra&quot; ## [123] &quot;kernlab&quot; &quot;kknn&quot; ## [125] &quot;knitr&quot; &quot;kohonen&quot; ## [127] &quot;labeling&quot; &quot;later&quot; ## [129] &quot;latticeExtra&quot; &quot;lava&quot; ## [131] &quot;lazyeval&quot; &quot;leafem&quot; ## [133] &quot;leaflet&quot; &quot;leaflet.providers&quot; ## [135] &quot;leafsync&quot; &quot;LearnBayes&quot; ## [137] &quot;lifecycle&quot; &quot;lme4&quot; ## [139] &quot;lubridate&quot; &quot;lwgeom&quot; ## [141] &quot;magick&quot; &quot;magrittr&quot; ## [143] &quot;maps&quot; &quot;maptools&quot; ## [145] &quot;maptree&quot; &quot;markdown&quot; ## [147] &quot;MatrixModels&quot; &quot;matrixStats&quot; ## [149] &quot;memoise&quot; &quot;metR&quot; ## [151] &quot;mime&quot; &quot;miniUI&quot; ## [153] &quot;minqa&quot; &quot;mlbench&quot; ## [155] &quot;ModelMetrics&quot; &quot;modelr&quot; ## [157] &quot;munsell&quot; &quot;ncdf4&quot; ## [159] &quot;NeuralNetTools&quot; &quot;nloptr&quot; ## [161] &quot;nomnoml&quot; &quot;numDeriv&quot; ## [163] &quot;openssl&quot; &quot;openxlsx&quot; ## [165] &quot;operator.tools&quot; &quot;pacman&quot; ## [167] &quot;pbkrtest&quot; &quot;permute&quot; ## [169] &quot;pillar&quot; &quot;pkgbuild&quot; ## [171] &quot;pkgconfig&quot; &quot;pkgload&quot; ## [173] &quot;plyr&quot; &quot;png&quot; ## [175] &quot;polyclip&quot; &quot;polynom&quot; ## [177] &quot;praise&quot; &quot;prettyunits&quot; ## [179] &quot;princurve&quot; &quot;prob&quot; ## [181] &quot;pROC&quot; &quot;processx&quot; ## [183] &quot;prodlim&quot; &quot;profileModel&quot; ## [185] &quot;progress&quot; &quot;progressr&quot; ## [187] &quot;promises&quot; &quot;proxy&quot; ## [189] &quot;ps&quot; &quot;purrr&quot; ## [191] &quot;quantreg&quot; &quot;R.cache&quot; ## [193] &quot;R.methodsS3&quot; &quot;R.oo&quot; ## [195] &quot;R.utils&quot; &quot;R6&quot; ## [197] &quot;randomForest&quot; &quot;rapidjsonr&quot; ## [199] &quot;rappdirs&quot; &quot;raster&quot; ## [201] &quot;rasterVis&quot; &quot;rayimage&quot; ## [203] &quot;rayrender&quot; &quot;rayshader&quot; ## [205] &quot;rcmdcheck&quot; &quot;RColorBrewer&quot; ## [207] &quot;Rcpp&quot; &quot;RcppArmadillo&quot; ## [209] &quot;RcppEigen&quot; &quot;RcppThread&quot; ## [211] &quot;RCurl&quot; &quot;readr&quot; ## [213] &quot;readxl&quot; &quot;recipes&quot; ## [215] &quot;rematch&quot; &quot;rematch2&quot; ## [217] &quot;remotes&quot; &quot;reprex&quot; ## [219] &quot;reshape&quot; &quot;reshape2&quot; ## [221] &quot;rgdal&quot; &quot;rgeos&quot; ## [223] &quot;rgl&quot; &quot;rio&quot; ## [225] &quot;rJava&quot; &quot;rlang&quot; ## [227] &quot;rmarkdown&quot; &quot;rnaturalearth&quot; ## [229] &quot;rnaturalearthdata&quot; &quot;RNCEP&quot; ## [231] &quot;roxygen2&quot; &quot;rpart.plot&quot; ## [233] &quot;rprojroot&quot; &quot;rstatix&quot; ## [235] &quot;RStoolbox&quot; &quot;rstudioapi&quot; ## [237] &quot;rversions&quot; &quot;rvest&quot; ## [239] &quot;sass&quot; &quot;scales&quot; ## [241] &quot;selectr&quot; &quot;servr&quot; ## [243] &quot;sessioninfo&quot; &quot;sf&quot; ## [245] &quot;sfheaders&quot; &quot;shiny&quot; ## [247] &quot;sourcetools&quot; &quot;sp&quot; ## [249] &quot;spacefillr&quot; &quot;spam&quot; ## [251] &quot;SparseM&quot; &quot;spatialEco&quot; ## [253] &quot;spatstat.core&quot; &quot;spatstat.data&quot; ## [255] &quot;spatstat.geom&quot; &quot;spatstat.sparse&quot; ## [257] &quot;spatstat.utils&quot; &quot;spData&quot; ## [259] &quot;spdep&quot; &quot;SQUAREM&quot; ## [261] &quot;stabledist&quot; &quot;stars&quot; ## [263] &quot;stringi&quot; &quot;stringr&quot; ## [265] &quot;styler&quot; &quot;svglite&quot; ## [267] &quot;synoptReg&quot; &quot;sys&quot; ## [269] &quot;systemfonts&quot; &quot;tensor&quot; ## [271] &quot;terra&quot; &quot;terrainmeshr&quot; ## [273] &quot;testthat&quot; &quot;tgp&quot; ## [275] &quot;tibble&quot; &quot;tidyr&quot; ## [277] &quot;tidyselect&quot; &quot;tidyverse&quot; ## [279] &quot;timeDate&quot; &quot;timeSeries&quot; ## [281] &quot;tinytex&quot; &quot;tmap&quot; ## [283] &quot;tmaptools&quot; &quot;trend&quot; ## [285] &quot;triebeard&quot; &quot;unikn&quot; ## [287] &quot;units&quot; &quot;urltools&quot; ## [289] &quot;usethis&quot; &quot;utf8&quot; ## [291] &quot;uuid&quot; &quot;vctrs&quot; ## [293] &quot;vegan&quot; &quot;viridis&quot; ## [295] &quot;viridisLite&quot; &quot;waldo&quot; ## [297] &quot;webshot&quot; &quot;wesanderson&quot; ## [299] &quot;whisker&quot; &quot;widgetframe&quot; ## [301] &quot;withr&quot; &quot;xfun&quot; ## [303] &quot;xlsx&quot; &quot;xlsxjars&quot; ## [305] &quot;XML&quot; &quot;xml2&quot; ## [307] &quot;xopen&quot; &quot;xtable&quot; ## [309] &quot;yaml&quot; &quot;zip&quot; ## [311] &quot;zoo&quot; &quot;base&quot; ## [313] &quot;boot&quot; &quot;class&quot; ## [315] &quot;cluster&quot; &quot;codetools&quot; ## [317] &quot;compiler&quot; &quot;datasets&quot; ## [319] &quot;foreign&quot; &quot;graphics&quot; ## [321] &quot;grDevices&quot; &quot;grid&quot; ## [323] &quot;KernSmooth&quot; &quot;lattice&quot; ## [325] &quot;MASS&quot; &quot;Matrix&quot; ## [327] &quot;methods&quot; &quot;mgcv&quot; ## [329] &quot;nlme&quot; &quot;nnet&quot; ## [331] &quot;parallel&quot; &quot;rpart&quot; ## [333] &quot;spatial&quot; &quot;splines&quot; ## [335] &quot;stats&quot; &quot;stats4&quot; ## [337] &quot;survival&quot; &quot;tcltk&quot; ## [339] &quot;tools&quot; &quot;translations&quot; ## [341] &quot;utils&quot; Ou poderia simplesmente digitar library(). library() 4.3 Entrando com dados Assista este conteúdo em Cap 3 - Entrando com dados partes 1 e 2 no PVANet Agora que dominamos 100% as estruturas e tratamento de objetos podemos partir para importação de dados das mais variadas fontes. Até agora nós basicamente trabalhamos com dados café com leite. Criamos uma tabelinha aqui, uma matrizinha acolá um vetor e por aí vai. Sinto muito em informá-los, mas o mundo é bem mais complexo e cruel. O mundo não é um mar de rosas. É um lugar sujo, um lugar cruel, que não quer saber o quanto você é durão. Vai botar você de joelhos e você vai ficar de joelhos para sempre se você deixar. Você, eu, ninguém vai bater tão forte como a vida, mas não se trata de bater forte. Se trata de quanto você aguenta apanhar e seguir em frente, o quanto você é capaz de aguentar e continuar tentando. É assim que se consegue vencer.Agora se você sabe do teu valor, então vá atrás do que você merece, mas tem que estar preparado para apanhar. E nada de apontar dedos, dizer que você não consegue por causa dele ou dela, ou de quem quer que seja. Só covardes fazem isso e você não é covarde, você é melhor que isso. Balboa, Rocky | Os dados no R podem ser importados por diferentes meios (teclado, text file, outros softwares estatísticos, planilhas e etc). Fonte: Kabacoff (2015) 4.3.1 edit() A forma mais simples de inserção de dados é através do teclado. No caso a seguir, o comando Matrícula=numeric(0) cria uma variável de um mode()específico, mas sem dados. O comando edit(), por sua vez, e como nome sugere, permite editar um banco de dados. Um popup abrirá na sua tela que permitirá a sua edição. Após o uso basta fechar que as edições feitas serão salvas. comando edit() Alunos.Eng792 &lt;- data.frame(Nome=character(0),Matrícula=numeric(0), Curço=character(0),Nível.de.R=numeric(0),Nível.de.Pós=character(0)) Alunos.Eng792 ## [1] Nome Matrícula Curço Nível.de.R ## [5] Nível.de.Pós ## &lt;0 linhas&gt; (ou row.names de comprimento 0) Alunos.Eng792 &lt;- edit(Alunos.Eng792) Alunos.Eng792 ## [1] Nome Matrícula Curço Nível.de.R ## [5] Nível.de.Pós ## &lt;0 linhas&gt; (ou row.names de comprimento 0) 4.3.2 built-in No R também temos os dados buit-in que são dados que já vem dentro do R ou pacotes que permite a execução dos exemplos das funções naturais do R e aquelas instaladas por meio dos pacotes. Temos vários dados built-in no R como ìris, mtcars, anscombe, USArrests, USAccDeaths,AirPassengers e etc. Vamos dar uma olha no USArrests que contém estatísticas de presos por diferentes crimes em EUA em taxas de 100.000. Presidiarios.USA&lt;-(USArrests) Presidiarios.USA ## Murder Assault UrbanPop Rape ## Alabama 13.2 236 58 21.2 ## Alaska 10.0 263 48 44.5 ## Arizona 8.1 294 80 31.0 ## Arkansas 8.8 190 50 19.5 ## California 9.0 276 91 40.6 ## Colorado 7.9 204 78 38.7 ## Connecticut 3.3 110 77 11.1 ## Delaware 5.9 238 72 15.8 ## Florida 15.4 335 80 31.9 ## Georgia 17.4 211 60 25.8 ## Hawaii 5.3 46 83 20.2 ## Idaho 2.6 120 54 14.2 ## Illinois 10.4 249 83 24.0 ## Indiana 7.2 113 65 21.0 ## Iowa 2.2 56 57 11.3 ## Kansas 6.0 115 66 18.0 ## Kentucky 9.7 109 52 16.3 ## Louisiana 15.4 249 66 22.2 ## Maine 2.1 83 51 7.8 ## Maryland 11.3 300 67 27.8 ## Massachusetts 4.4 149 85 16.3 ## Michigan 12.1 255 74 35.1 ## Minnesota 2.7 72 66 14.9 ## Mississippi 16.1 259 44 17.1 ## Missouri 9.0 178 70 28.2 ## Montana 6.0 109 53 16.4 ## Nebraska 4.3 102 62 16.5 ## Nevada 12.2 252 81 46.0 ## New Hampshire 2.1 57 56 9.5 ## New Jersey 7.4 159 89 18.8 ## New Mexico 11.4 285 70 32.1 ## New York 11.1 254 86 26.1 ## North Carolina 13.0 337 45 16.1 ## North Dakota 0.8 45 44 7.3 ## Ohio 7.3 120 75 21.4 ## Oklahoma 6.6 151 68 20.0 ## Oregon 4.9 159 67 29.3 ## Pennsylvania 6.3 106 72 14.9 ## Rhode Island 3.4 174 87 8.3 ## South Carolina 14.4 279 48 22.5 ## South Dakota 3.8 86 45 12.8 ## Tennessee 13.2 188 59 26.9 ## Texas 12.7 201 80 25.5 ## Utah 3.2 120 80 22.9 ## Vermont 2.2 48 32 11.2 ## Virginia 8.5 156 63 20.7 ## Washington 4.0 145 73 26.2 ## West Virginia 5.7 81 39 9.3 ## Wisconsin 2.6 53 66 10.8 ## Wyoming 6.8 161 60 15.6 4.3.3 scan() Uma outra forma de entrada manual se dá através dom comando scan(). Neste formato de entrada de dados podemos digitar informação por informação ou copiar de uma fonte e colá-la. Tudo isso feito no console e em formato numérico. Exemplo com digitação. teste1 &lt;-scan() # Digite 1, 2, 4, 5, 6, 7, 8 teste1 Exemplo com copia e cola. seq(30,38) teste2 &lt;-scan() teste2 4.3.4 Lendo arquivos de texto (.txt) No dia a dia esbarramos em dados que estão disponíveis em formato de texto. Geralmente este dados estão organizados em linhas e colunas onde cada linha representa uma observação e cada coluna uma variável. Para fazer leitura de dados em formato de texto (.txt) podemos utilizar o comando read.table() que lê o arquivo em formato de tabela e armazena em formato de data.frame. A sintaxe do comando é: meu.df &lt;- read.table(file, options) Existem muitas opções ( options) disponíveis, mas podemos destacar algumas mais utilizadas header, sep, row.names, col.names, skip. Para saber quais são as options e o que cada uma delas faz você pode acessar através de ?data.datble. No caso abaixo estamos utilizando sep=\",\", header=T e skip=3. Baixe os dados aqui Cap_3_Notas_ENG792.txt no PVANet notas&lt;-read.table(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Notas_ENG792.txt&quot;, sep=&quot;,&quot;, header = T, skip=3) notas ## Nome Nota.1 Nota.2 Nota.3 Nota.4 ## 1 A 10.9 60.9 53.6 12.0 ## 2 B 71.3 9.9 13.9 47.0 ## 3 C 65.9 0.3 28.9 55.0 ## 4 D 3.6 70.0 37.9 75.3 ## 5 E 70.9 81.9 43.9 8.6 ## 6 F 76.9 53.0 29.9 38.6 ## 7 G 73.6 2.3 23.0 37.3 ## 8 H 2.0 88.0 10.3 28.3 ## 9 I 25.3 11.9 12.3 26.3 ## 10 J 7.0 19.3 82.9 46.3 ## 11 K 52.0 41.0 70.3 31.6 ## 12 L 27.3 74.0 47.6 18.9 ## 13 M 87.9 75.9 17.9 80.6 ## 14 N 76.0 47.9 2.0 19.6 ## 15 O 55.0 60.6 51.9 24.0 ## 16 P 76.6 47.9 90.3 55.6 ## 17 Q 10.3 55.9 18.0 86.3 ## 18 R 17.0 0.9 43.3 14.6 ## 19 S 38.6 22.6 23.6 6.6 ## 20 T 69.0 31.9 75.3 90.6 ## 21 U 26.9 3.6 65.3 48.6 ## 22 X 56.6 32.0 74.6 28.0 ## 23 Y 22.3 42.3 88.9 65.0 ## 24 Z 36.6 44.3 17.9 23.9 str(notas) ## &#39;data.frame&#39;: 24 obs. of 5 variables: ## $ Nome : chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ## $ Nota.1: num 10.9 71.3 65.9 3.6 70.9 76.9 73.6 2 25.3 7 ... ## $ Nota.2: num 60.9 9.9 0.3 70 81.9 53 2.3 88 11.9 19.3 ... ## $ Nota.3: num 53.6 13.9 28.9 37.9 43.9 29.9 23 10.3 12.3 82.9 ... ## $ Nota.4: num 12 47 55 75.3 8.6 38.6 37.3 28.3 26.3 46.3 ... Acima nós criamos o objeto notaspela importação do arquivo Notas_ENG792.txt referente às notas hipotéticas de vocês na disciplina Eng 792 ao término do semestre. Este arquivo está armazenado em meu computador na pasta J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/. Preste atenção na forma como ele foi importado o endereço veio antes do nome do arquivo e as separações entre os diretórios se pelo uso de /, mas também poderia ter utilizado \\\\. Após o endereço do arquivo vieram as options separadas por vírgulas (,). Se você tiver a curiosidade de abrir o arquivo .txt, você verá como os dados estão organizados e entenderá a utilização de cada argumento. No entanto, como eu sou gente boa, vou ajudar vocês embora vocês não mereçam. O argumento sep=\",\"foi utilizado pois os dados de cada célula está separado da outra por meio de uma vírgula ,. sep=\"\" indica espaço delimitando os dados sep=\"\\t\" indica tab delimitando os dados sep=\"\\n\" indica new line delimitaNdo os dados O argumento header=T\" indica que nossa tabela tem cabeçalho e é a primeira linha após o skip=3. O argumento skip=3\" indica que as 3 primeiras linhas de nosso arquivo devem ser ignoradas começando assim, nossa tabela a partir da 4ª linha. Note ainda que os nomes das colunas foram automaticamente alterados para atender as convenções de condificação do R. Onde originalmente estava Nota 1 agora temos Nota.1. Notas Eng792 Vejam que na tabela criada houve erros na na codificação dos caracteres especiais. RESOLVA ISSO! E digo mais determine que a primeira coluna (os nomes de vocês) sejam o nome das linhas 4.3.5 read.csv() Embora muito comuns arquivos em formato .txt, a maioria dos cientistas preferem armazenar dados em planilhas eletrônicas como do excel xlsx. ou .csv ( comma-separated values). Baixe o arquivo Cap_1_P2-Mispriced-Diamonds.csv PVANet diamantes&lt;-read.csv(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_1_P2-Mispriced-Diamonds.csv&quot;) str(diamantes) ## &#39;data.frame&#39;: 53940 obs. of 3 variables: ## $ carat : num 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ clarity: chr &quot;SI2&quot; &quot;SI1&quot; &quot;VS1&quot; &quot;VS2&quot; ... ## $ price : int 326 326 327 334 335 336 336 337 337 338 ... head(diamantes) # mostra as 6 primeiras linhas do objeto ## carat clarity price ## 1 0.23 SI2 326 ## 2 0.21 SI1 326 ## 3 0.23 VS1 327 ## 4 0.29 VS2 334 ## 5 0.31 SI2 335 ## 6 0.24 VVS2 336 tail(diamantes) # mostra as 6 últimas linhas do objeto ## carat clarity price ## 53935 0.72 SI1 2757 ## 53936 0.72 SI1 2757 ## 53937 0.72 SI1 2757 ## 53938 0.70 SI1 2757 ## 53939 0.86 SI2 2757 ## 53940 0.75 SI2 2757 Observem que no comando read.csv() nós não adicionamos o argumento header=T, issto por que por padrão headeré igual a TRUE (T), caso seus dados não tenham cabeçalhos você deve argumentar header=F Você já deve ter esbarrado com dados no brasileiros nos quais os separadores decimais não são pontos como no padrão internacional, mas vírgulas. Da mesma maneira, em Banânia, os separadores de de células são ponto e vírgula (semi-vírgula - ;). Para evitar problemas como esse na importação dos dados, (Perlin (2018)) sugere que sejam abertos em um editor de texto qualquer e substitua todos os valores de vírgula (,) por ponto (.). Isso deixa o arquivo em um formato internacional. No Windows, programas como o Notepad e o Notepad + + realizam essa tarefa facilmente, no linux o gedit e etc. Perlin (2018) suegre para evitar problemas, antes de prosseguir para a importação de dados em um arquivo .csv, deve-se abrir o arquivo em um editor de texto qualquer e verificar: A existência de texto antes dos dados e a necessidade de ignorar algumas linhas iniciais; A existência ou não dos nomes das colunas; O símbolo separador de colunas; O símbolo de decimal, o qual deve ser o ponto (.). Caso não seja possível converter os dados para o formato internacional, para esta jaboticaba você pode utilizar funções específicas como read.csv2() que assume que o indicador de decimal é a vírgula (,) e o separação de colunas é o ponto-e-vírgula (;). O read.csv()usa como default o padrão internacional sep=, e dec=. já o read.csv2() tem por default o padrão sep=\";\" e dec=\",\". dec=\"\" (separador de casas decimais) Experimente ambos comandos para abrir o Cap_3_Notas_ENG792.csv. Temos 1 arquivo Cap_3_Notas_ENG792.csv PVANet Notas.csv&lt;-read.csv2(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Notas_ENG792.csv&quot;, row.names = &quot;Nome&quot;) Notas.csv ## Nota.1 Nota.2 Nota.3 Nota.4 ## A 10.9 60.9 53.6 12.0 ## B 71.3 9.9 13.9 47.0 ## C 65.9 0.3 28.9 55.0 ## D 3.6 70.0 37.9 75.3 ## E 70.9 81.9 43.9 8.6 ## F 76.9 53.0 29.9 38.6 ## G 73.6 2.3 23.0 37.3 ## H 2.0 88.0 10.3 28.3 ## I 25.3 11.9 12.3 26.3 ## J 7.0 19.3 82.9 46.3 ## K 52.0 41.0 70.3 31.6 ## L 27.3 74.0 47.6 18.9 ## M 87.9 75.9 17.9 80.6 ## N 76.0 47.9 2.0 19.6 ## O 55.0 60.6 51.9 24.0 ## P 76.6 47.9 90.3 55.6 ## Q 10.3 55.9 18.0 86.3 ## R 17.0 0.9 43.3 14.6 ## S 38.6 22.6 23.6 6.6 ## T 69.0 31.9 75.3 90.6 ## U 26.9 3.6 65.3 48.6 ## V 56.6 32.0 74.6 28.0 ## X 22.3 42.3 88.9 65.0 ## Y 36.6 44.3 17.9 23.9 ## Z 40.0 65.0 77.9 59.0 Notas.csv&lt;-read.csv(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Notas_ENG792.csv&quot;, row.names = &quot;Nome&quot;) ## Error in read.table(file = file, header = header, sep = sep, quote = quote, : more columns than column names Note que o comando read.csv() não funcionou, faça os ajustes necessários para que ele funcine. Explore o comandos rowSums(), colSums(), rowMeans(), colMeans(). 4.3.6 Planilhas excel completas (.xls ou .xlsx) É muito comum encontrarmos dados organizados em diferentes planilhas dentro de um mesmo arquivo como no caso do excel ( .xls ou .xlsx) e semelehantes ( .odt). Estes arquivos e suas diferentes abas podem ser acessados pelo R também, no entanto não há funções nativas que executem esta ação. Precisamos nesse caso instalar pacotes de funções específicas para desempnhar esta operação. Temos algumas opções de pacotes para esta função como XLConnect (Mirai Solutions GmbH (2020)), xlsx (Dragulescu and Arendt (2020)) e readxl (Hadley Wickham and Bryan (2019)). Caso a instalação desses pacotes não funcione e, a mensagem de abaixo apareça. error: No CurrentVersion entry in Software/JavaSoft registry! Try re-installing Java and make sure R and Java have matching architectures. Experimente instalar ou atualizar antes o Java correspondente ao seu sistema operacional e bit. Vamos abrir o Definições iniciais - ENG 792.xlsx. Eu já tenho instalado no meu R, então instale no seu caso não o tenha. install.packages(\"xlsx\") Baixe os dados aqui Baixe o arquivo Cap_3_Informações - Alunos ENG 792.xlsx PVANet library(xlsx) Info.Alunos&lt;-read.xlsx(file=&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.xlsx&quot;, endRow=28,sheetIndex=4,startRow = 2, header = T,encoding=&quot;UTF-8&quot;) Info.Alunos 4.3.7 Exportar arquivos() Uma vez que somo capazes de importar arquivos de formatos específicos, somo também capazes de exportá-los. Podemos exportar data.frame, matrix ou vector para .csv (dos 2 tipos csv e csv2) e para .txt. A estrutura é semelhante para diferentes métodos (write.csv(), write.csv2() ou write.table()): write.csv(Objeto, file = objeto.csv\", append = FALSE, quote = TRUE, sep = \" \", eol = \"\\n\", na = \"NA\", dec = \".\", row.names = TRUE, col.names = TRUE, qmethod = c(\"escape\", \"double\"), fileEncoding = \"\") Vamos experimentar os diferentes comandos. Antes de prosseguir certifique-se que o endereço de saída está adequado. write.csv(Info.Alunos, file=&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.csv&quot;, sep=&quot;,&quot;,fileEncoding=&quot;UTF-8&quot;) ## Warning in write.csv(Info.Alunos, file = &quot;J:/ENG 792/ ## ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG ## 792.csv&quot;, : attempt to set &#39;sep&#39; ignored ## Error in is.data.frame(x): object &#39;Info.Alunos&#39; not found write.csv2(Info.Alunos, file=&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.2.csv&quot;,sep=&quot;,&quot;,fileEncoding=&quot;UTF-8&quot;) ## Warning in write.csv2(Info.Alunos, file = &quot;J:/ENG 792/ ## ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG ## 792.2.csv&quot;, : attempt to set &#39;sep&#39; ignored ## Error in is.data.frame(x): object &#39;Info.Alunos&#39; not found write.table(Info.Alunos, file=&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.txt&quot;, sep=&quot;,&quot;,fileEncoding=&quot;UTF-8&quot;) ## Error in is.data.frame(x): object &#39;Info.Alunos&#39; not found 4.3.8 Definir diretório de trabalho setwd() Durante a importação e exportação de dados nós forncemos dentro dos comandos os endereço no seu computador ou periférico de onde e para onde os dados deveriam ser importados e exportados, respectivamente. Esta tarefa pode ser simplificada pela determinação de um diretório de trabalho. Após esta definição o R vai comunicar diretamente com esta pasta de maneira que todos os arquivos importados e exportados de a para esta pasta. setwd(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/&quot;) Al.Eng792&lt;-read.xlsx(file=&quot;Cap_3_Informações - Alunos ENG 792.xlsx&quot;, endRow=28,sheetIndex=4,startRow = 2, header =T, encoding=&quot;UTF-8&quot;) write.table(Reposição.de.aula, file=&quot;Cap_3_Informações - Alunos ENG 792.txt&quot;,sep=&quot;,&quot;,fileEncoding=&quot;UTF-8&quot;) Explore o comandos rowSums(), colSums(), rowMeans(), colMeans() e acrescente no data.frame notas uma coluna com soma e média das notas dos alunos e linhas com no fim do arquivo soma e média das notas 1 a 4. Para terminar exporte os arquivos em formato .csv e .txt Para mais informações sobre importação e exportação de dados leia RCoreTeam (2020) . E digo mais, é só isso mesmo. 4.4 Exercícios Defina um objeto chamado a com valores de 60 a 85. Determine o elemento 12 de a. Determine elemento 20 de a. Mostre o 5° e 25° elementos de a. Mostre o 4°, 8°, 12°, 20° e 24° elementos de a. Mostre todos exceto 18°elemento de a. Mostre todos exceto o 2°, 15° e 17° elementos de a. Gere um data frame chamado new_frame com 3 colunas: A primeira com valores de 33 a 47; a segunda começando em 115 e terminando em 157, com incrementos de 3; e a terceira começando em 10, com 15 elementods, e cada elemento decrescendo 8.5. Cada coluna deve ser chamada de X, Y e Z respectivamente. Extraia todos os valores da coluna 1. Extraia das linhas 6 a 10 da coluna 2. Extraia os valores da linha 11 para todas as colunas. Extraia os valores das linhas 4 a 8 das colunas 1 e 3 em formato de data frame Demonstre o número de linhas do new_frame. Demonstre 4 diferentes métodos de extrair os valores de todas as linhas da coluna 1 de new_frame. Crie uma função que multiplique os valores de cada coluna por 2 ao cubo e em seguida aplique para a mesma seleção log10() criando new_frame2 alojando-o no global environment. Exporte seu new_frame2 para .csv e .txt. 4.5 Dica de leitura Introduction to the pacman Package in R (3 Examples) Quick list of useful R packages 36 Instalando e usando pacotes (packages) do R Installing and Using R Packages 15 Essential packages in R for Data Science A Tutorial on Using Functions in R! R - Functions Creating Functions R Functions Writing Functions in R: Example One How to write Functions in R This R Data Import Tutorial Is Everything You Need Importing Data Into R Importing Data R Data Import/Export Importing Data with the RStudio IDE References "],["produção-gráfica-e-comunicação-visual.html", "Capítulo 5 Produção gráfica e comunicação visual 5.1 Utilizando funções nativas 5.2 Cores no R 5.3 Para mais informações utilize o Google ou os documentos abaixo 5.4 ggplot2 5.5 Para mais informações utilize o Google ou os documentos abaixo", " Capítulo 5 Produção gráfica e comunicação visual Assista este conteúdo em Cap 4 - Produção gráfica e comunicação visual no PVANet R é capaz de produzir uma grande variedade de gráficos em alta qualidade para publicação e impressão. Tipos básicos de gráficos ( barplot, boxplot, scatterplot, maps e etc). É bastante simples produzir gráficos tradicionais no R, especialmente no nível mais básico e cada gráfico pode ser personalizado para atender as demandas do usuário. Gráficos R Fonte: Revolutions Os comando gráficos podem ser divididos em 3 categorias Mello and Peternelli (2013); 1. comando de alto nível  criam gráficos completos; 2. comando de baixo nível  adicionam informações a gráficos já existentes; 3. comando interativos  permitem ao usuário a interação com a janela gráfica. Os gráficos são plotados na aba Plots. Painel de plotagem O R possui algumas funções nativas para a criação de figuras, tal como plot e hist. De acordo com Perlin (2018) essas e outras funções nativas são restritivas e não recomendadas com customização pouco intuitivas com resultado final pouco atrativo. Eu pessoalmente nunca experimentei tal limitação e, arrisco a dizer respeitosamente que, tudo que você quer fazer com funções do ggplot2 pode ser feito com funções nativas, basta saber manipular corretamente os argumentos. Mas tenho que concordar que com ggplot2 as funções são mais simples e objetivas. De qualquer forma fica o alerta para possíveis limitações. 5.1 Utilizando funções nativas As funções nativas do R para prdoução de gráficos e plotagem são armazenadas pelos pacotes graphics e grDevices que carregam atutomaticamente sempre que o R é iniciado Peng (2020a). graphics: Contém as funções básicas do ambiente gráfico (plot, hist, boxplot e etc) grDevices: É responsável por permitir a comunição dos gráficos produzidos com outras linguagens de tratameneto de imagens ( X11, .pdf, PostScript, PNG e etc). Os gráficos básicos no R possuem uma grande variedade de parâmetros que nos auxiliam na produção e/ou melhoramento de um gráfico pré-concebido através da adição de novas informações. 5.1.1 boxplot - boxplot() São gráficos muito úteis que conseguem concatenar e mostrar uma série de informações de uma só vez. Muito úteis principalmente quando temos uma variável categórica associada. No R estes gráficos podem ser feitos utilizando o comando boxplot(). A fórmula tem a forma de eixo-y ~ eixo-x. Vamos utilizar o pacote datasets e os dados InsectSprays que mostra dados de um experimento de agricultura onde insetos foram tratados com diferentes inseticidas. A hipótese é que quanto mais eficiente o inseticida ( spray ) menos insetos ( count ) sobrevivem, ou seja, count é em função de spray. No boxplot cada caixa mostra os dados observados de cada tipos de spray (A até F) e vemos que os inseticidas C, D e E são os mais eficientes. Temos a mediana representada pela linha preta, os limites inferior e superior que representam o primeiro e o terceiro quartil (50% dos dados). As linhas superiores e inferiores correspondem a 2 desvios-padrão e os pontos fora das caixas são os outliers. Para mais detalhes sobre interpretação do boxplot procure um livro de estatística ou acesse a internet como em . data(InsectSprays) str(InsectSprays) ## &#39;data.frame&#39;: 72 obs. of 2 variables: ## $ count: num 10 7 20 14 14 12 10 23 17 20 ... ## $ spray: Factor w/ 6 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... head(InsectSprays) ## count spray ## 1 10 A ## 2 7 A ## 3 20 A ## 4 14 A ## 5 14 A ## 6 12 A tail(InsectSprays) ## count spray ## 67 13 F ## 68 10 F ## 69 26 F ## 70 26 F ## 71 24 F ## 72 13 F boxplot(count ~ spray,data = InsectSprays) Experimente adicionar o argumento notch=T. 5.1.2 histograma - hist() Histograma é um tipo de gráfico que combina várias barras verticais representando as frequências das variáveis. hist(InsectSprays$count,right=T, breaks=10, include.lowest=T, col= &quot;orange&quot;, border=&quot;red&quot;, adj=0, col.axis=&quot;blue&quot;) Veja que no histograma gerado nós adicionais alguns argumentos. Estes comandos introduzem variações no gráfico gerado que auxiliam na visualização das informações. right=T: Considera valores fechado à direita (já é o padrão). breaks=30: Define o intervalo das classes no eixo x (abscissas) controlando a espessura das barras. include.lowest=T: Inclui os valor extremos do vetor. col=\"orange: Define a cor do preenchimento da forma. border=red: Define a cor da borda. adj=0: Ajusta o alinhamento dos nomes dos eixos. col.axis=blue: Define a cor dos eixos. 5.1.3 Gráfico de barras - barplot() Linhas verticais descrevendo valores (barplot()). Exemplo abaixo veio do stackoverflow Texture in barplot for 7 bars in R?. Aqui temos gráficos de barras com texturas. # data generation --------------------------------------------------------- set.seed(1) mat &lt;- matrix(runif(4*7, min=0, max=10), 7, 4) rownames(mat) &lt;- 1:7 colnames(mat) &lt;- LETTERS[1:4] # plotting settings ------------------------------------------------------- ylim &lt;- range(mat)*c(1,1.5) angle1 &lt;- rep(c(45,45,135), length.out=7) angle2 &lt;- rep(c(45,135,135), length.out=7) density1 &lt;- seq(5,35,length.out=7) density2 &lt;- seq(5,35,length.out=7) col &lt;- 1 # rainbow(7) # plot -------------------------------------------------------------------- op &lt;- par(mar=c(3,3,1,1)) barplot(mat, beside=TRUE, ylim=ylim, col=col, angle=angle1, density=density1) barplot(mat, add=TRUE, beside=TRUE, ylim=ylim, col=col, angle=angle2, density=density2) legend(&quot;top&quot;, legend=1:7, ncol=7, fill=TRUE, col=col, angle=angle1, density=density1) par(bg=&quot;transparent&quot;) legend(&quot;top&quot;, legend=1:7, ncol=7, fill=TRUE, col=col, angle=angle2, density=density2) par(op) 5.1.4 Gráfico de setores (pizza) - pie() Divide um círculo em setores de acorco com os valores de cada categoria. pie(1:15, col = rainbow(15)) col=rainbow(15)= Preenche as áreas internas do gráfico com 15 cores utilizando a paleta de cores do arco-íris. 5.1.5 Função plot() A função plot() é uma função genérica amplamente utilizada para gerar gráficos. Nós vamos utilizá-la muito de agora em diante. plot()é provavelmente o comando de alto nível mais simples para criação de gráficos. Com ele podemos visualizar desde gráficos de dispersão até imagens de satélites. O tipo de plot a ser gerado depende da classe (class(x)) do primeiro argumento(x). Se x e y são vetores (plot(x, y)) produzirá um gráfico de dispersão ( scatter plot). Se x é um vetor numérico plot(x) produzirá um gráfico dos valores de X contra os valores dos índices. Se x é uma série temporal plot(x) produzirá um gráfico de uma série temporal. Se x é um factor, plot(x) produzirá um bar plot de x. Se x é um factor e y um vetor numérico plot(x,y) produzirá um bosplot de y para cada nível de x. Se x é um data.frame, y é qualquer objeto e expr é uma lista de nomes de objetos separados por + (por exemplo, a + b + c). plot(df) e plot(~ expr) produzirão gráficos de distribuição das variáveis em uma tabela quadro de dados (1º plot) ou de vários objetos nomeados (2° plot). plot(y ~ expr) produzirá um plot de y em relação a cada objeto nomeado em expr. v&lt;-1:20 m&lt;-v^2 plot(v,m) points(rev(v),m) # points () adiciona pontos a um gráfico já existente lines(v,400-m, col=&quot;red&quot;) #lines() adiciona linhas a um gráfico já existente text(10,200, &quot;Anuncie aqui&quot;) X&lt;-c(2, 3, 4, 5, 6, 7) #X maiúsculos mesmo Y&lt;-c(15, 46, 56, 15, 81, 11) #Y maiúsculo mesmo Nomes&lt;-LETTERS[1:6] Cidades&lt;-data.frame(X, Y, row.names=Nomes) Cidades ## X Y ## A 2 15 ## B 3 46 ## C 4 56 ## D 5 15 ## E 6 81 ## F 7 11 plot(Cidades) identify(Cidades) ## integer(0) 5.1.6 Formatando eixos Os exemplos anteriores serviram apenas para ilustração, mas se quisermos algo para publicação ou qualquer comunicação de melhor qualidade temos que trabalhar um pouco mais. Inicialmente podemos inserir os título e nomear os eixos. main=: Insere um título no gráfico; xlab=: Adiciona título ao eixo x do gráfico; ylab=: Adiciona título ao eixo y do gráfico. plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;) Nesse caso nós manipulamos os tamanhos dos eixos x e y concatenando vetores para xlim e ylim respectivamente. xlim=: Determina o intervalo do eixo x. ylim=: Determina o intervalo do eixo y. plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90)) Os rótulos dos eixos são geralmente posicionados na horizontal, no entanto os rótulos podem ser ajustados para o critério do usuário utilizando o argumento las=x (x=valor inteiro entre 0 e 3). * 1: sempre paralelo ao eixo (default) * 2: sempre horizontal * 3: sempre perpendicular ao eixo * 4: sempre vertical Podemos também plotar vários gráficos na mesma janela. Para isso precismamos controlar o painel com o comando par() combinado com mfrowou mfcol. mfrow=(x,y): Distribui os gráficos em linhas em que x é o número de linhas e y o número de colunas. mfcol=(x,y): Distribui os gráficos em colunas em que x é o número de linhas e y o número de colunas. par(mfrow=c(2,2)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3) par(mfcol=c(2,2)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3) Podemos alterar também os símbolos dos gráficos Por padrão o R usa círculos abertos nos gráficos. Isso pode ser alterado de acordo com preferência do usuário usando o argumento pch = x (x=valor inteiro entre 0 e 25) dentro do plot(). par(mfcol=c(2,2)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, pch=2) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1,pch=4) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2,pch=8) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,pch=16) O tamanho dos símbolos também pode ser ajustado utilizando o argumento cex=x. par(mfcol=c(2,2)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, pch=2, cex=0.3) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1,pch=4, cex=0.8) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2,pch=8, cex=1.3) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,pch=16, cex=1.8) O usuário não precisa unicamente utilizar os símbolos de pch para fazer seus gráficos, a conexão entres os pontos podem ser importante em alguns casos acrescentando o argumento type=\"x\" (x pode ser p, l, b, c, o, h, s, S, n). p para pontos; l para linhas; b para ambos; c apenas as linhas sem os pontos; o para ambos sobrepostos; h para tipo histograma (ou alta densidade) linhas verticais; s para degraus; S para outros tipos de degraus; n sem plot; par(mfcol=c(3,3)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, cex=1, type=&quot;p&quot;) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1,cex=1, type=&quot;l&quot;) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2, cex=1,type=&quot;b&quot;) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,cex=1,type=&quot;c&quot;) plot(trees$Girth, trees$Height,main=&quot;5° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, cex=1, type=&quot;o&quot;) plot(trees$Girth, trees$Height,main=&quot;6° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1,cex=1, type=&quot;h&quot;) plot(trees$Girth, trees$Height,main=&quot;7° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2, cex=1,type=&quot;s&quot;) plot(trees$Girth, trees$Height,main=&quot;8° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,cex=1,type=&quot;S&quot;) plot(trees$Girth, trees$Height,main=&quot;9° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,cex=1,type=&quot;n&quot;) Os gráficos podem também ser feitos por diferentes tipos de linhas. Uma vez defino que ele será do tipo l por xemplo (type=\"l\") podemos variar como a linha será apresentada com lty=x (x = número de 0 a 6). Experimente acrescentar o comando lwd=x (x é um número) para ir variando a espessura da linha. Fonte: sthda par(mfcol=c(3,2)) # Já que lty = 0 produz uma gráfico em branco não vamos mostrá-lo. for(i in 1:6){ plot(trees$Girth, trees$Height,main=paste(i,&quot;Relação Altura x Circunferência&quot;), xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, cex=1, type=&quot;l&quot;,lty=i) legend(&quot;bottomright&quot;,c(paste(&quot;lty=&quot;,i)),col=c(&quot;red&quot;)) } Podemos também fazer a sobreposição de gráficos ou adicionar elementos em um gráfico existente. par(new=T): habilita a sobreposição no mesmo painel de um outro gráfico. Lembre-se de desativar os outros parâmetros como eixos, labels, nomes e etc. Deixe apenas os pontos e informações do eixo necessário. axes=FALSE: Desativa a inclusão dos eixos xlab=\"\" e ylab=\"\": Deixa os labels dos eixos vazios. plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência x Volume&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;,ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) Veja no gráfico acima que o eixo secundário da informação voluma não foi incluído por isso precisamos adicioná-lo. Contudo antes de adicioná-lo, vamos ter que ajustar o painel, caso contrário ele será plotado, mas não aparecerá. Precisamos entender antes de tudo que a região de plotagem é possui 4 lados (4 margens) numeradas da seguinte forma. 1 - inferior 2 - esquerda 3 - superior 4 - direita Margens da figura O tamanho destas margens podem ser controladas utilizando o argumento mar=c(A,B,C,D) em que c(A, B, C e D) é um vetor numérico que determina o tamanho das margens referentes à 1ª, 2ª, 3ª e 4ª posição, respectivamente. Vamos liberar um espaço à direita para adicionar um eixo secundário no exemplo anterior. O eixo secundário é inserido ativando a margem 4 com comando axis(side=4, las=1) e em seguinda, acrescentando as informaçõpes necessárias com mtext(side=4, line=2.5, \"Volume da madeira (pés cúbicos)\"). side=4: Indica que as informações serão inseridas no lado 4. line=2.5: Indica a posição onde o texto será inserio no lado 4. par(mar=c(4, 4, 2, 4)) plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência x Volume&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) Podemos adicionar informações fora do gráfico (como título do eixo secundário) de uma outra forma. Para isto precisamos determinar xpd=T que viabiliza utilizar as margens externas do gráfico atual (padrão é xpd=F). Caso determine xpd=NA você pode utilizar qualquer região da área de plotagem. par(oma=c(0,0,4,3)): oma (Outer Margin Area) - especifica que as margens 3 e 4 terão 4 e 3 linhas, respectivamente. Investigue também os argumentos omi, mai, mgp, outer e omd. par(mar=c(4, 4, 2, 4),par(oma=c(0,0,4,3))) plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência x Volume&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(22.6, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) Pesquise por outer=T. A legenda pode ser adicionada com argumento legend(). bty=\"n\": não permite desenhar uma caixa em torno da legenda. \\n : Permite quebrar o texto como no título agora inserido com comando title(). cex.main=: Tamanho da fonte font.main= Tipo da fonte par(mfrow=c(1,2),mar=c(2, 2, 2, 2),par(oma=c(1,1,1,1))) plot(trees$Girth, trees$Height, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) title(&quot;Medidas de altura, diâmentro e\\n volume para 31 cerejeiras&quot;, cex.main=0.5,font.main=2) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(25, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) legend(&quot;topleft&quot;, c(&quot;Altura da árvore&quot;, &quot;Volume da madeira&quot;), pch=c(16, 4),col=c(&quot;springgreen&quot;, &quot;blue&quot;), bty=&quot;n&quot;) ##################### plot(trees$Girth, trees$Height,xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) title(&quot;Medidas de altura, diâmentro e\\n volume para 31 cerejeiras&quot;, cex.main=1,font.main=4) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(25, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) legend(12,20, c(&quot;Altura da árvore&quot;, &quot;Volume da madeira&quot;), pch=c(16, 4), col=c(&quot;springgreen&quot;, &quot;blue&quot;), bty=&quot;n&quot;) Outra maneira de plotar vários gráficos é manipulando os layouts. layout.matrix &lt;- matrix(c(2,1, 0, 3), nrow = 2, ncol = 2) layout(mat = layout.matrix, heights = c(1, 2), # Altura das duas linhas widths = c(2, 2)) # Largura das duas colunas layout.show(3) layout.matrix &lt;- matrix(c(2,1, 0, 3), nrow = 2, ncol = 2) layout(mat = layout.matrix, heights = c(1, 2), # Altura das duas linhas widths = c(2, 2)) # Largura das duas colunas plot(trees$Girth, trees$Height, xlab=&quot;Circunferência da árvore (polegadas)&quot;,ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) title(&quot;Medidas de altura, diâmentro e\\n volume para 31 cerejeiras&quot;, cex.main=1,font.main=2) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(25, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) legend(&quot;topleft&quot;, c(&quot;Altura da árvore&quot;, &quot;Volume da madeira&quot;), pch=c(16, 4),col=c(&quot;springgreen&quot;, &quot;blue&quot;), bty=&quot;n&quot;) par(mar = c(0, 4, 4, 0)) boxplot(trees$Girth, xaxt = &quot;n&quot;,yaxt = &quot;n&quot;, bty = &quot;n&quot;,col = &quot;white&quot;, frame = FALSE, horizontal = TRUE, main=&quot;Boxplot circunferência&quot;) par(mar = c(5, 0, 4, 0)) boxplot(trees$Height,xaxt = &quot;n&quot;,yaxt = &quot;n&quot;, bty = &quot;n&quot;,col = &quot;white&quot;, frame = F,main=&quot;Boxplot Altura&quot;) Para salvar os gráficos ou figuras podemos fazê-lo manualmente no painel Plots -&gt; export e escolher o formato de saída bem como as dimensões. Podemos também exportar as figuras por linhas de comando. png(filename = &quot;ENG792.Plot.png&quot;, width = 480, height = 480) layout.matrix &lt;- matrix(c(2,1, 0, 3), nrow = 2, ncol = 2) layout(mat = layout.matrix, heights = c(1, 2), # Altura das duas linhas widths = c(2, 2)) # Largura das duas colunas plot(trees$Girth, trees$Height, xlab=&quot;Circunferência da árvore (polegadas)&quot;,ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) title(&quot;Medidas de altura, diâmentro e\\n volume para 31 cerejeiras&quot;, cex.main=1,font.main=2) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(25, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) legend(&quot;topleft&quot;, c(&quot;Altura da árvore&quot;, &quot;Volume da madeira&quot;), pch=c(16,4),col=c(&quot;springgreen&quot;, &quot;blue&quot;), bty=&quot;n&quot;) par(mar = c(0, 4, 4, 0)) boxplot(trees$Girth, xaxt = &quot;n&quot;,yaxt = &quot;n&quot;, bty = &quot;n&quot;,col = &quot;white&quot;, frame = FALSE, horizontal = TRUE,main=&quot;Boxplot circunferência&quot;) par(mar = c(5, 0, 4, 0)) boxplot(trees$Height,xaxt = &quot;n&quot;,yaxt = &quot;n&quot;, bty = &quot;n&quot;,col = &quot;white&quot;, frame = F,main=&quot;Boxplot Altura&quot;) dev.off() ## png ## 2 Para mais exemplos sobre as fontes acesse. aqui Para saber mais dos parâmetros: names(par()) ## [1] &quot;xlog&quot; &quot;ylog&quot; &quot;adj&quot; &quot;ann&quot; ## [5] &quot;ask&quot; &quot;bg&quot; &quot;bty&quot; &quot;cex&quot; ## [9] &quot;cex.axis&quot; &quot;cex.lab&quot; &quot;cex.main&quot; &quot;cex.sub&quot; ## [13] &quot;cin&quot; &quot;col&quot; &quot;col.axis&quot; &quot;col.lab&quot; ## [17] &quot;col.main&quot; &quot;col.sub&quot; &quot;cra&quot; &quot;crt&quot; ## [21] &quot;csi&quot; &quot;cxy&quot; &quot;din&quot; &quot;err&quot; ## [25] &quot;family&quot; &quot;fg&quot; &quot;fig&quot; &quot;fin&quot; ## [29] &quot;font&quot; &quot;font.axis&quot; &quot;font.lab&quot; &quot;font.main&quot; ## [33] &quot;font.sub&quot; &quot;lab&quot; &quot;las&quot; &quot;lend&quot; ## [37] &quot;lheight&quot; &quot;ljoin&quot; &quot;lmitre&quot; &quot;lty&quot; ## [41] &quot;lwd&quot; &quot;mai&quot; &quot;mar&quot; &quot;mex&quot; ## [45] &quot;mfcol&quot; &quot;mfg&quot; &quot;mfrow&quot; &quot;mgp&quot; ## [49] &quot;mkh&quot; &quot;new&quot; &quot;oma&quot; &quot;omd&quot; ## [53] &quot;omi&quot; &quot;page&quot; &quot;pch&quot; &quot;pin&quot; ## [57] &quot;plt&quot; &quot;ps&quot; &quot;pty&quot; &quot;smo&quot; ## [61] &quot;srt&quot; &quot;tck&quot; &quot;tcl&quot; &quot;usr&quot; ## [65] &quot;xaxp&quot; &quot;xaxs&quot; &quot;xaxt&quot; &quot;xpd&quot; ## [69] &quot;yaxp&quot; &quot;yaxs&quot; &quot;yaxt&quot; &quot;ylbias&quot; 5.2 Cores no R O R nativo possui uma grande variedade de cores que podem ser utilizadas e combinadas. Podemos utilizar cores (cm.colors, rainbow, heat.colors, terrain.colors ou topo.colors) do grDevices. Podemos utilizar pacotes de cores também como RColorBrewer, unikn, viridis 5.2.1 RColorBrewer 5.2.2 unkin 5.2.3 viridis 5.3 Para mais informações utilize o Google ou os documentos abaixo Uma grande fonte de inspiração para produção de gráficos é o The R Graph Gallery Mastering r plot - part 1 Mastering r plot - part 2 Mastering r plot - part 3 An Introduction to R Graphics parameters list The R Graphics Package Graphical Parameters - cheat sheet R Graphics: Plot Parameters Graphical parameters - STHDA Styling Base R Graphics R Base Graphics: An Idiots Guide R Function of the Day - par(mar, mgp, las) Set or Query Graphical Parameters Graphical Layouts An xpd-tion into R plot margins Barplots with Pattern Fill AN INTRODUCTION TO PATTERNPLOT PACKAGE Colors in R Top R Color Palettes to Know for Great Data Visualization R color cheatsheet Creating a composite gif with multiple gganimate panels Leia também Murrel (2011), Venables and Smith (2020), Chang (2020) e Neth (2021) 5.4 ggplot2 Assista este conteúdo em Cap 4 - ggplot2 no PVANet O pacote ggplot2 é parte da coleção de pacotes chamado tidyverse que se destina à ciência de dados. Todos estes pacotes possuem a mesma espinha dorsal, ideia e/ou filosofia desde sua concepção até sua utilização. Caso queira se aventurar no universo tidy (altamente recomendado) instale todos os pacotes de uma só ves pelo comando: install.packages(\"tidyverse\") Vai demorar um pouco, pois são muitos arquivos enquanto isso você pode ir lendo o livro R for Data Science. Como nosso assunto hoje é apenas o ggplot2 podemos instalar apenas ele. Você pode instalá-lo diretamente do CRAN install.packages(\"ggplot2\") ou do github install.packages(\"devtools\") em seguida devtools::install_github(\"tidyverse/ggplot2\"). Para instalar do github você vai precisar de um pacote como devtools que permite, entre outras coisas, abrir conexão com github através da URL do pacote para instalá-lo. Uma vez instalado o pacote pode ser carregado por library(tidyverse)(carrega todos os pacotes da coleção) ou library(ggplot2) (carrega apenas o ggplot2) Veremos que, embora o potencial do comando nativo plot() seja enorme o comando ggplot() e seus argumentos deixam as coisas bem mais simples e objetivas. Seguirei aquilo que foi apresentado no livro R for Data Science por H. Wickham and Grolemund (2019). O ggplot2()possui uma estrutura lógica de construção de grágicos que nos permite entender melhor ou de maneira mais fácil como os dados podem ser visualizados. Estrutura do ggplot Atenção quando forem trabalhar os dados (quantitativos, qualitativos, cronológicos ou geográficos), cada tipo de dados possui características que são melhores exploradas/visualizadas por tipos específicos de gráficos. Vamos utilizar os dados mpg para iniciar nossas análises. Estes dados guardam informações coletadas pela Agência de Proteção Ambiental dos Estados Unidos sobre 38 modelos de carros. Carros com motores maiores consomem mais combustível? library(tidyverse) # ou library(ggplot2) str(mpg) ## tibble [234 x 11] (S3: tbl_df/tbl/data.frame) ## $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... ## $ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... ## $ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... ## $ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... ## $ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... ## $ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... ## $ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... ## $ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... ## $ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... ## $ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... ## $ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... ggplot(data=mpg)+ geom_point(mapping=aes(x=displ, y=hwy)) Veja que a estrutura do gráfico com ggplot() é a seguinte: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) ggplot() cria um sistema de coordenadas ao qual outras informações são adicionadas. O usuário diz a origem dos dados (data=), escolhe a função geom_ (geom_point nesse caso) para definir o tipo de gráfico que quer (ponto, linhas, barras e etc) seguido de parênteses com os argumentos da estética do (aes) que estabelece o que vai em cada eixo. No gráfico acima, observamos alguns pontos à direta que estão fora da tendência linear e gostaríamos de saber quais pontos são esses. Para isso podemos adicionar uma terceira informação ao nosso gráfico relacionado às cores (color ou colour funcionam da mesma maneira) para o atributo class. Não se esqueça que o sinal + deve ficar no final da linha a qual quer continuar abaixo. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class)) Desta forma, para associar uma variável ou atributo à um elemento gráfico adicione tudo dentro de aes() como no caso acima associamos classe às cores e um legenda foi automaticamente gerada. Percebemos que os pontos fora da tendência são pontos de carros de 2 lugares que não são necessariamente híbridos, mas esportivos. Da mesma maneira que associamos às cores podemos associar ao tamanho utilizando size=class. Mas observe que temos um aviso sobre o inconveniente que é associar variável discreta à tamanho. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = class)) ## Warning: Using size for a discrete variable is not advised. Poderíamos ainda associar class à transparência alpha, como já apresentado na Semana 1 - Aula 1, ou a formato. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, alpha = class)) ## Warning: Using alpha for a discrete variable is not ## advised. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = class)) ## Warning: The shape palette can deal with a maximum of 6 ## discrete values because more than 6 becomes ## difficult to discriminate; you have 7. Consider ## specifying shapes manually if you must have them. ## Warning: Removed 62 rows containing missing values ## (geom_point). Pela análise do gráfico acima ficamos pensando o que acontece com as SUVs, notamos assim que temos apenas 6 tipos de shapes para nossas variáveis e os demais grupos ficam de fora da classificação. Uma vez definido as características estéticas (aes) a seleção dos demais atributos como a paleta de cores será automaticamente definida pelo ggplot2. Se definirmos a cor como blue por exemplo, não temos ganho de informação no nosso gráfico uma vez que ficou tudo azul. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = &quot;blue&quot;) 5.4.1 Facetas (subgráficos) - facets Uma maneira de prozir múltiplos gráficos com ggplot2 é utilizar o comand facet Para gerar gráficos de facetas com uma única variável utilize facet_wrap() e adicione os argumento que achar necessários como número de linhas ncol=2. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2) Para combinar 2 variáveis utilize facet_grid(). Desta vez o argumento é uma fórmula drv ~ cyl ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ cyl) Se optar por gráficos não atrelados às dimensões de linhas ou colunas, use ponto (.) no lugar do nome de uma variável. # Orientação por linha ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ .) # Orientação por coluna ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(. ~ cyl) # Organizados em 2 linhas por class ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2) 5.4.2 Objetos geométricos Observe os gráficos abaixo e vejam em que eles diferem. Obviamente um mostra pontos e o outro uma linha suavizada. O comando comando responsável por esta diferença é o geom_COMPLEMENTO. #install.packages(&quot;ggpubr&quot;) library(ggpubr) ggarrange(ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)), ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy))) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Um geom é um objeto geométrico que um gráfico usa para representar dados. As pessoas descrevem o geom como o tipo de gráfico que ele usa. Por exemplo, gráfico de barras usam geoms de barras, gráficos de linha usam geoms de linha  . Gráficos de dispersão quebram a tendência, eles utilizam geom de ponto.  Cada função geom recebe um argumento mapping. Entretanto, nem toda estética funciona com todo geom. Você pode configurar a forma de um ponto, mas não pode configurar aforma\" de uma linha. Por outro lado, você pode configurar o tipo de linha. mpg$drv ## [1] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [14] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; ## [27] &quot;r&quot; &quot;r&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [40] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [53] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [66] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;4&quot; ## [79] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;r&quot; ## [92] &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [105] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [118] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [131] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; &quot;f&quot; ## [144] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; &quot;f&quot; ## [157] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [170] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [183] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [196] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; ## [209] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [222] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; # 4 = tração 4x4 # f = tração dianteira # r = tração traseira ggplot2 tem mais de 30 geoms clique aqui e confira. ggplot2 vai automaticamente agrupar os dados para esses geoms de qualquer mapeamento estético para variável discreta. Podemos utilizar o argumento group com uma variável para agrupar vários objetos. ggarrange(ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy)), ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, group = drv)), ggplot(data = mpg) + geom_smooth( mapping = aes(x = displ, y = hwy, color = drv), show.legend = FALSE), ncol=3) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Para exibir mais de um geom no mesmo gráfico você pode combiná-los. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_smooth(mapping = aes(x = displ, y = hwy)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Nesse caso há uma duplicação de informações e caso queira fazer alterações em uma variável e esquecesse a outra poderia ter problemas. Por isso podemos evitar repetições combinando os geoms. Veja que temos o mesmo gráfico sem tantos argumentos. ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; O ggplot2 tratará os mapeamentos locais para cada camada caso determine mapeamentos em função de geom possibilitando exibir estéticas diferentes. ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Podemos utilizar a mesma ideia para especificar um conjunto de dados diferentes para cada camada. No exemplo abaixo a linha exibe o comportamento de um outro banco de dados. ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth(data = filter(mpg, class == &quot;subcompact&quot;), se = FALSE) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 5.4.3 Transformações estatísticas 5.4.3.1 Gráfico de barras Número total de diamantes agrupados por cut. É aquele conjunto de dados de diamantes que trabalhamos nas aulas anteriores, mas agora com outras variáveis além de price, carat e clarity. Agora temos também color e cut. No eixo x temos cut e no y temos count mesmo não sendo uma variável de diamonds. Esta figura mostra como funciona a transformação para produção do gráfico de barras utilizando o algorítimo stat. str(diamonds) ## tibble [53,940 x 10] (S3: tbl_df/tbl/data.frame) ## $ carat : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... ## $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... ## $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... ## $ depth : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... ## $ table : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ... ## $ price : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ... ## $ x : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... ## $ y : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... ## $ z : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) Podemos analisar qual stat cada geom utiliza entrando com os comando adequados (geom_bar() usa stat_count()) geom_bar() ## geom_bar: width = NULL, na.rm = FALSE, orientation = NA ## stat_count: width = NULL, na.rm = FALSE, orientation = NA ## position_stack stat_count() ## geom_bar: na.rm = FALSE, orientation = NA, width = NULL ## stat_count: na.rm = FALSE, orientation = NA, width = NULL ## position_stack ggplot(data = diamonds) + stat_count(mapping = aes(x = cut)) Podemos alterar o mapeamento padrão de variáveis transformadas para estética. Exibir um gráfico de barras de proporção, em vez de count. ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = stat(prop), group = 1) ) Um pouco mais de detalhe. ggplot(data = diamonds) + stat_summary( mapping = aes(x = cut, y = depth), fun.min = min, fun.max = max, fun = median ) ?stat_bin para mais informações sobre os mais de 20 stats. 5.4.3.2 Ajustes de Posição Você também pode colorir as barras do gráficos utilizando o argumento estético color ou fill. ggarrange(ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, colour = cut)), ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut))) Se alternar e coloar fill=clarity as barras ficam empilhadas. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity)) O empilhamento acontece automaticamente pelo ajuste de posição. Se você não quiser o gráfico empilhado, pode usar ma outra opção como identity, dodge ou fill. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity), position = &quot;dodge&quot;) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity), position = &quot;identity&quot;) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity), position = &quot;fill&quot;) ggarrange(ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + geom_bar(alpha = 1/5, position = &quot;identity&quot;), ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + geom_bar(fill = NA, position = &quot;identity&quot;), ncol=2) Para gráficos de dispersão podemos utilizar position=jitter que adiciona um pouco de ruído no espalhamento dos pontos. ggarrange(ggplot(data=mpg)+ geom_point(mapping=aes(x=displ, y=hwy)), ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), position = &quot;jitter&quot;)) Para saber mais sobre ajuste de posição ?position_dodge,?position_fill,?position_identity,?position_jitter,?position_stack. 5.4.4 Sistema de coordenadas O sistema de coordenadas padrão do ggplot2 é cartesiano (x e y agem independentemente para encontrar a localização de cada ponto). cord_flip alterna os eixos x e y. ggarrange(ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot(), ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() + coord_flip()) coord_quickmap() ajusta a tela para mapas. nz &lt;- map_data(&quot;nz&quot;) ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, colour = &quot;black&quot;) ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, colour = &quot;black&quot;) + coord_quickmap() Experimente alternar os temas. gg&lt;-ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, colour = &quot;black&quot;)+ coord_quickmap() gg + theme_light() gg + theme_minimal() gg + theme_classic() coord_polar() usa coordendas polares. bar &lt;- ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL) ggarrange(bar + coord_flip(), bar + coord_polar()) 5.4.5 Rótulos 5.4.5.1 Título, subtítulo e caption (canto inferior direito). ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = FALSE) + labs(title = &quot;Fuel efficiency generally decreases with engine size&quot;) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = FALSE) + labs( title = &quot;Fuel efficiency generally decreases with engine size&quot;, subtitle = &quot;Two seaters (sports cars) are an exception because of their light weight&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Podemos tambpem usar labs() para renomear os eixos. ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_smooth(se = FALSE) + labs( x = &quot;Engine displacement (L)&quot;, y = &quot;Highway fuel economy (mpg)&quot;, colour = &quot;Car type&quot; ) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 5.4.5.2 Anotações Podemos rotular as observações do gráfico com geom_text(). best_in_class &lt;- mpg %&gt;% group_by(class) %&gt;% filter(row_number(desc(hwy)) == 1) ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_text(aes(label = model), data = best_in_class) Melhorando a visualização 1. ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_label(aes(label = model), data = best_in_class, nudge_y = 2, alpha = 0.5) Melhorando a visualização 2. ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_point(size = 3, shape = 1, data = best_in_class) + ggrepel::geom_label_repel(aes(label = model), data = best_in_class) Alterando os rótulos das legendas (legend.position=none). Rótulos diretamente no gráfico. class_avg &lt;- mpg %&gt;% group_by(class) %&gt;% summarise( displ = median(displ), hwy = median(hwy) ) ggplot(mpg, aes(displ, hwy, colour = class)) + ggrepel::geom_label_repel(aes(label = class), data = class_avg, size = 6, label.size = 0, segment.color = NA ) + geom_point() + theme(legend.position = &quot;none&quot;) Adicionando um único rótulos aos gráficos (geom_text()). Note o ajuste de hjust e vjust. label &lt;- mpg %&gt;% summarise( displ = max(displ), hwy = max(hwy), label = &quot;Increasing engine size is \\nrelated to decreasing fuel economy.&quot; ) ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_text(aes(label = label), data = label, vjust = &quot;top&quot;, hjust = &quot;right&quot;) # Texto exatamente nas bordas use -inf e +Inf label &lt;- tibble( displ = Inf, hwy = Inf, label = &quot;Increasing engine size is \\nrelated to decreasing fuel economy.&quot; ) ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_text(aes(label = label), data = label, vjust = &quot;top&quot;, hjust = &quot;right&quot;) 5.4.6 Eixos Podemos alterar os eixos e os intervalos dos eixos (x e y). No exemplo abaixo vamos utilizar scale_y_continuous para habilitar a edição do eixo y e determinar seus limites (limits=) e intervalos (breaks). p&lt;-ggplot(mpg, aes(displ, hwy)) + geom_point() + scale_y_continuous(breaks = seq(5,45,5), limits = c(5,45)) p Para adicionar um eixo y secundário precisamos utilizar o argumento sec.axis dentro de scale_y_continuous. p &lt;- ggplot(mpg, aes(x = displ))+ geom_point(aes(y = hwy, colour = &quot;hwy&quot;))+ geom_line(aes(y = cty, colour = &quot;cty&quot;))+ scale_y_continuous(sec.axis = sec_axis(~ . , name = &quot;cty&quot;, seq(1,1000,10)))+ scale_colour_manual(values = c(&quot;green&quot;, &quot;red&quot;))+ labs(y = &quot;hwy&quot;,x = &quot;displ&quot;,colour = &quot;Legenda&quot;)+ theme(legend.position = c(0.8, 0.9)) p 5.4.7 Escalas Uma outra forma de melhorar o aspecto de nosso gráfico é alterando as escalas que são automaticamente geradas. breaks() e label.breaks() controlam a posição das marcas ou os valores associados. ggarrange(ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)), ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + scale_x_continuous() + scale_y_continuous() + scale_colour_discrete(), ggplot(mpg, aes(displ, hwy)) + geom_point() + scale_y_continuous(breaks = seq(15, 40, by = 5)), ncol=2) ## $`1` ## ## $`2` ## ## attr(,&quot;class&quot;) ## [1] &quot;list&quot; &quot;ggarrange&quot; Pode determinar labels=NULL para omitir os rótulos. ggplot(mpg, aes(displ, hwy)) + geom_point() + scale_x_continuous(labels = NULL) + scale_y_continuous(labels = NULL) breaks() também pode destacar exatamente onde as observações ocorreram. # Quando cada presidente americano começou e terminou seu mandato presidential %&gt;% mutate(id = 33 + row_number()) %&gt;% ggplot(aes(start, id)) + geom_point() + geom_segment(aes(xend = end, yend = id)) + scale_x_date(NULL, breaks = presidential$start, date_labels = &quot;&#39;%y&quot;) 5.4.8 layout da legenda Para controlar a posição da legenda precismos da função theme() que controla as partes sem dados do gráfico. legend.position()controla onde a legenda será desenhada. base &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) ggarrange(base + theme(legend.position = &quot;left&quot;), base + theme(legend.position = &quot;top&quot;), base + theme(legend.position = &quot;bottom&quot;), base + theme(legend.position = &quot;right&quot;),ncol=2, nrow=2) # the default Para controlar a exibição das legendas use guides() junto de gui_legend() ou guide_colorbar(). O exemplo abaixo temos nrow=1 controla número de linhas da legenda. ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_smooth(se = FALSE) + theme(legend.position = &quot;bottom&quot;) + guides(colour = guide_legend(nrow = 1, override.aes = list(size = 4))) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 5.4.8.1 Substituindo uma escala. Se vezes não queremos ajustar uma escala, mas queremos substituí-la. Temos abaixo a relação de carat e price em escala logarítimica facilitando a visualização. ggarrange(ggplot(diamonds, aes(carat, price)) + geom_bin2d(), ggplot(diamonds, aes(log10(carat), log10(price))) + geom_bin2d(),ncol=2) A desvantagem é que os eixos estão rotulados com os valores transformados. Assim, em vez de fazer trasnformação no mapeamentos podemos fazê-la na escala. ggplot(diamonds, aes(carat, price)) + geom_bin2d() + scale_x_log10() + scale_y_log10() Outra escala frequentemente customizada é a cor. ggarrange(ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = drv)), ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = drv)) + scale_colour_brewer(palette = &quot;Set1&quot;), ncol=2) ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = drv, shape = drv)) + scale_colour_brewer(palette = &quot;Set1&quot;) presidential %&gt;% mutate(id = 33 + row_number()) %&gt;% ggplot(aes(start, id, colour = party)) + geom_point() + geom_segment(aes(xend = end, yend = id)) + scale_colour_manual(values = c(Republican = &quot;red&quot;, Democratic = &quot;blue&quot;)) 5.4.9 Dando zoom Há 3 formas de controlar os limites do gráfico. 1 - ajustando os dados do gráfico. 2 - Configurando limites em cada escala. 3 - Configurando xlim e ylimem coord_cartesian()). ggplot(mpg, mapping = aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth() + coord_cartesian(xlim = c(5, 7), ylim = c(10, 30)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; mpg %&gt;% filter(displ &gt;= 5, displ &lt;= 7, hwy &gt;= 10, hwy &lt;= 30) %&gt;% ggplot(aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Extraindo classes de carro e fazendo gráficos delas separadamente deixa difícil a comparação uma vez que cada um tem sua escala. suv &lt;- mpg %&gt;% filter(class == &quot;suv&quot;) compact &lt;- mpg %&gt;% filter(class == &quot;compact&quot;) ggarrange(ggplot(suv, aes(displ, hwy, colour = drv)) + geom_point(), ggplot(compact, aes(displ, hwy, colour = drv)) + geom_point(), ncol=2) Podemos superar isso formatando as escalas com os limites de todos os gráficos. x_scale &lt;- scale_x_continuous(limits = range(mpg$displ)) y_scale &lt;- scale_y_continuous(limits = range(mpg$hwy)) col_scale &lt;- scale_colour_discrete(limits = unique(mpg$drv)) ggplot(suv, aes(displ, hwy, colour = drv)) + geom_point() + x_scale + y_scale + col_scale ggplot(compact, aes(displ, hwy, colour = drv)) + geom_point() + x_scale + y_scale + col_scale 5.5 Para mais informações utilize o Google ou os documentos abaixo Articles - ggpubr: Publication Ready Plots ggplot2 Quick Reference: geom gganimate r-grph-gallery-ggplot2 GRÁFICOS COM GGPLOT2 O Que é ggplot2? ggplot2 esquisse R is Getting an Official Pipe Operator My aversion to pipes Draw Composition of Plots Using the patchwork Package in R (3 Examples) Kassambara (2019) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

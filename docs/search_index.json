[["index.html", "ENG 792 - Análise e visualização de dados com R (RStudio) Capítulo 1 Apresentação 1.1 Hello World! - Sejam Bem Vindos!", " ENG 792 - Análise e visualização de dados com R (RStudio) Jackson Rodrigues 2023-03-30 Capítulo 1 Apresentação 1.1 Hello World! - Sejam Bem Vindos! Assista este conteúdo em Cap 1 - Hello World! - Sejam Bem Vindos! no PVANet. Este é o material para os alunos matriculados na disciplina ENG 792 - Análise e Visualização de dados com R (RStudio) ofertada pelo programa de pós-graduação em Meteorologia Aplicada da Universidade Federal de Viçosa (UFV). Este curso foi criado e é ministrado por Jackson Rodrigues, professor da Universidade Federal Fluminense (UFF), mas também professor no programa de pós-graduação em Meteorologia Aplicada do Departamento de Engenharia Agrícola (DEA) da Universidade Federal de Viçosa (UFV). Este curso foi construído pensando em minha saga para aprender algo utilizando o R em meu doutorado. Foi bastante dolorido, principalmente no começo quando eu nunca havia tido contato com a liguagem, na verdade, sabia quase nada em programação. Desta forma, o público alvo é aquele que tem conhecimento zero sobre o assunto. Mas se você já sabe algo em qualquer nível, seja bem vindo também! Podemos aprender juntos, você ensina o que você sabe e eu ensino o que eu sei. A ideia principal deste curso é que o(a) aluno(a) que nada sabe de R seja exposto(a) a grande quantidade de conceitos e métodos para que o “gelo” seja quebrado e possa se virar sozinho ao término do curso. Desta forma, não é um curso de estatística, não é um curso de produção gráfica nem um curso produção de conteúdo (eg. modelagem), mas um curso de exposição, quase um “how to”. Vamos levantar demandas do dia a dia e tentar resolver os problemas comuns enfrentados pelo estudante na condução de suas análises. Eventualmente algum especialista será convidado para dar uma aula, bater um papo, fazer uma apresentação e etc sobre um assunto específico. O R é uma ferramenta espetacular para análise e produção de dados, bem como produção gráfica! Vamos começar devagar e ao poucos vocês vão se tornando autossuficientes. Muitas dúvidas surgem em fóruns, grupos e tanto outros canais de comunicação da comunidade de usuários de R. Muitas vezes surgem perguntas como:“Tem como fazer isso no R? A resposta imediada, devido à sua versatilidade, é: A pergunta não é “se tem jeito”, mas “como fazer”. Vamos dar uma passeio por muitas coisas legais que o R pode fazer e que vão ajudar a tornar sua vida bem melhor. Com tempo ganho na otimização das suas tarefas por utilização do R sobrará tempo para você escrever um paper a mais na pós-graduação, dormir no final de semana sem culpa, tomar uma cerveja na sexta com a turma e ir ao culto domingo sem pedidos. Vamos fazer tudo isso nos divertindo. É legal! Vocês verão. Por isso não se procupem comigo (professor), será muito pior para mim por ter que corrigir trabalhos enquanto vocês produzem mais um paper, dormem, tomam um cerveja com a turma e/ou rezam como foi na véspera de natal de 2020 quando estava corrigindo trabalhos. Véspera de Natal 2020 Let’s ride to Metal Land! Não se sintam pressionados ou intimidados, façam as perguntas que quiserem. Eu também não sei tudo, o R é uma ferramenta que está em constante desenvolvimento tornando impossível acompanhar cada novidade. Caso eu não saiba uma resposta não tenho problemas em dizer que não sei, mas vou me esforçar para buscar a resposta. Por isso: Vamos aprender e tentar nos divertir; Pensei nesse curso como uma forma de lutar contra a “dor” que senti quando comecei a trabalhar no R sozinho; Então sou um usuário e não um programador; A verdade é que o R tem uma curva de aprendizado muito íngreme que uma vez vencido o primeiro obstáculo as coisas deslancham; Vamos trabalhar de maneira que esse curso atenda superficialmente suas demandas e que te habilitem a se virarem sozinhos; Então vamos seguir passo-a-passo para um aprendizado gradual com vários exemplos; Tudo que você aprender em determinando momento não será descartado, você deverá guardar aquele conhecimento para utilização em próximo trabalho ou tarefa; Ou ainda, este conhecimento inicial será utilizado para sedimentar o caminho para um próximo passo; Aplicar o máximo possível nosso conhecimento a problemas reais, do mundo real. Para finalizar gostaria de deixar algumas coisas claras. Este curso conta com vasto material encontrado em artigos, livros, blogs especializados, grupos de discussões e etc. Desta forma, caso encontre por aí algo que ofertei em aula não precisa me chamar de picareta. Provavelmente foi tirado de lá mesmo. O curso funciona como um How to. Não teremos tempo de nos aprofundar nas teorias dos assuntos aqui apresentados (nem é a intenção), por isso, vou mostrar o “que é”, “como usar” e “como fazer”. Ao término de cada aula será mostrada uma bibliografia básica sobre o conteúdo. Como são conteúdos diversificados, acho melhor separar as bibliografias por aula. 1.1.1 Sobre Este é um material de apoio compilado e criado para os alunos da disciplina ENG 792 - Análise e visualização de dados com R (RStudio). Importante mencionar que o conteúdo aqui apresentado é um compilado de vários anos de materiais estudados disponíveis online ou em livros e artigos especialzados. Desta forma, caso identifique algum conteúdo apresentado aqui que não esteja devidamente referenciado fique à vontade para solicitar os devidos créditos aos autores originais. Não tenho a intenção de ter crédito que não é meu. 1.1.2 Utilização Cada capítulo é referente ao conteúdo de mais ou menos uma semana de curso. Cada semama trata de um assunto diferente e complementar ao conteúdo da semana anterior. Desta forma, fique livre para ir e vir no conteúdo caso algo não esteja claro o suficiente. Teremos aulas gravadas e aulas síncronas através de alguma plataforma. Apenas os alunos matriculados na disciplina terão acesso ao conteúdo gravado. A distribuição e/ou compartilhamento do conteúdo gravado por qualquer meio é proibido. 1.1.3 Códigos e Dados Todo o material necessário para acompanhar a disciplina será oferecido via github. Os códigos com alguma explicação neste material online (explicação completa nas aulas) e os dados onde forem possíveis de serem armazenados. 1.1.4 Cronograma de aulas As aulas serão ofertadas por material gravado e presencial às terças-feiras entre 13:30 e 16:00. 1.1.5 Métodos de avaliação Faremos pelo menos 3 listas de exercícios distribuídas pelo semestre. O trabalho final será a confecção de um atrabalho autoral com o conteúdo do curso que poderá ser feito em grupo (isso será definido ainda em conversa com vocês). Este trabalho será apresentado na forma de seminário ao término do curso. Bom curso! "],["vamos-ao-que-interesa.html", "Capítulo 2 Vamos ao que interesa 2.1 Conhecendo o R 2.2 Como R funciona", " Capítulo 2 Vamos ao que interesa 2.1 Conhecendo o R 2.1.1 O que é o R? É uma linguagem de programação voltada para resolução de problemas estatísticos, tratamento e visualização de dados. Para Peng (2020b) essa resposta é simples, “R é um dialeto do S”. De acordo com Perlin (2018) O código base do R foi inicialmente criado no laboratório da Bell/ AT&amp; T por John Chambers e seus colegas, com base na linguagem S. Esse código foi reaproveitado por dois acadêmicos, Ross Ihaka e Robert Gentleman, resultando na plataforma de programação que temos hoje. Para os curiosos, o nome R foi escolhido devido ao compartilhamento da primeira letra do nome de seus criadores. O R está em constante desenvolvimento por um grupo chamado R Team Core e conta com colaboração gratuita de centenas de milhares de usuários e desenvolvedores ao redor do mundo. Por isso, atualmente o R é utilizado por diversas áreas do conhecimento variando das ciências humanas até exatas, naquelas ciências que poderíamos imaginar pouco ou nada relacionadas. Por isso não se limite a procurar informações apenas no seu nicho, abra sua mente e busque aprender de outras ciências também. Eu, particularmente, busco muita coisa na econometria. Embora presente em todo tipo de livro sobre R, esta citação acima (Perlin (2018)) é de um livro de econometria. Veremos mais conteúdos desse material em breve. R é um software livre de análise de dados (não só estatística) que funciona em diversos sistemas operacionais: GNU Linux, MicrosoftWindows, Mac OS X e outros. O aprendizado do R é difícil no início devido à necessidade de se adaptar à sua lógica de funcionamento, se acostumar com a estrutura dos seus documentos de ajuda e memorizar alguns comandos básicos. eq = function(x){x*x} plot(eq(1:1000), type=&quot;l&quot;,lwd=3,col=&quot;red&quot;, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, xlab=&quot;Tempo&quot;, ylab=&quot;Aprendizado&quot;, main=&quot;Curva de Aprendizado&quot;) É preciso bastante perseverança e motivação para aprender os comandos básicos, e disposição para ler as páginas de ajuda e os manuais. Entretanto, depois de um certo tempo, ele possibilita que se trabalhe com grande produtividade e, o que é mais importante, eficácia e independência. Leia também sobre o mito da curva de aprendizado do R. 2.1.2 Instalação do R O R é um software gratuito para análises estatísticas e além. Pode ser baixado de The R Project for Statistical Computing. Clique em download R. Escolha o “espelho”.Escolha o mais próximo de você. Escolha o seu sistema operacional. Caso você seja usuário de windows clique em Download R for Windows em seguinda em install R for the first time e finalmente em Download R 4.1.0 for Windows. Veja que no momento que este tutorial foi feito a versão mais recente é a 4.1.0. No vídeo abaixo a versão é uma anterior, mas a lógica é a mesma. Assista este conteúdo em Cap 1 - Instalação do R no Windows no PVANet. Eu não tenho um sistema operacional de cada para mostrar a instalação, por isso deixo este vídeo para instalação no linux e este para instalação no mac. Caso você não consiga instalar me procure. 2.1.3 Primeiro contato Assista este conteúdo em Cap 1 - Primeiro contato no PVANet. Temos 1 arquivo Cap_1_P2-Mispriced-Diamonds.csv PVANet no PVANet com mais de 50.000 linhas referentes a transações de venda de diamantes dividida em 3 colunas clarity, carat e price. Quanto mais claro mais caro, certo? Ou há sub ou super valorização? Vamos investigar se essa relação é verdadeira como sugerido em ecapitaladvisors. Abaixo vamos apenas dar uma olhada no potencial de análise e produção gráfica do R. Não precisa se preocupar se não conseguir fazer tudo funcionar. Vamos aos poucos aprender cada comando apresentado. mydata&lt;-read.csv(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_1_P2-Mispriced-Diamonds.csv&quot;) library(&quot;ggplot2&quot;) ggplot(data=mydata, aes(x=carat, y=price))+ geom_point() Faz algum sentido. Mas está difícil de visualizar então vamos fazer um tratamento, vamos atribuir cores de acordo com a classificação do atributo clarity. ggplot(data=mydata, aes(x=carat, y=price, colour=clarity))+ geom_point() Os pontos estão sobrepostos impossibilitando a visualização. Vamos mexer na transparência. ggplot(data=mydata, aes(x=carat, y=price, colour=clarity))+ geom_point(alpha=0.1) Temos pontos que não são estatisticamente significantes à direita. Vamos nos livrar dos pontos não significativos, aqueles que são carat menores que 2.5. Vamos também adicionar algumas linhas através dos dados para avaliar o comportamento das variáveis em conjunto. brown é a melhor claridade, vejam que temos mispricing onde as linhas se cruzam. ggplot(data=mydata[mydata$carat&lt;2.5,], aes(x=carat, y=price, colour=clarity))+ geom_point(alpha=0.1) + geom_smooth() ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; Vamos agora reproduzir um ourto exemplo muito legal do pacote rayshader. Executando o código abaixo você produzirá uma Modelo Digital do Terreno em 3D em uma janela pop up. library(rayrender) library(rayshader) library(magick) #Vamos carregar o mapa com o pacote raster. loadzip = tempfile() download.file(&quot;https://tylermw.com/data/dem_01.tif.zip&quot;, loadzip) localtif = raster::raster(unzip(loadzip, &quot;dem_01.tif&quot;)) unlink(loadzip) # convertê-lo para matriz: elmat = raster_to_matrix(localtif) #Usar uma outra textura do rayshader elmat %&gt;% sphere_shade(texture = &quot;desert&quot;) %&gt;% add_water(detect_water(elmat), color = &quot;desert&quot;) %&gt;% plot_3d(elmat, zscale = 10, fov = 0, theta = 60, zoom = 0.75, phi = 45, windowsize = c(1000, 800)) Agora vamos adicionar mais algumas infromações como escala e indicador de norte. render_scalebar(limits=c(0, 5, 10),label_unit = &quot;km&quot;,position = &quot;W&quot;, y=50,scale_length = c(0.33,1)) render_compass(position = &quot;E&quot;) Sys.sleep(0.2) render_highquality(samples=200, scale_text_size = 24,clear=TRUE) 2.2 Como R funciona Assista este conteúdo em Cap 1 - Como R Funciona no PVANet. Diferentemente de outras linguagens, todos os comandos escritos são diretamente executados, desta forma o R não precisa de um compilador para executar os comandos como Fortran. Por isso, torna-se uma linguagem muito mais amigável e acessível para não programadores. A linguagem é muito intuitiva (quase uma sintaxe lógica). Por exemplo uma regressão linear pode ser executada como lm(x~y) ( lm vem de linear model). Como no exemplo do modelo linear acima, sempre que formos executar um comando temos que seguir da seguinte forma função(dados e demais ajustes ou parâmetros), ou seja chame a função e coloque o resto dentro de parênteses. Tudo que é executado pelo R fica armazenado na memória ativa (RAM) do computador na forma de objetos que possuem um nome. Os objetos, que variam em tipos e estruturas, podem ser funções criadas pelo próprio usuário, dados criados ou importados de uma memória, expressões e etc. Antes de entrarmos em detalhes sobre funções ou expressões, vamos nos ater aos objetos enquanto tipo e, na sequência, suas estruturas. Dica de livro de cabeceira sobre R Mello and Peternelli (2013). Antes de avançarmos para os objetos é necessário fazer algumas recomendações e ressalvas. Para criar um objeto qualquer podemos utilizar &lt;- ou =. As boas práticas recomendam o uso de &lt;- para evitar confusão já que o sinal = tem outras funções. Um objeto é criado da seguinte forma nome_do_objeto &lt;- atribuição. nome_do_objeto &lt;- &quot;atribuição&quot; nome_do_objeto ## [1] &quot;atribuição&quot; Contudo, evitem nomes longos, que comecem com numerais ou caracteres especiais ou letras maiúsculas (R é case-sensitive). Caso sua linha de comando esteja ficando longa demais opte por quebrar a linha veremos isso mais adiante). 2.2.1 Tipos de objetos (mode ou type) Os objetos no R podem ser do tipo lógico, inteiro, simples, dupla, complexo, função ou caractere. mode() Armazenamento Exemplo logical lógico TRUE or FALSE numeric inteiro, simples ou dupla Números 1, 3.14, 2e-308 etc complex complexo 3+2i function função Soma&lt;-function(…) name caractere média Tabela 1: Tipos de modos para objetos no R. #logical q1 &lt;-T mode(q1);typeof(q1) ## [1] &quot;logical&quot; ## [1] &quot;logical&quot; q2 &lt;- FALSE #pode ser a palavra toda mas em maiúsculas mode(q2);typeof(q2) ## [1] &quot;logical&quot; ## [1] &quot;logical&quot; #integer x&lt;-2L #L garante que 2 será integer mode(x);typeof(x) ## [1] &quot;numeric&quot; ## [1] &quot;integer&quot; #double y&lt;-2.5 mode(y);typeof(y) ## [1] &quot;numeric&quot; ## [1] &quot;double&quot; #Complex z&lt;-3+2i mode(z);typeof(z) ## [1] &quot;complex&quot; ## [1] &quot;complex&quot; #function Soma&lt;-function(x,y){ x+y } mode(Soma);typeof(Soma) ## [1] &quot;function&quot; ## [1] &quot;closure&quot; #Character a &lt;-&quot;h&quot; #Para colocar uma letra em uma variável é preciso colocar entre &quot;&quot;) mode(a);typeof(a) ## [1] &quot;character&quot; ## [1] &quot;character&quot; média&lt;-&quot;média&quot; mode(a);typeof(a) ## [1] &quot;character&quot; ## [1] &quot;character&quot; Saber as diferenças entre os diversos objetos é importante para uma exploração mais adequada dos dados, utilização eficiente de funções ou operações lógicas, artiméticas, estatísticas e etc. Veja que no caso acima em integer (x &lt;- 2L) optamos por adicionar “L” após o número 2, pois o R por padrão decide onde e como aloca/aloja/armazena um operador. A informação será preferencialmente salva como double e isso faz sentido caso você queira mais adiante realizar operações com números decimais ou realizar operações que resultem em números decimais. No entanto, caso queira saber que tipo de dado está manipulando você pode “perguntar” utilizando is. seguido da designação do tipo de dados quer testar ( integer, numeric, double e etc) e teremos uma resposta lógica. is.double(x) ## [1] FALSE Caso você deseje que sua variável seja de um tipo específico, você pode transformá-la utilizando as. seguido da designação desejada ( integer, numeric, double e etc). x&lt;-as.double(x) is.double(x) ## [1] TRUE Cada tipo de dado é associado com um teste e uma função de conversão conforme a tabela 2. Tipo Teste Função de conversão character is.character as.character complex is.complex as.complex double is.double as.double expression is.expression as.expression integer is.integer as.integer list is.list as.list logical is.logical as.logical numeric is.numeric as.numeric single is.single as.single raw is.raw as.raw Date is.Date as.Date Tabela 2: Tipos de dados, teste e modos de conversão. 2.2.2 Estrutura do objetos (class) As informações armazenadas em objetos no R podem ser organizadas em diferentes estruturas ou classes. No R existe uma grande variedade de classes de objetos, e sempre surgindo mais. No entanto, há classes de objetos que são mais comuns em situações em que estamos manipulando bases de dados, seja ela já existente, ou quando estamos criando com coleta usando técnicas de webscraping, por exemplo. São elas: interger, numeric, character, factor, matrix, data.frame e list. Uma coisa importante, no R não precisamos declarar qual classe vai ser o objeto unidimensional como em outras linguagem, embora possamos fazer isso, pois, o R aloca o objeto automaticamente em uma classe a partir do seu conteúdo. Meireles and Silva (2018) Figura 1: Estrutura de dados no R. Fonte: techvidvan Objeto modes descrição vector numeric, character, complex ou logical Com um ou mais elementos factor numeric ou character Vetor que representa dados categóricos matriz numeric, character, complex ou logical Um array de duas dimensões array numeric, character, complex ou logical Pode conter um, duas ou mais dimensões data frame numeric, character, complex ou logical Um array de duas dimenões que permite colunas de diferentes tipos dem mesmo objeto list numeric, character, complex, logical, function, expression, … Objeto que permite combinar diferentes estruturtas de dados num único objeto Tabela 3: Características dos tipos de objetos. 2.2.2.1 Vetores (Vectors) Vetores são os tipos de objetos mais comuns no R. Um vetor é composto de uma informação ou uma séries de informações ( arrays ) unidimensionais que podem conter informaçõs numéricas, caracteres ou dados lógicos. Mesmo quando digitamos apenas um único elemento ele se torna um vetor de comprimento um (1). Vetores com Apenas 1 elemento esquerdo&lt;-(&quot;direito&quot;) # O objeto &quot;esquerdo&quot; recebe a palavra &quot;direito&quot; esquerdo #execute o arquivo e veja seu conteúdo ## [1] &quot;direito&quot; direito=c(&quot;esquerdo&quot;) #Outra maneira de criar objeto print(direito) #Outra forma de executar o conteúdo ## [1] &quot;esquerdo&quot; b=(10) # O objeto &quot;b&quot; recebe o número 10 b ## [1] 10 (15.23)-&gt;c # O objeto &quot;c&quot; recebe o número 15.23 c ## [1] 15.23 Vetores com múltiplos elementos. d&lt;-(0:10) # Criando uma sequência de 0 até 10 d ## [1] 0 1 2 3 4 5 6 7 8 9 10 e&lt;-10.5:20.5 # criando uma sequência de 10.5 até 20.5 e ## [1] 10.5 11.5 12.5 13.5 14.5 15.5 16.5 17.5 18.5 19.5 20.5 f&lt;-(10.6:20.3) # O último elemento é descartado por nãos e encaixar na sequência f ## [1] 10.6 11.6 12.6 13.6 14.6 15.6 16.6 17.6 18.6 19.6 Podemos utilizar também a função seq para gerar uma sequêncaio de dados. seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),length.out = NULL, along.with = NULL, …) g&lt;-seq(0,10,0.5) # O objeto &quot;g&quot; recebe a sequência de 0 até 10 a cada 0.5 g ## [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 ## [16] 7.5 8.0 8.5 9.0 9.5 10.0 h&lt;-seq(from=10,to=20,length.out=50) # O objeto &quot;h&quot; recebe a sequência de 0 até 10 que é do compriumento 50, ou seja, há 50 número de 10 até 20 h ## [1] 10.00000 10.20408 10.40816 10.61224 10.81633 11.02041 11.22449 11.42857 ## [9] 11.63265 11.83673 12.04082 12.24490 12.44898 12.65306 12.85714 13.06122 ## [17] 13.26531 13.46939 13.67347 13.87755 14.08163 14.28571 14.48980 14.69388 ## [25] 14.89796 15.10204 15.30612 15.51020 15.71429 15.91837 16.12245 16.32653 ## [33] 16.53061 16.73469 16.93878 17.14286 17.34694 17.55102 17.75510 17.95918 ## [41] 18.16327 18.36735 18.57143 18.77551 18.97959 19.18367 19.38776 19.59184 ## [49] 19.79592 20.00000 Experimente também a função rep(). rep(x, times = 1, length.out = NA, each = 1) i&lt;-rep(0,10) # O objeto &quot;i&quot; recebe 10 números 1 i ## [1] 0 0 0 0 0 0 0 0 0 0 j&lt;-rep(c(1:3),10) # O objeto &quot;j&quot; recebe 10 vezes a sequência 1, 2 e 3 j ## [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 Um Vetor só pode conter informações de um único tipo! k&lt;-c(0,1,2,3,4, &quot;A&quot;) # O objeto &quot;k&quot; é do tipo character por causa de &quot;A&quot; typeof(k);mode(k) ## [1] &quot;character&quot; ## [1] &quot;character&quot; l&lt;-c(0,1,2,3,4) # O objeto &quot;l&quot; é do tipo numérico typeof(l);mode(l) ## [1] &quot;double&quot; ## [1] &quot;numeric&quot; 2.2.2.2 Fatores (Factors) Os fatores são vetores em que os elementos pertencem a uma ou mais categorias temáticas. As variáveis aleatórias podem ser divididas em contínuas e categóricas. As contínuas podem ser medidas nas escalas: relacional e intervalar. As categóricas nas escalas: nominal e ordinal. No R, as variáveis categóricas medidas nas escalas nominal e ordinal são chamados fatores. A função factor() armazena os valores categóricos como um vetor de inteiros [1..k] e um vetor interno de strings referentes ao nomes. Em outras palavras, um factor é um vetor objeto usado para especificar uma classsificação discreta (agrupamento) dos componentes de outros vetores de mesmo tamanho. factor(x = character(), levels, labels = levels,exclude = NA, ordered = is.ordered(x), nmax = NA) ou gl(n, k, length = n X k, labels = seq_len(n), ordered = FALSE) m&lt;-factor(c(&quot;H&quot;,&quot;H&quot;,&quot;H&quot;,&quot;M&quot;,&quot;M&quot;)) # O objeto &quot;k&quot; recebe 3 H&#39;s e 2 M&#39;s m ## [1] H H H M M ## Levels: H M as.integer(m) ## [1] 1 1 1 2 2 n&lt;-gl(n=2,k=3,labels=c(&quot;M&quot;,&quot;F&quot;)) n ## [1] M M M F F F ## Levels: M F Podemos verificar os níveis de um fator usando o comando levels(). levels(m) ## [1] &quot;H&quot; &quot;M&quot; levels(n) ## [1] &quot;M&quot; &quot;F&quot; 2.2.2.3 Matriz (Matrix) É o tipo de dado mais comum que encontramos do dia a dia. A maioria dos dados que analisamos estão organizados em matrizes que são dados combinados em 2 dimensões (linhas e colunas). Existem várias maneiras de criar uma matriz como utilizando o comando matrix(). matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,dimnames = NULL) Assim como os vetores, as matrizes só aceitam dados do mesmo tipo. o&lt;-1:10 # cria um vetor de 1 a 10 o_matriz1&lt;-matrix(o,ncol=5)# Organiza o vetor &quot;o&quot; e 5 colunas o_matriz1 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 o_matriz2&lt;-matrix(o,nrow=5)# Organiza o vetor &quot;o&quot; e 5 linhas o_matriz2 ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 Podemos utilizar também o argumento byrow=, que, diferente do exemplo acima, preenche a tabela por linha. p&lt;-1:10 # cria um vetor de 1 a 10 p_matriz1&lt;-matrix(o,nrow=5,byrow=T)# Organiza o vetor &quot;o&quot; e 5 colunas p_matriz1; o_matriz2 # compare os 2 modos ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 ## [4,] 7 8 ## [5,] 9 10 ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 As dimensões de uma matriz podem ser acessadas através do comando dim(): dim(o_matriz1);dim(o_matriz2) # Leia o o resultado como linha e coluna ## [1] 2 5 ## [1] 5 2 Também é interessante usar o comando summary(). summary(o_matriz1);summary(o_matriz2) # Mostra informações por coluna ## V1 V2 V3 V4 V5 ## Min. :1.00 Min. :3.00 Min. :5.00 Min. :7.00 Min. : 9.00 ## 1st Qu.:1.25 1st Qu.:3.25 1st Qu.:5.25 1st Qu.:7.25 1st Qu.: 9.25 ## Median :1.50 Median :3.50 Median :5.50 Median :7.50 Median : 9.50 ## Mean :1.50 Mean :3.50 Mean :5.50 Mean :7.50 Mean : 9.50 ## 3rd Qu.:1.75 3rd Qu.:3.75 3rd Qu.:5.75 3rd Qu.:7.75 3rd Qu.: 9.75 ## Max. :2.00 Max. :4.00 Max. :6.00 Max. :8.00 Max. :10.00 ## V1 V2 ## Min. :1 Min. : 6 ## 1st Qu.:2 1st Qu.: 7 ## Median :3 Median : 8 ## Mean :3 Mean : 8 ## 3rd Qu.:4 3rd Qu.: 9 ## Max. :5 Max. :10 Outras formas de construir matrizes é juntando objetos existentes através dos comandos cbind() e rbind() que concatenam objetos por colunas e linhas, respectivamente. Vamos juntar as matrizes já criadas. o_matriz3&lt;-rbind(o_matriz1,o_matriz1) # concatena por linhas (row) o_matriz3 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [3,] 1 3 5 7 9 ## [4,] 2 4 6 8 10 o_matriz4&lt;-cbind(o_matriz2,o_matriz2) # concatena por colunas (column) o_matriz4 ## [,1] [,2] [,3] [,4] ## [1,] 1 6 1 6 ## [2,] 2 7 2 7 ## [3,] 3 8 3 8 ## [4,] 4 9 4 9 ## [5,] 5 10 5 10 2.2.2.4 Array O array é um conjunto de matrizes ou vetores que podem ter qualquer número de dimensões. Estas dimensões podem receber nomes. Podemos criar arrays atribuindo dimensções a um vetor com o comando dim() ou usando array(). array(data = NA, dim = length(data), dimnames = NULL) q_array&lt;-1:12 # cria um vetor dim(q_array)&lt;-c(2,3,2) # atribuindo 3 dimensões a q_array q_array ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 r_array&lt;-array(1:12,c(2,3,2)) # cria um array de 3 dimensões r_array ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 2.2.2.5 Data Frame Tão comum quanto a matriz, o data frame também um modo bidimensional de organização dos dados (linhas e colunas) que, diferentemente da matriz, permite objetos de tipos diferentes (character, numeric, logical e etc) sejam armazenados. Normalmente, nos data frames temos nas linhas as observações e nas colunas temos as variáveis. No entanto, é importante que cada coluna tenha o mesmo tamanho. data.frame(…, row.names = NULL, check.rows = FALSE,check.names = TRUE, fix.empty.names = TRUE,stringsAsFactors = default.stringsAsFactors()) Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores Săo Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 10 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana Bahia 38 12 13 13 44 43 49 1 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 -6 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana Botafogo 38 13 4 21 31 45 43 -14 38 NA Ceará 38 10 9 19 36 41 39 -5 34 NA Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado CSA 38 8 8 22 24 58 32 -34 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado Tabela 3: Data frame do resultados final do Campeonato Brasileiro de 2019. Nome&lt;-c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) Idade&lt;-c(25, 32, 28) Sexo&lt;-c(&quot;M&quot;,&quot;M&quot;, &quot;F&quot;) Nome;Idade;Sexo ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## [1] 25 32 28 ## [1] &quot;M&quot; &quot;M&quot; &quot;F&quot; Ficha&lt;-data.frame(Nome,Idade,Sexo) attributes(Ficha) # exibe os atributos do data frame ## $names ## [1] &quot;Nome&quot; &quot;Idade&quot; &quot;Sexo&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] 1 2 3 Nome Idade Sexo A 25 M B 32 M C 28 F Tabela 4: Tabela com dados fictícios. 2.2.2.6 Lista (list) List permite combinar diferentes estruturas de dados em um mesmo objeto, ou seja, vetores, matrizes, arrays, data.frames e até outras listas. As listas são construídas utilizando o comando list(). Os componentes da lista são criados da mesma maneira como para data.frame. list(…) Nome&lt;-c(&quot;A&quot;) Idade&lt;-c(25) Sexo&lt;-c(&quot;M&quot;) Notas&lt;-c(55,42,50,35) Nome;Idade;Sexo;Notas ## [1] &quot;A&quot; ## [1] 25 ## [1] &quot;M&quot; ## [1] 55 42 50 35 Desempenho&lt;-list(nome=&quot;A&quot;, idade=25, Sexo=&quot;M&quot;,Notas=c(55,42,50,35)) Desempenho ## $nome ## [1] &quot;A&quot; ## ## $idade ## [1] 25 ## ## $Sexo ## [1] &quot;M&quot; ## ## $Notas ## [1] 55 42 50 35 is.list(Desempenho) ## [1] TRUE Existem também alguns comandos/funções que mostram resultados como listas. s&lt;-c(1:30) t&lt;-c(30:59) teste.t&lt;-t.test(s,t, var.equal = T) # calcula o test t para 2 amostras de variâncias iguais teste.t ## ## Two Sample t-test ## ## data: s and t ## t = -12.758, df = 58, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -33.54996 -24.45004 ## sample estimates: ## mean of x mean of y ## 15.5 44.5 is.list(teste.t);mode(teste.t) ## [1] TRUE ## [1] &quot;list&quot; Para finalizar por hoje preste atenção no seu Global Environment. Veja que há uma grande quantidade de objetos lá. Agora execute o comando abaixo: rm(Desempenho) rm(list=ls()) Voilà! Sumiu tudo. References "],["references.html", "References", " References "],["acessando-e-manipulação-de-dados.html", "Capítulo 3 Acessando e manipulação de dados 3.1 Organização 3.2 Operadores 3.3 Dica de leitura 3.4 Exercícios", " Capítulo 3 Acessando e manipulação de dados 3.1 Organização Assista este conteúdo em Cap 2 - Organização Partes 1 e 2 no PVANet Como mencionado anteriormente, vector é uma das principais estruturas do R. Um vetor é uma sequência de elementos (1…n) do mesmo tipo organizados tal qual livros em uma prateleira. No caso abaixo temos um vetor numérico que pode ser integer ou double. a&lt;-c(25,17,55,3,12,315,10,2,3,11) a ## [1] 25 17 55 3 12 315 10 2 3 11 Posição 1 2 3 4 5 6 7 8 9 10 Elementos 25 17 55 3 12 315 10 2 3 11 Um vetor também pode armazernar caracteres. Neste caso eles devem estar entre aspas duplas (\"\"). b&lt;-c(&quot;Z&quot;,&quot;f&quot;, &quot;7&quot;,&quot;2a&quot;,&quot;Yes&quot;,&quot;A&quot;,&quot;Ab&quot;) b;typeof(b) ## [1] &quot;Z&quot; &quot;f&quot; &quot;7&quot; &quot;2a&quot; &quot;Yes&quot; &quot;A&quot; &quot;Ab&quot; ## [1] &quot;character&quot; Embora tenhamos o número 7 entre os nossos elementos do vetor acima, por estar entre aspas o número 7 não é numéric, mas caractere. Lembrem-se que um vector é um banco de dados da mesmo tipo Logo, se você colocar um número 7 dentro dele, o R vai automaticamente convertê-lo em caractere independente de estar entre \"\" ou não. Posição 1 2 3 4 5 6 7 Elementos “Z” “f” “7” “2a” “Yes” “A” “Ab” Mesmo que você tenha apenas um único numeral ele será armazenado como vector, vector de comprimento = 1. Então um único número ou um único caractere será um vector. c&lt;-(1) c;typeof(c);is.vector(c) ## [1] 1 ## [1] &quot;double&quot; ## [1] TRUE Posição 1 Elemento “1” Entender a posição de cada elemento dentro de um vector é crucial! Saber a posição correta onde determinado(s) elemento(s) está(estão) facilita em muito nossa limpeza, nosso tratamento e demais passos para uma eficiente manipulação dos dados. seq(100,50,-1) ## [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 ## [20] 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 ## [39] 62 61 60 59 58 57 56 55 54 53 52 51 50 Atenção para os números dentro dos colchetes [1] [17] [33] [49]. Como mencionado em aulas passadas, eles, os colchetes, indicam a posição de determinados elementos dentro de um banco de dados. Especificamente o [1] informa que o número 100 é o primeiro elemento, [17] informa que o número 84 é o vigésimo elemento, [33] informa que o número 68 é o trigésimo nono elemento, [49] informa que o número 52 é o trigésimo nono elemento. 3.1.1 Usando [ ] - Subscribing ou indexing 3.1.1.1 Vetores Podemos extrapolar esta ideia de utilização de [] para acessar informações dentros dos objetos que criamos ou importamos. d&lt;-c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) d ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; Posição 1 2 3 4 5 Elementos “a” “b” “c” “d” “e” No vector d temos cada um dos elementos em sua respectiva posição. Para acessar um elemento específico podemos inserir o número refere à sua posição dentro de []. Por exemplo: d[1] ## [1] &quot;a&quot; d[2] ## [1] &quot;b&quot; d[3] ## [1] &quot;c&quot; d[4] ## [1] &quot;d&quot; d[5] ## [1] &quot;e&quot; Importante saber que [] é muito versátil. d[-1] # Acessa todos elementos exceto o primeiro ## [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; d1&lt;-d[3] # Atribuir o(s) elemento(s) de um vetor a outro vetor, ou criar um novo objeto de elementos já de objetos já existentes d1 ## [1] &quot;c&quot; d[1:3] # Acessar um intervalo de elementos ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; d[3:5] ## [1] &quot;c&quot; &quot;d&quot; &quot;e&quot; d[c(1,3:5)] # Acessar utilizando combinações ## [1] &quot;a&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; d[c(-2,-4)] # Exceto o segundo e quanto elementos ## [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; d[-3:-5] # Exceto o intervalo entre 3 e 5 ## [1] &quot;a&quot; &quot;b&quot; Vamos dar mais uma olhada na importância do []. Considere os seguintes vetores. Posição 1 2 3 4 5 6 7 8 9 10 Elemento 50 34 11 7 24 631 20 4 7 21 Posição 1 2 3 4 5 6 7 8 9 10 Elemento 100 2 56 12 0 65 93 10 244 1 Vamos somar os dois vetores e observe que são adicionados o primeiro elemento com primeiro elemento, segundo elemento com segundo elemento e assim por diante. Em algumas outras linguagens se você quiser fazer esse procedimento, você vai provavelmente usar um loop. Mas em R você pode simplesmente adicioná-los. Esse é o motivo do R ser linguagem vetorizada. Você pode testar qualquer método matemático (soma, divisão, booleana, lógica). e&lt;-c(50,34,11,7,24,631,20,4,7,21) f&lt;-c(100,2,56,12,0,65,93,10,244,1) e;f ## [1] 50 34 11 7 24 631 20 4 7 21 ## [1] 100 2 56 12 0 65 93 10 244 1 e+f ## [1] 150 36 67 19 24 696 113 14 251 22 Neste caso funcionou tudo perfeitamente, pois nossos vetores são do mesmo tamanho. No entanto, caso tenhamos vetores de tamanho diferentes o R vai fazer um procedimento chamado recycling of vector. O R vai fazer com que os dois vetores se encaixarem no mesmo tamanho caso sejam múltiplos. Basicamente, o R vai copiar os elementos do começo do vetor menor e adicionar ao seu fim até que fiqque do mesmo tamanho do outro vetor para, então, fazer a operação. Posição 1 2 3 4 5 Elemento 50 34 11 7 24 Posição 1 2 3 4 5 6 7 8 9 10 Elemento 100 2 56 12 0 65 93 10 244 1 h&lt;-c( 50,34,11, 7,24) i&lt;-c(100, 2,56,12, 0,65,93,10,244,1) h+i ## [1] 150 36 67 19 24 115 127 21 251 25 h;i ## [1] 50 34 11 7 24 ## [1] 100 2 56 12 0 65 93 10 244 1 h+i ## [1] 150 36 67 19 24 115 127 21 251 25 E se não forem múltiplos? Nesse caso vamos ter uma aviso, em que o R ao fazer o preenchimento dos valores faltantes vai querer saber se está certo o que estamos fazendo e emitindo um warning. j&lt;-c(50,34,11,7,24,631) k&lt;-c(100,2,56,12,0,65,93,10,244,1) j+k ## Warning in j + k: comprimento do objeto maior não é múltiplo do comprimento do ## objeto menor ## [1] 150 36 67 19 24 696 143 44 255 8 3.1.1.2 Matrizes Da mesma forma que utilizamos [ ] para acessar elementos específicos em um vetor, estes podem ser utilizados para acessar elementos de matrizes. Lembrando que as matrizes possuem duas dimensões e que as dimensões são organizadas na sequência de linhas e colunas. l&lt;-cbind(matrix(14:1, ncol=2),matrix(1:14, ncol=2)) l ## [,1] [,2] [,3] [,4] ## [1,] 14 7 1 8 ## [2,] 13 6 2 9 ## [3,] 12 5 3 10 ## [4,] 11 4 4 11 ## [5,] 10 3 5 12 ## [6,] 9 2 6 13 ## [7,] 8 1 7 14 As linhas e colunas [linhas, colunas] são numeradas sequencialmente [x...n,y] e [x,y...n]. Podemos desta forma selecionar uma ou várias linhas e colunas de uma só vez. Para isto basta apenas numerar a linhas ou coluna requerida. l[1,] # Apenas a primeira linhas ## [1] 14 7 1 8 l[,1] # Apenas a primeira coluna ## [1] 14 13 12 11 10 9 8 l[1:3,] # O intervalo de linhas entre 1 a 3 ## [,1] [,2] [,3] [,4] ## [1,] 14 7 1 8 ## [2,] 13 6 2 9 ## [3,] 12 5 3 10 l[,1:3] # O intervalo de colunas entre 1 e 3 ## [,1] [,2] [,3] ## [1,] 14 7 1 ## [2,] 13 6 2 ## [3,] 12 5 3 ## [4,] 11 4 4 ## [5,] 10 3 5 ## [6,] 9 2 6 ## [7,] 8 1 7 l[-3,] # Exceto a terceira linha ## [,1] [,2] [,3] [,4] ## [1,] 14 7 1 8 ## [2,] 13 6 2 9 ## [3,] 11 4 4 11 ## [4,] 10 3 5 12 ## [5,] 9 2 6 13 ## [6,] 8 1 7 14 l[,-3] # Exceto a terceira coluna ## [,1] [,2] [,3] ## [1,] 14 7 8 ## [2,] 13 6 9 ## [3,] 12 5 10 ## [4,] 11 4 11 ## [5,] 10 3 12 ## [6,] 9 2 13 ## [7,] 8 1 14 l[-1:-3,] # Exceto o intervalo de linhas entre 1 a 3 ## [,1] [,2] [,3] [,4] ## [1,] 11 4 4 11 ## [2,] 10 3 5 12 ## [3,] 9 2 6 13 ## [4,] 8 1 7 14 l[,-1:-3] # Exceto o intervalo de colunas entre 1 e 3 ## [1] 8 9 10 11 12 13 14 Podemos também acessar elementos específicos de uma matriz definindo o “endereço” do elemento nas linhas e colunas. l[2,3] # Acessa apenas o elemento do cruzamento da linha 2 e coluna 3 ## [1] 2 Para facilitar a manipulação das matrizes podemos nomear as linhas e colunas. Para isso podemos utilizar as funções colnames() e rownames(). nrow(l) # Retorna o número de linhas ## [1] 7 ncol(l) # Retorna o número de colunas ## [1] 4 dim(l) # Retorna as dimnesões (n° de linhas e colunas) ## [1] 7 4 l ## [,1] [,2] [,3] [,4] ## [1,] 14 7 1 8 ## [2,] 13 6 2 9 ## [3,] 12 5 3 10 ## [4,] 11 4 4 11 ## [5,] 10 3 5 12 ## [6,] 9 2 6 13 ## [7,] 8 1 7 14 rownames(l)&lt;-letters[1:7] # Atribui 7 letras minúsculas sequenciais de &quot;a&quot; até &quot;g&quot; como nomes das linhas l ## [,1] [,2] [,3] [,4] ## a 14 7 1 8 ## b 13 6 2 9 ## c 12 5 3 10 ## d 11 4 4 11 ## e 10 3 5 12 ## f 9 2 6 13 ## g 8 1 7 14 colnames(l)&lt;-LETTERS[1:ncol(l)] # Atribui letras maiúsculas sequenciais obedecendo o número de colunas como nomes das colunas l ## A B C D ## a 14 7 1 8 ## b 13 6 2 9 ## c 12 5 3 10 ## d 11 4 4 11 ## e 10 3 5 12 ## f 9 2 6 13 ## g 8 1 7 14 Agora podemos acessar via nomes das linhas e colunas também. l[&quot;a&quot;,] # Apenas a primeira linhas ## A B C D ## 14 7 1 8 l[,&quot;A&quot;] # Apenas a primeira coluna ## a b c d e f g ## 14 13 12 11 10 9 8 l[letters[1:3],] # O intervalo de linhas entre &quot;a&quot; a &quot;c&quot; ## A B C D ## a 14 7 1 8 ## b 13 6 2 9 ## c 12 5 3 10 l[,LETTERS[1:3]] # O intervalo de colunas entre &quot;A&quot; e &quot;C&quot; ## A B C ## a 14 7 1 ## b 13 6 2 ## c 12 5 3 ## d 11 4 4 ## e 10 3 5 ## f 9 2 6 ## g 8 1 7 l[c(&quot;a&quot;,&quot;c&quot;,&quot;d&quot;),] # Seleciona as linhas &quot;a&quot;, &quot;c&quot; e &quot;d&quot; ## A B C D ## a 14 7 1 8 ## c 12 5 3 10 ## d 11 4 4 11 l[,c(&quot;A&quot;,&quot;C&quot;,&quot;D&quot;)] # Seleciona as colunas &quot;a&quot;, &quot;c&quot; e &quot;d&quot; ## A C D ## a 14 1 8 ## b 13 2 9 ## c 12 3 10 ## d 11 4 11 ## e 10 5 12 ## f 9 6 13 ## g 8 7 14 3.1.1.3 Arrays Sendo muito similares aos vetores e matrizes, os arrays podem ter n dimensões. m&lt;-1:24 dim(m)&lt;-c(4,3,2) m ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 # ou m&lt;-array(1:24,c(4,3,2)) m ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 m[1,,] # Retorna as primeiras linhas do array ## [,1] [,2] ## [1,] 1 13 ## [2,] 5 17 ## [3,] 9 21 m[,2,] # Retorna as segundas colunas do array ## [,1] [,2] ## [1,] 5 17 ## [2,] 6 18 ## [3,] 7 19 ## [4,] 8 20 m[1,2,] # Retorna as intersecções entre as primeiras linhas com as segundas colunas ## [1] 5 17 m[1,2,2] # Retorna as intersecções entre a primeira linha com segunda coluna da sugunda camada ## [1] 17 3.1.1.4 Data Frame Sendo semelhantes às matrizes, os data frames pode serm acessados pelo número das linhas ou colunas. Equipes&lt;-c(&quot;Flamengo&quot;, &quot;Santos&quot;, &quot;Palmeiras&quot;, &quot;Grêmio&quot;, &quot;Athletico Paranaense&quot;, &quot;Săo Paulo&quot;, &quot;Internacional&quot;, &quot;Corinthians&quot;, &quot;Fortaleza&quot;, &quot;Goiás&quot;, &quot;Bahia&quot;, &quot;Vasco da Gama&quot;, &quot;Atlético Mineiro&quot;, &quot;Fluminense&quot;, &quot;Botafogo&quot;, &quot;Ceará&quot;, &quot;Cruzeiro&quot;, &quot;CSA&quot;, &quot;Chapecoense&quot;, &quot;Avaí&quot;) Jogos&lt;-c(&quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;, &quot;38&quot;) Vitórias&lt;-c(&quot;28&quot;, &quot;22&quot;, &quot;21&quot;, &quot;19&quot;, &quot;18&quot;, &quot;17&quot;, &quot;16&quot;, &quot;14&quot;, &quot;15&quot;, &quot;15&quot;, &quot;12&quot;, &quot;12&quot;, &quot;13&quot;, &quot;12&quot;, &quot;13&quot;, &quot;10&quot;, &quot;7&quot;, &quot;8&quot;, &quot;7&quot;, &quot;3&quot;) Empates&lt;-c(&quot;6&quot;, &quot;8&quot;, &quot;11&quot;, &quot;8&quot;, &quot;10&quot;, &quot;12&quot;, &quot;9&quot;, &quot;14&quot;, &quot;8&quot;, &quot;7&quot;, &quot;13&quot;, &quot;13&quot;, &quot;9&quot;, &quot;10&quot;, &quot;4&quot;, &quot;9&quot;, &quot;15&quot;, &quot;8&quot;, &quot;11&quot;, &quot;11&quot;) Derrotas&lt;-c(&quot;4&quot;, &quot;8&quot;, &quot;6&quot;, &quot;11&quot;, &quot;10&quot;, &quot;9&quot;, &quot;13&quot;, &quot;10&quot;, &quot;15&quot;, &quot;16&quot;, &quot;13&quot;, &quot;13&quot;, &quot;16&quot;, &quot;16&quot;, &quot;21&quot;, &quot;19&quot;, &quot;16&quot;, &quot;22&quot;, &quot;20&quot;, &quot;24&quot;) Gols.Pró&lt;-c(&quot;86&quot;, &quot;60&quot;, &quot;61&quot;, &quot;64&quot;, &quot;51&quot;, &quot;39&quot;, &quot;44&quot;, &quot;42&quot;, &quot;50&quot;, &quot;46&quot;, &quot;44&quot;, &quot;39&quot;, &quot;45&quot;, &quot;38&quot;, &quot;31&quot;, &quot;36&quot;, &quot;27&quot;, &quot;24&quot;, &quot;31&quot;, &quot;18&quot;) Gols.Contra&lt;-c(&quot;37&quot;, &quot;33&quot;, &quot;32&quot;, &quot;39&quot;, &quot;32&quot;, &quot;30&quot;, &quot;39&quot;, &quot;34&quot;, &quot;49&quot;, &quot;64&quot;, &quot;43&quot;, &quot;45&quot;, &quot;49&quot;, &quot;46&quot;, &quot;45&quot;, &quot;41&quot;, &quot;46&quot;, &quot;58&quot;, &quot;52&quot;, &quot;62&quot;) Pontos&lt;-c(&quot;90&quot;, &quot;74&quot;, &quot;74&quot;, &quot;65&quot;, &quot;64&quot;, &quot;63&quot;, &quot;57&quot;, &quot;56&quot;, &quot;53&quot;, &quot;52&quot;, &quot;49&quot;, &quot;49&quot;, &quot;48&quot;, &quot;46&quot;, &quot;43&quot;, &quot;39&quot;, &quot;36&quot;, &quot;32&quot;, &quot;32&quot;, &quot;20&quot;) Saldo.de.Gols&lt;-c(&quot;49&quot;, &quot;27&quot;, &quot;29&quot;, &quot;25&quot;, &quot;19&quot;, &quot;9&quot;, &quot;5&quot;, &quot;8&quot;, &quot;1&quot;, &quot;-18&quot;, &quot;1&quot;, &quot;-6&quot;, &quot;-4&quot;, &quot;-8&quot;, &quot;-14&quot;, &quot;-5&quot;, &quot;-19&quot;, &quot;-34&quot;, &quot;-21&quot;, &quot;-44&quot;) Aprov.&lt;-c(&quot;79&quot;, &quot;65&quot;, &quot;65&quot;, &quot;57&quot;, &quot;56&quot;, &quot;55&quot;, &quot;5&quot;, &quot;49&quot;, &quot;46&quot;, &quot;46&quot;, &quot;43&quot;, &quot;43&quot;, &quot;42&quot;, &quot;4&quot;, &quot;38&quot;, &quot;34&quot;, &quot;32&quot;, &quot;28&quot;, &quot;28&quot;, &quot;18&quot;) Destino&lt;-c(&quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Libertadores&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;Sulamericana&quot;, &quot;NA&quot;, &quot;NA&quot;, &quot;Rebaixado&quot;, &quot;Rebaixado&quot;, &quot;Rebaixado&quot;, &quot;Rebaixado&quot;) Campeonato.Brasileiro.2019&lt;-as.data.frame(cbind(Equipes,Jogos,Vitórias,Empates,Derrotas,Gols.Pró,Gols.Contra,Pontos,Saldo.de.Gols, Aprov., Destino)) Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores Săo Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 10 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana Bahia 38 12 13 13 44 43 49 1 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 -6 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana Botafogo 38 13 4 21 31 45 43 -14 38 NA Ceará 38 10 9 19 36 41 39 -5 34 NA Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado CSA 38 8 8 22 24 58 32 -34 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado Campeonato.Brasileiro.2019[1,] # Retorna a primeira linha do data frame ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 1 Flamengo 38 28 6 4 86 37 90 ## Saldo.de.Gols Aprov. Destino ## 1 49 79 Libertadores Campeonato.Brasileiro.2019[,1] # Retorna a primeira coluna do data frame ## [1] &quot;Flamengo&quot; &quot;Santos&quot; &quot;Palmeiras&quot; ## [4] &quot;Grêmio&quot; &quot;Athletico Paranaense&quot; &quot;Săo Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; &quot;Fortaleza&quot; ## [10] &quot;Goiás&quot; &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atlético Mineiro&quot; &quot;Fluminense&quot; &quot;Botafogo&quot; ## [16] &quot;Ceará&quot; &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; Todas as outras combinações utilizadas nas matrizes podem ser utilizadas aqui nos data frames. No entanto, os data frames possuem uma outra “vantagem” sobre as matrizes. Além de armazenar elementos de diferentes tipos (numeric, character, logical e etc), eles também podemser acessados utilizando $. Campeonato.Brasileiro.2019$Equipes # Retorna os elementos da coluna &quot;Equipes&quot; ## [1] &quot;Flamengo&quot; &quot;Santos&quot; &quot;Palmeiras&quot; ## [4] &quot;Grêmio&quot; &quot;Athletico Paranaense&quot; &quot;Săo Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; &quot;Fortaleza&quot; ## [10] &quot;Goiás&quot; &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atlético Mineiro&quot; &quot;Fluminense&quot; &quot;Botafogo&quot; ## [16] &quot;Ceará&quot; &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; Campeonato.Brasileiro.2019$Vitórias # Retorna os elementos da coluna &quot;Vitórias&quot; ## [1] &quot;28&quot; &quot;22&quot; &quot;21&quot; &quot;19&quot; &quot;18&quot; &quot;17&quot; &quot;16&quot; &quot;14&quot; &quot;15&quot; &quot;15&quot; &quot;12&quot; &quot;12&quot; &quot;13&quot; &quot;12&quot; &quot;13&quot; ## [16] &quot;10&quot; &quot;7&quot; &quot;8&quot; &quot;7&quot; &quot;3&quot; Campeonato.Brasileiro.2019$Gols.Pró # Retorna os elementos da coluna &quot;Gols.Pró&quot; ## [1] &quot;86&quot; &quot;60&quot; &quot;61&quot; &quot;64&quot; &quot;51&quot; &quot;39&quot; &quot;44&quot; &quot;42&quot; &quot;50&quot; &quot;46&quot; &quot;44&quot; &quot;39&quot; &quot;45&quot; &quot;38&quot; &quot;31&quot; ## [16] &quot;36&quot; &quot;27&quot; &quot;24&quot; &quot;31&quot; &quot;18&quot; Campeonato.Brasileiro.2019$Saldo.de.Gols # Retorna os elementos da coluna &quot;Saldo.de.Gols&quot; ## [1] &quot;49&quot; &quot;27&quot; &quot;29&quot; &quot;25&quot; &quot;19&quot; &quot;9&quot; &quot;5&quot; &quot;8&quot; &quot;1&quot; &quot;-18&quot; &quot;1&quot; &quot;-6&quot; ## [13] &quot;-4&quot; &quot;-8&quot; &quot;-14&quot; &quot;-5&quot; &quot;-19&quot; &quot;-34&quot; &quot;-21&quot; &quot;-44&quot; Campeonato.Brasileiro.2019$Destino # Retorna os elementos da coluna &quot;Destino&quot; ## [1] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; ## [6] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Sulamericana&quot; &quot;Sulamericana&quot; ## [11] &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;NA&quot; ## [16] &quot;NA&quot; &quot;Rebaixado&quot; &quot;Rebaixado&quot; &quot;Rebaixado&quot; &quot;Rebaixado&quot; Campeonato.Brasileiro.2019$Equipes[2] # Retorna o segundo elemento da coluna &quot;Nome&quot; ## [1] &quot;Santos&quot; Campeonato.Brasileiro.2019$Vitórias[5] # Retorna o quinto elemento da coluna &quot;Vitórias&quot; ## [1] &quot;18&quot; Campeonato.Brasileiro.2019$Gols.Pró[3] # Retorna os elementos da coluna &quot;Gols.Pró&quot; ## [1] &quot;61&quot; Campeonato.Brasileiro.2019$Saldo.de.Gols[1] # Retorna os elementos da coluna &quot;Nivel.deR&quot; ## [1] &quot;49&quot; Campeonato.Brasileiro.2019$Destino[10] # Retorna os elementos da décima coluna &quot;Destino&quot; ## [1] &quot;Sulamericana&quot; Outra maneira de acessar informações pode através []. Campeonato.Brasileiro.2019[Campeonato.Brasileiro.2019$Equipes==&quot;Flamengo&quot;,] # Retorna apenas as informações da coluna &quot;Equipes&quot; que atendem o critério &quot;Flamengo&quot; ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 1 Flamengo 38 28 6 4 86 37 90 ## Saldo.de.Gols Aprov. Destino ## 1 49 79 Libertadores split(Campeonato.Brasileiro.2019,Destino) # Retorna apenas as informações da coluna &quot;Destino&quot; ## $Libertadores ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra ## 1 Flamengo 38 28 6 4 86 37 ## 2 Santos 38 22 8 8 60 33 ## 3 Palmeiras 38 21 11 6 61 32 ## 4 Grêmio 38 19 8 11 64 39 ## 5 Athletico Paranaense 38 18 10 10 51 32 ## 6 Săo Paulo 38 17 12 9 39 30 ## 7 Internacional 38 16 9 13 44 39 ## 8 Corinthians 38 14 14 10 42 34 ## Pontos Saldo.de.Gols Aprov. Destino ## 1 90 49 79 Libertadores ## 2 74 27 65 Libertadores ## 3 74 29 65 Libertadores ## 4 65 25 57 Libertadores ## 5 64 19 56 Libertadores ## 6 63 9 55 Libertadores ## 7 57 5 5 Libertadores ## 8 56 8 49 Libertadores ## ## $`NA` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 15 Botafogo 38 13 4 21 31 45 43 ## 16 Ceará 38 10 9 19 36 41 39 ## Saldo.de.Gols Aprov. Destino ## 15 -14 38 NA ## 16 -5 34 NA ## ## $Rebaixado ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 17 Cruzeiro 38 7 15 16 27 46 36 ## 18 CSA 38 8 8 22 24 58 32 ## 19 Chapecoense 38 7 11 20 31 52 32 ## 20 Avaí 38 3 11 24 18 62 20 ## Saldo.de.Gols Aprov. Destino ## 17 -19 32 Rebaixado ## 18 -34 28 Rebaixado ## 19 -21 28 Rebaixado ## 20 -44 18 Rebaixado ## ## $Sulamericana ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 9 Fortaleza 38 15 8 15 50 49 53 ## 10 Goiás 38 15 7 16 46 64 52 ## 11 Bahia 38 12 13 13 44 43 49 ## 12 Vasco da Gama 38 12 13 13 39 45 49 ## 13 Atlético Mineiro 38 13 9 16 45 49 48 ## 14 Fluminense 38 12 10 16 38 46 46 ## Saldo.de.Gols Aprov. Destino ## 9 1 46 Sulamericana ## 10 -18 46 Sulamericana ## 11 1 43 Sulamericana ## 12 -6 43 Sulamericana ## 13 -4 42 Sulamericana ## 14 -8 4 Sulamericana Vou criar alguns verores aleatórios. gr1 &lt;- rep(letters[1:4],each=5) gr1 ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; &quot;c&quot; &quot;c&quot; &quot;c&quot; &quot;d&quot; &quot;d&quot; &quot;d&quot; &quot;d&quot; ## [20] &quot;d&quot; gr2 &lt;- c(rep(1:2,each=5),rep(2:3,each=5)) gr2 ## [1] 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 fc1 &lt;- factor(rep(letters[1:4],each=5)) fc1 ## [1] a a a a a b b b b b c c c c c d d d d d ## Levels: a b c d fc2 &lt;- factor(c(rep(1:2,each=5),rep(2:3,each=5))) fc2 ## [1] 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 ## Levels: 1 2 3 split(Campeonato.Brasileiro.2019,f=(gr1)) # Divide o Campeonato.Brasileiro.2019 de acordo com os vetores informados ## $a ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra ## 1 Flamengo 38 28 6 4 86 37 ## 2 Santos 38 22 8 8 60 33 ## 3 Palmeiras 38 21 11 6 61 32 ## 4 Grêmio 38 19 8 11 64 39 ## 5 Athletico Paranaense 38 18 10 10 51 32 ## Pontos Saldo.de.Gols Aprov. Destino ## 1 90 49 79 Libertadores ## 2 74 27 65 Libertadores ## 3 74 29 65 Libertadores ## 4 65 25 57 Libertadores ## 5 64 19 56 Libertadores ## ## $b ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 6 Săo Paulo 38 17 12 9 39 30 63 ## 7 Internacional 38 16 9 13 44 39 57 ## 8 Corinthians 38 14 14 10 42 34 56 ## 9 Fortaleza 38 15 8 15 50 49 53 ## 10 Goiás 38 15 7 16 46 64 52 ## Saldo.de.Gols Aprov. Destino ## 6 9 55 Libertadores ## 7 5 5 Libertadores ## 8 8 49 Libertadores ## 9 1 46 Sulamericana ## 10 -18 46 Sulamericana ## ## $c ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 11 Bahia 38 12 13 13 44 43 49 ## 12 Vasco da Gama 38 12 13 13 39 45 49 ## 13 Atlético Mineiro 38 13 9 16 45 49 48 ## 14 Fluminense 38 12 10 16 38 46 46 ## 15 Botafogo 38 13 4 21 31 45 43 ## Saldo.de.Gols Aprov. Destino ## 11 1 43 Sulamericana ## 12 -6 43 Sulamericana ## 13 -4 42 Sulamericana ## 14 -8 4 Sulamericana ## 15 -14 38 NA ## ## $d ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 16 Ceará 38 10 9 19 36 41 39 ## 17 Cruzeiro 38 7 15 16 27 46 36 ## 18 CSA 38 8 8 22 24 58 32 ## 19 Chapecoense 38 7 11 20 31 52 32 ## 20 Avaí 38 3 11 24 18 62 20 ## Saldo.de.Gols Aprov. Destino ## 16 -5 34 NA ## 17 -19 32 Rebaixado ## 18 -34 28 Rebaixado ## 19 -21 28 Rebaixado ## 20 -44 18 Rebaixado split(Campeonato.Brasileiro.2019,f=(gr2)) # Divide o Campeonato.Brasileiro.2019 de acordo com os vetores informados ## $`1` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra ## 1 Flamengo 38 28 6 4 86 37 ## 2 Santos 38 22 8 8 60 33 ## 3 Palmeiras 38 21 11 6 61 32 ## 4 Grêmio 38 19 8 11 64 39 ## 5 Athletico Paranaense 38 18 10 10 51 32 ## Pontos Saldo.de.Gols Aprov. Destino ## 1 90 49 79 Libertadores ## 2 74 27 65 Libertadores ## 3 74 29 65 Libertadores ## 4 65 25 57 Libertadores ## 5 64 19 56 Libertadores ## ## $`2` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 6 Săo Paulo 38 17 12 9 39 30 63 ## 7 Internacional 38 16 9 13 44 39 57 ## 8 Corinthians 38 14 14 10 42 34 56 ## 9 Fortaleza 38 15 8 15 50 49 53 ## 10 Goiás 38 15 7 16 46 64 52 ## 11 Bahia 38 12 13 13 44 43 49 ## 12 Vasco da Gama 38 12 13 13 39 45 49 ## 13 Atlético Mineiro 38 13 9 16 45 49 48 ## 14 Fluminense 38 12 10 16 38 46 46 ## 15 Botafogo 38 13 4 21 31 45 43 ## Saldo.de.Gols Aprov. Destino ## 6 9 55 Libertadores ## 7 5 5 Libertadores ## 8 8 49 Libertadores ## 9 1 46 Sulamericana ## 10 -18 46 Sulamericana ## 11 1 43 Sulamericana ## 12 -6 43 Sulamericana ## 13 -4 42 Sulamericana ## 14 -8 4 Sulamericana ## 15 -14 38 NA ## ## $`3` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 16 Ceará 38 10 9 19 36 41 39 ## 17 Cruzeiro 38 7 15 16 27 46 36 ## 18 CSA 38 8 8 22 24 58 32 ## 19 Chapecoense 38 7 11 20 31 52 32 ## 20 Avaí 38 3 11 24 18 62 20 ## Saldo.de.Gols Aprov. Destino ## 16 -5 34 NA ## 17 -19 32 Rebaixado ## 18 -34 28 Rebaixado ## 19 -21 28 Rebaixado ## 20 -44 18 Rebaixado split(Campeonato.Brasileiro.2019,f=list(gr1,gr2), drop = TRUE, sep = &quot;: &quot;) # Divide o Campeonato.Brasileiro.2019 de acordo com as listas informadas ## $`a: 1` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra ## 1 Flamengo 38 28 6 4 86 37 ## 2 Santos 38 22 8 8 60 33 ## 3 Palmeiras 38 21 11 6 61 32 ## 4 Grêmio 38 19 8 11 64 39 ## 5 Athletico Paranaense 38 18 10 10 51 32 ## Pontos Saldo.de.Gols Aprov. Destino ## 1 90 49 79 Libertadores ## 2 74 27 65 Libertadores ## 3 74 29 65 Libertadores ## 4 65 25 57 Libertadores ## 5 64 19 56 Libertadores ## ## $`b: 2` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 6 Săo Paulo 38 17 12 9 39 30 63 ## 7 Internacional 38 16 9 13 44 39 57 ## 8 Corinthians 38 14 14 10 42 34 56 ## 9 Fortaleza 38 15 8 15 50 49 53 ## 10 Goiás 38 15 7 16 46 64 52 ## Saldo.de.Gols Aprov. Destino ## 6 9 55 Libertadores ## 7 5 5 Libertadores ## 8 8 49 Libertadores ## 9 1 46 Sulamericana ## 10 -18 46 Sulamericana ## ## $`c: 2` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 11 Bahia 38 12 13 13 44 43 49 ## 12 Vasco da Gama 38 12 13 13 39 45 49 ## 13 Atlético Mineiro 38 13 9 16 45 49 48 ## 14 Fluminense 38 12 10 16 38 46 46 ## 15 Botafogo 38 13 4 21 31 45 43 ## Saldo.de.Gols Aprov. Destino ## 11 1 43 Sulamericana ## 12 -6 43 Sulamericana ## 13 -4 42 Sulamericana ## 14 -8 4 Sulamericana ## 15 -14 38 NA ## ## $`d: 3` ## Equipes Jogos Vitórias Empates Derrotas Gols.Pró Gols.Contra Pontos ## 16 Ceará 38 10 9 19 36 41 39 ## 17 Cruzeiro 38 7 15 16 27 46 36 ## 18 CSA 38 8 8 22 24 58 32 ## 19 Chapecoense 38 7 11 20 31 52 32 ## 20 Avaí 38 3 11 24 18 62 20 ## Saldo.de.Gols Aprov. Destino ## 16 -5 34 NA ## 17 -19 32 Rebaixado ## 18 -34 28 Rebaixado ## 19 -21 28 Rebaixado ## 20 -44 18 Rebaixado Alterando elementos dentro do data frame. Campeonato.Brasileiro.2019$Destino # Retorna apenas as informações da coluna &quot;Destino&quot; ## [1] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; ## [6] &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Libertadores&quot; &quot;Sulamericana&quot; &quot;Sulamericana&quot; ## [11] &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;Sulamericana&quot; &quot;NA&quot; ## [16] &quot;NA&quot; &quot;Rebaixado&quot; &quot;Rebaixado&quot; &quot;Rebaixado&quot; &quot;Rebaixado&quot; Campeonato.Brasileiro.2019$Destino[Campeonato.Brasileiro.2019$Destino==&quot;NA&quot;]&lt;-&quot;Lugar Algum&quot; # Substitui &quot;Libertadores&quot; na coluna &quot;Destino&quot; por &quot;Liberta&quot;. Veja como ficou com a informação alterada. Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores Săo Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 10 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana Bahia 38 12 13 13 44 43 49 1 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 -6 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana Botafogo 38 13 4 21 31 45 43 -14 38 Lugar Algum Ceará 38 10 9 19 36 41 39 -5 34 Lugar Algum Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado CSA 38 8 8 22 24 58 32 -34 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado Vamos expurgar remover o Vasco da Gama da nossa lista. Campeonato.Brasileiro.2019$Equipes # Retorna apenas as informações da coluna &quot;Equipes&quot; ## [1] &quot;Flamengo&quot; &quot;Santos&quot; &quot;Palmeiras&quot; ## [4] &quot;Grêmio&quot; &quot;Athletico Paranaense&quot; &quot;Săo Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; &quot;Fortaleza&quot; ## [10] &quot;Goiás&quot; &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atlético Mineiro&quot; &quot;Fluminense&quot; &quot;Botafogo&quot; ## [16] &quot;Ceará&quot; &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; Campeonato.Brasileiro.2019.SV&lt;-Campeonato.Brasileiro.2019[Campeonato.Brasileiro.2019$Equipes!=&quot;Vasco da Gama&quot;,] #Seleciona tudo exceto aquilo que for de &quot;Vasco da Gama&quot; Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino 1 Flamengo 38 28 6 4 86 37 90 49 79 Libertadores 2 Santos 38 22 8 8 60 33 74 27 65 Libertadores 3 Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores 4 Grêmio 38 19 8 11 64 39 65 25 57 Libertadores 5 Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores 6 Săo Paulo 38 17 12 9 39 30 63 9 55 Libertadores 7 Internacional 38 16 9 13 44 39 57 5 5 Libertadores 8 Corinthians 38 14 14 10 42 34 56 8 49 Libertadores 9 Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana 10 Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana 11 Bahia 38 12 13 13 44 43 49 1 43 Sulamericana 13 Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana 14 Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana 15 Botafogo 38 13 4 21 31 45 43 -14 38 Lugar Algum 16 Ceará 38 10 9 19 36 41 39 -5 34 Lugar Algum 17 Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado 18 CSA 38 8 8 22 24 58 32 -34 28 Rebaixado 19 Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado 20 Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado Atendendo a pedidos, vamos continuar brevemente com manipulação de dados em data.frame. As funções grep, grepl, regexpr, gregexpr e regexec busca por elementos de um objeto que coincidem com um argumento padrão. 3.1.2 grep() grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino) # retorna as posições de tudo no vetor Campeonato.Brasileiro.2019$Destino que coincide com Lugar Algum ## [1] 15 16 Durante a aula gravada eu me enrolei um pouco na demonstração abaixo. Acontece que Libertadores estava escrito errado, estava escrito Libetadores (sem o r). grep(&quot;Libertadores|Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino) # retorna as posições de tudo no vetor Campeonato.Brasileiro.2019$Destino que coincide com Libetadores ou Lugar Algum ## [1] 1 2 3 4 5 6 7 8 15 16 grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino) # retorna as posições de tudo no vetor Campeonato.Brasileiro.2019$Destino que coincide com Lugar Algum ## [1] 15 16 Campeonato.Brasileiro.2019$Destino[15]&lt;-&quot;lugar algum&quot; #Substitui a 15ª posição por lugar algum&quot; Execute o comando grepanterior novamente e veja as diferenças. Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 10 10 51 32 64 19 56 Libertadores Săo Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 10 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 1 46 Sulamericana Goiás 38 15 7 16 46 64 52 -18 46 Sulamericana Bahia 38 12 13 13 44 43 49 1 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 -6 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 -4 42 Sulamericana Fluminense 38 12 10 16 38 46 46 -8 4 Sulamericana Botafogo 38 13 4 21 31 45 43 -14 38 lugar algum Ceará 38 10 9 19 36 41 39 -5 34 Lugar Algum Cruzeiro 38 7 15 16 27 46 36 -19 32 Rebaixado CSA 38 8 8 22 24 58 32 -34 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 -21 28 Rebaixado Avaí 38 3 11 24 18 62 20 -44 18 Rebaixado grep(&quot;[L l]ugar [A a]lgum&quot;,Campeonato.Brasileiro.2019$Destino) # retorna as posições de tudo no vetor Campeonato.Brasileiro.2019$Destino que coincide com Lugar/lugar ou Algum/algum ## [1] 15 16 str(grep(&quot;lugar algum&quot;, Campeonato.Brasileiro.2019$Destino)) ## int 15 str(grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino)) # mostra a estrutura de um objeto ## int 16 setdiff(grep(&quot;lugar algum&quot;, Campeonato.Brasileiro.2019$Destino), grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino)) #Identifica a difença entre X e Y ## [1] 15 setdiff(grep(&quot;Lugar Algum&quot;, Campeonato.Brasileiro.2019$Destino), grep(&quot;lugar algum&quot;, Campeonato.Brasileiro.2019$Destino)) ## [1] 16 library(purrr) ## ## Attaching package: &#39;purrr&#39; ## The following object is masked from &#39;package:magrittr&#39;: ## ## set_names suits &lt;- c(&#39;spades&#39;, &#39;clubs&#39;, &#39;diamonds&#39;, &#39;hearts&#39;) suit &lt;- unlist(map(suits, rep, 13)) head(suit) ## [1] &quot;spades&quot; &quot;spades&quot; &quot;spades&quot; &quot;spades&quot; &quot;spades&quot; &quot;spades&quot; faces &lt;- c(&#39;king&#39;, &#39;queen&#39;, &#39;jack&#39;, &#39;ten&#39;, &#39;nine&#39;, &#39;eight&#39;, &#39;seven&#39;, &#39;six&#39;, &#39;five&#39;, &#39;four&#39;, &#39;three&#39;, &#39;two&#39;, &#39;ace&#39;) face &lt;- rep(faces, 4) head(face) ## [1] &quot;king&quot; &quot;queen&quot; &quot;jack&quot; &quot;ten&quot; &quot;nine&quot; &quot;eight&quot; value &lt;- rep(13:1, 4) head(value) ## [1] 13 12 11 10 9 8 deck &lt;- data.frame(face, suit, value) head(deck) ## face suit value ## 1 king spades 13 ## 2 queen spades 12 ## 3 jack spades 11 ## 4 ten spades 10 ## 5 nine spades 9 ## 6 eight spades 8 A &lt;- subset(deck, suit == &quot;hearts&quot;) A ## face suit value ## 40 king hearts 13 ## 41 queen hearts 12 ## 42 jack hearts 11 ## 43 ten hearts 10 ## 44 nine hearts 9 ## 45 eight hearts 8 ## 46 seven hearts 7 ## 47 six hearts 6 ## 48 five hearts 5 ## 49 four hearts 4 ## 50 three hearts 3 ## 51 two hearts 2 ## 52 ace hearts 1 B &lt;- subset(deck, face == &quot;ace&quot; ) B ## face suit value ## 13 ace spades 1 ## 26 ace clubs 1 ## 39 ace diamonds 1 ## 52 ace hearts 1 setdiff(B, A) #Identifica a difença entre X e Y ## $face ## [1] &quot;ace&quot; &quot;ace&quot; &quot;ace&quot; &quot;ace&quot; ## ## $suit ## [1] &quot;spades&quot; &quot;clubs&quot; &quot;diamonds&quot; &quot;hearts&quot; ## ## $value ## [1] 1 1 1 1 Campeonato.Brasileiro.2019$Equipes[1] ## [1] &quot;Flamengo&quot; grep(&quot;Flamengo&quot;, Campeonato.Brasileiro.2019$Equipes, value = TRUE) ## [1] &quot;Flamengo&quot; 3.1.3 grepl() grepl(&quot;Flamengo&quot;, Campeonato.Brasileiro.2019$Equipes) # Retorna valores lógicos de acordo com o critério estabelecido ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 3.1.4 sub() e gsub() sub(&quot;Fla&quot;, &quot;fla&quot;, Campeonato.Brasileiro.2019$Equipes) #Substitui Fla por fla naquilo que começa com Fla ## [1] &quot;flamengo&quot; &quot;Santos&quot; &quot;Palmeiras&quot; ## [4] &quot;Grêmio&quot; &quot;Athletico Paranaense&quot; &quot;Săo Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; &quot;Fortaleza&quot; ## [10] &quot;Goiás&quot; &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atlético Mineiro&quot; &quot;Fluminense&quot; &quot;Botafogo&quot; ## [16] &quot;Ceará&quot; &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; gsub(&quot;Atlé|Athle&quot;, &quot;Atle&quot;, Campeonato.Brasileiro.2019$Equipes) #Substitui Atlé ou Athle por Atlé naquilo que contém com Atlé ou Athle ## [1] &quot;Flamengo&quot; &quot;Santos&quot; &quot;Palmeiras&quot; ## [4] &quot;Grêmio&quot; &quot;Atletico Paranaense&quot; &quot;Săo Paulo&quot; ## [7] &quot;Internacional&quot; &quot;Corinthians&quot; &quot;Fortaleza&quot; ## [10] &quot;Goiás&quot; &quot;Bahia&quot; &quot;Vasco da Gama&quot; ## [13] &quot;Atletico Mineiro&quot; &quot;Fluminense&quot; &quot;Botafogo&quot; ## [16] &quot;Ceará&quot; &quot;Cruzeiro&quot; &quot;CSA&quot; ## [19] &quot;Chapecoense&quot; &quot;Avaí&quot; Alguns elementos especiais podem ser encontrados no R como: Infinito positivo ou negativo (-Inf e Inf), elementos “não número” (NaN - Not a Number) e valores ausentes (NA, Not Available). 3/0 ## [1] Inf -3/0 ## [1] -Inf x&lt;-Inf;x ## [1] Inf y&lt;-(-Inf);y ## [1] -Inf 0/0 ## [1] NaN Inf-Inf ## [1] NaN Campeonato.Brasileiro.2019[Campeonato.Brasileiro.2019&lt;=10]&lt;-NA Equipes Jogos Vitórias Empates Derrotas Gols Pró Gols Contra Pontos Saldo de Gols Aprov Destino Flamengo 38 28 6 4 86 37 90 49 79 Libertadores Santos 38 22 8 8 60 33 74 27 65 Libertadores Palmeiras 38 21 11 6 61 32 74 29 65 Libertadores Grêmio 38 19 8 11 64 39 65 25 57 Libertadores Athletico Paranaense 38 18 NA NA 51 32 64 19 56 Libertadores Săo Paulo 38 17 12 9 39 30 63 9 55 Libertadores Internacional 38 16 9 13 44 39 57 5 5 Libertadores Corinthians 38 14 14 NA 42 34 56 8 49 Libertadores Fortaleza 38 15 8 15 50 49 53 NA 46 Sulamericana Goiás 38 15 7 16 46 64 52 NA 46 Sulamericana Bahia 38 12 13 13 44 43 49 NA 43 Sulamericana Vasco da Gama 38 12 13 13 39 45 49 NA 43 Sulamericana Atlético Mineiro 38 13 9 16 45 49 48 NA 42 Sulamericana Fluminense 38 12 NA 16 38 46 46 NA 4 Sulamericana Botafogo 38 13 4 21 31 45 43 NA 38 lugar algum Ceará 38 NA 9 19 36 41 39 NA 34 Lugar Algum Cruzeiro 38 7 15 16 27 46 36 NA 32 Rebaixado CSA 38 8 8 22 24 58 32 NA 28 Rebaixado Chapecoense 38 7 11 20 31 52 32 NA 28 Rebaixado Avaí 38 3 11 24 18 62 20 NA 18 Rebaixado any(is.na(Campeonato.Brasileiro.2019)) ## [1] TRUE Identificando onde estão os valores que atendem critérios desejados. which(is.na(Campeonato.Brasileiro.2019), arr.ind=TRUE) ## row col ## [1,] 16 3 ## [2,] 5 4 ## [3,] 14 4 ## [4,] 5 5 ## [5,] 8 5 ## [6,] 9 9 ## [7,] 10 9 ## [8,] 11 9 ## [9,] 12 9 ## [10,] 13 9 ## [11,] 14 9 ## [12,] 15 9 ## [13,] 16 9 ## [14,] 17 9 ## [15,] 18 9 ## [16,] 19 9 ## [17,] 20 9 which((Campeonato.Brasileiro.2019&lt;1), arr.ind=TRUE) ## row col 3.2 Operadores Assista este conteúdo em Cap 2 - Operadores no PVANet O R tem vários operadores, tais quais outras linguagens, que nos permitem realizar procedimentos aritiméticos, lógicos ou relacionais. Os operadores aritméticos atuam em 2 elementos (x e y) e retorna respostas lógicas. Estes elementos, pos sua vez, podem ser de modo (mode()) numéricos ou complexos e também variáveis lógicas. Símbolo Operação + adição - subtração * multiplicação / divisão ^ potência %% resto da divisão %/% divisão inteira x&lt;-2;y&lt;-3 x+y ## [1] 5 x-y ## [1] -1 x*y ## [1] 6 y/x ## [1] 1.5 y%/%x ## [1] 1 y%%x ## [1] 1 y^x ## [1] 9 Os operadores de comparações atuam em cada elemento de 2 objetos sob comparação (fazendo o recycling se necessário) retornando um objeto do mesmo tamanho. Símbolo Relação &lt; menor que &gt; maior que &lt;= menor ou igual &gt;= maior ou igual == igual != diferente x&lt;-1:3;y&lt;-1:3 x&gt;y ## [1] FALSE FALSE FALSE x&lt;y ## [1] FALSE FALSE FALSE x*y ## [1] 1 4 9 y&gt;=x ## [1] TRUE TRUE TRUE y&lt;=x ## [1] TRUE TRUE TRUE y==x ## [1] TRUE TRUE TRUE y!=x ## [1] FALSE FALSE FALSE Caso queira comparar bancos de dados completos, por inteiro de uma vez só, utilize identical(x,y) e all.equal(x,y). identicalfaz uma comparação estrita da representação dos objetos e retorna como TRUE ou FALSE. all.equal compara a “igualdade próxima” e retorna TRUE ou mostra as diferenças. x&lt;-0.9;y&lt;-0.9 identical(x,y) ## [1] TRUE identical(0.9, 1.1 - 0.2) ## [1] FALSE all.equal(x,y) ## [1] TRUE all.equal(0.9, 1.1 - 0.2, tolerance = 1e-16) ## [1] &quot;Mean relative difference: 1.233581e-16&quot; Operadores lógicos são utilizados para para testes lógicos entre 1 ou 2 objetos e retorna valores lógicos também. Símbolo Relação ! Logical NOT &amp; Logical AND or Exclusive OR Lembrando que temos outro operadores $, @, [, [[, :, ?, &lt;-, &lt;&lt;-, =, :: que já começamos a manipular. Existem dois tipos de pessoas: = &amp; &lt;- Com o passar do tempo vamos “brincando” com cada operador e, assim, assimilando o que cada uma faz. 3.2.1 Iterações 3.2.1.1 while() Essa forma de loop é menos comumente usada e potencialmente perigosa, uma vez que ela pode resultar em uma execução descontrolada. Por isso, em muitos casos iterações restritivas são mais adequadas. A função while() requer uma condição testável que continuará a resultar em declarações subsequentes a serem executadas até o resultado do teste dar falso (FALSE). Estrutura: Começa com a palavra while seguida por parênteses e colchetes while(){} A segunda parte vai dentro de parênteses e diz respeito a uma expressão lógica e a terceira parte, entre colchetes, o corpo do loop. while(abc){xyz} #Se abc for TRUE ele vai executar o resto {xyz}. Depois volta para checar se (abc) continua TRUE ou FALSE para decidir se continua no loop ou parar. while(condição){ “Código a ser executado” } Fonte: Guru99 Exemplo 1: Teste Ter aula na segunda-feira é bom ou não? while(FALSE){ print(&quot;Aula segunda-feira é ótimo!&quot;)} while(TRUE){ print(&quot;Aula segunda-feira é ótimo!&quot;)} Exemplo 2: Teste Num concurso de beleza Jackson desafiou qualquer um de seus alunos. Cada um recebeu uma nota. Jackson&lt;-9.5 Aluno&lt;-6 while(Aluno&lt;Jackson){ print(Jackson)} 3.2.1.2 for() É similar ao while(), mas é mais conveniente na maioria dos casos. Iterações restritas (loops) destinam-se a execução de um número fixo de vezes dos comandos usando a função for(). O loop é executado tantas vezes quanto variam os valores de i. Começa com a palavra for seguindo de por parênteses e colchetes – for(){}. () não especifica funções lógicas como no while, mas especifica as interações do loop. {} são usados para preencher com os comandos do loop for(i in conjunto_de_valores){ comandos que serão repetidos } Fonte:tutorialspoint for(i in 1:5){ print(&quot;Aula segunda-feira é ótimo!&quot;) } ## [1] &quot;Aula segunda-feira é ótimo!&quot; ## [1] &quot;Aula segunda-feira é ótimo!&quot; ## [1] &quot;Aula segunda-feira é ótimo!&quot; ## [1] &quot;Aula segunda-feira é ótimo!&quot; ## [1] &quot;Aula segunda-feira é ótimo!&quot; Significa que Aula segunda-feira é ótimo! Será mostrada 5 vezes sempre retornando como o objeto criado i. for(i in 1:5){ print((i+1)*3) } ## [1] 6 ## [1] 9 ## [1] 12 ## [1] 15 ## [1] 18 Não importa onde você começa ou o tipo de vetor que é (Caractere, número e etc). Basicamente toda vez que mudar ele vai executar o que estiver dentro do corpo do loop. 3.2.2 Condicionais 3.2.2.1 if, else A função if() é usado para conduzir uma ou mais declarações contidas dentro de [], fornecendo a condição dentro de (). Voltando para nosso concurso de beleza, temos um controle um pouco mais inteligente do resultado mostrado. Jackson&lt;-9.5 Aluno&lt;-6 if(Jackson&gt;Aluno){ print(&quot;Jackson é mais bonito que Aluno!&quot;) } ## [1] &quot;Jackson é mais bonito que Aluno!&quot; if(Aluno*2&gt;=Jackson){ print(&quot;Aluno é mais bonito!&quot;) } ## [1] &quot;Aluno é mais bonito!&quot; Adaptando a o código acima para fazer a declaração condicional FALSE simplesmente retorna nenhum comando no prompt uma vez que o código não disse como R deveria responder nesse caso. if(Aluno*2&gt;=Jackson^2){ print(&quot;Aluno é mais bonito!&quot;) } Existem 2 métodos de informar ao R como responder em casos onde a declaração de condição é retornada como FALSE: usando o modificador else ou a função ifelse(). Ao contrário de uma função qualquer, else não pode ser usado independentemente, mas apenas como um modificador (adição) ao if(). If no exemplo acima, o resultado é solicitado quando o valor retornado é FALSE, else pode ser adicionado como segue: if(Aluno*2&gt;=Jackson^2){ print(&quot;A declaração é verdadeira!&quot;) }else{ print(&quot;A declaração é falsa!&quot;) } ## [1] &quot;A declaração é falsa!&quot; Note que else foi escrito na mesma linha que conclui o if() para informar ao R que o teste condicional continua. Podemos retirar a segunda parte do teste anterior e adicionar uma nova comparação. Aluno2&lt;-7 if(Aluno2&gt;Jackson){ print(&quot;Aluno1 é mais bonito!&quot;) }else if(Aluno2&gt;Aluno){ print(&quot;Aluno2 é mais bonito que Aluno e menos bonito que Jackson.&quot;) } ## [1] &quot;Aluno2 é mais bonito que Aluno e menos bonito que Jackson.&quot; 3.2.2.2 ifelse() A função ifelse() é separada de if() e é formada de uma sintaxe mais simples e concisa. No entanto, ela pode ser usada para gerar o mesmo efeito que nas demonstrações anteriores usando if() com o modificador else. ifelse(Aluno*2&gt;=Jackson^2, &quot;Aluno é mais bonito!&quot;, &quot;Jackson é mais bonito!&quot;) ## [1] &quot;Jackson é mais bonito!&quot; Como mostrado acima, o uso de ifelse() usa a forma: ifelse(teste condicional, resultado se verdadeiro, resultado se falso) Declarações condicionais também podem ser aninhadas dentro uma outra. Adaptando o exemplo com o argumento else um outro teste é executado se o teste inicial é FALSE, onde o secundário é TRUE. ifelse(Aluno*2&gt;=Jackson^2, &quot;Aluno é mais bonito!&quot;, ifelse(Aluno*2&gt;=Jackson^0.5 ,&quot;Agora o Aluno é mais bonito!&quot;, &quot;Aluno continua feio!&quot;)) ## [1] &quot;Agora o Aluno é mais bonito!&quot; Se o teste secundário é ajustado de maneira que os resultados em um teste lógico FALSE, o seguinte resultado é retornado. ifelse(Aluno*2&gt;=Jackson^2, &quot;Aluno é mais bonito!&quot;, ifelse(Aluno*2&gt;=Jackson^3,&quot;Agora o Aluno é mais bonito!&quot;, &quot;Aluno continua feio!&quot;)) ## [1] &quot;Aluno continua feio!&quot; 3.3 Dica de leitura Mello and Peternelli (2013) Peng (2020b) Kabacoff (2015) Venables and Smith (2020) Neth (2021) Yamamoto (2020) Freire (2021b) Spatial Data Science - Indexing Indexing into a data structure r-coder datamentor - R if…else Statement 3.4 Exercícios Crie o vetor p que contenham uma sequência de 200 iniciando em 0 aumentando 0.5. Eleve o vetor p ao cubo criando o vetor o e multiplique por p. Organize p por linhas em uma matriz com 10 colunas . Crie os elementos x = 10 e y = 25. Mostre na tela A declaração é verdadeira sob a condição de x ser menor que y. Mostre 2 maneiras condicionais de executar a declaração na qual mostraria A declaração é correta se x é menor ou igual a y, ou caso contrário mostre A declaração é incorreta se não for o caso. Atribua z = 50 e construa uma função ifelse() que testa se x é maior que y, mostrando true se a condição é encontrada. Aninhe dentro disso uma segunda condição que mostre uma verdadeira, uma falsa ou ambas falsas caso x seja maior que z. Use uma iteração restrita para gerar uma sequência de números de 1 até 20. Use iteração restrita para conduzir o cálculo (i^2)-i, onde i vai de 5 até 10. Use interação não restrita para gerar uma sequência de inteiros de -10 até -20. References "],["acessando-e-criando-funções-importação-e-exportação-dados.html", "Capítulo 4 Acessando e criando Funções, Importação e exportação dados 4.1 Funções 4.2 Pacotes 4.3 Entrando com dados 4.4 Exercícios 4.5 Dica de leitura", " Capítulo 4 Acessando e criando Funções, Importação e exportação dados 4.1 Funções Assista este conteúdo em Cap 3 - Funções no PVANet Embora existam uma grande variedade de funções e pacotes disponíveis e crescendo em número, a grande versatilidade do R nos permite criar comandos/funções personalizadas. No entanto, uma dúvida que por ventura você tenha e não consiga sanar dentro das opções de ajuda do próprio R, buscar em fóruns sobre o assunto pode ser uma saída, pois geralmente a sua dúvida foi a dúvida de alguém antes de você. Vamos inicialmente dar uma olhada nas funções do próprio R. Até aqui vimos algumas funções como: c(), seq(), rep(), print(), is.numeric(), is.integer(), is.double(), is.character(), typeof(), which(), grep() e etc Para entender melhor como uma função funciona ou o que ela faz e permite fazer podemos pedir ajuda escrevendo ?nomedafunção. Por exemplo: ?rnorm #Gera um vetor de números aleatórios normalmente ditribuídos ## starting httpd help server ... done No display de ajuda da função rnorm()observamos como a função deve ser utilizada, quais parâmetros devem ser inseridos. rnorm(n, mean = 0, sd = 1) rnorm(5 ,10 , 8) #Vejam que não estão próximas de zero, mas de dez. ## [1] 22.101881 27.692473 18.294883 8.961472 4.598034 Podemos dar nomes aos parâmetros também, caso não sejam nomeados, os parâmetros seguirão a ordem estabelecida na função original inciada em n seguida de mean e sd. set.seed(1234) rnorm(n=5 ,mean=10 , sd=8) ## [1] 0.343474 12.219434 18.675529 -8.765582 13.432998 set.seed(1234) rnorm(mean=10,n=5, sd=8) # Uma vez nomeados, eles podem ser arranjados da maneira que desejar. ## [1] 0.343474 12.219434 18.675529 -8.765582 13.432998 Quando você executou ?rnorm, você deve ter percebido que existem outro comandos semelhantes: dnorm(x, mean = 0, sd = 1, log = FALSE) pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) dnorm retorna o valor da função de densidade de probabilidade para os parâmetros. fornececidos. dnorm(5, mean = 10, sd = 8) ## [1] 0.04102012 pnorm retorna a integral de -Inf até q de um pdf ( Probability density function) da distribuição normal onde q é o z-score. pnorm(5, mean = 10, sd = 8) ## [1] 0.2659855 qnorm é simplesmente o inverso do cdf ( cumulative distribution function), no qual você pode entender com o inverso de pnorm. qnorm(.2) # Responde como o z-score do vigèsimo elemento de uma distribuiçãop normal. ## [1] -0.8416212 Para mais detalhes sobre estas funções clique aqui. As funções acima e tantas outras estão disponíveis no R desde sua instalação, assim como as funções básicas abaixo. função Descrição abs(x) Valor absoluto sqrt(x) Raiz quadrada ceiling(x) Arredonda para o inteiro acima floor(x) Arredonda para o inteiro abaixo trunc(x) Trunca para um inteiro round(x,digits=n) Arredonda de acordo com número de casas decimais log(x) Logarítimo natural log10(x) Logarítmo decimal exp(x) Exponenciação de base e com expoente x sin(x) Seno em radianos cos(x) Cosseno em radianos tan(x) Tangente em radianos ## [1] 9.99 ## [1] 1.772454 ## [1] 4 ## [1] 3 ## [1] 3 ## [1] 3.14 ## [1] 1.14473 ## [1] 0.4971499 ## [1] 23.14069 ## [1] 1.224606e-16 ## [1] -1 ## [1] -1.224647e-16 Pesquise por asin(), acos(), atan(). Embora seja rico de opções, com funções dos mais variados tipos e aplicações às vezes não encontramos aquelas específicas que precisamos para algo específico. Ou, mesmo que esteja desenvolvendo uma metodologia nova com novos approaches ou um novo pacote você precisará impreterivelmente de criar suas próprias funções. As funções às vezes não são tão simples para uma primeira tentativa de uso ou criação principalmente para aqueles que estão iniciando em R ou qualquer linguagem de programação. Podemos imaginar a função dividida em 3 partes (entrada, processamento e saída) como uma caixa com muito buracos de uma lado ( inputs) e apenas um buraco do outro ( output) e a caixa atua de acordo com nossos comandos. Ou ainda como processamento de frutas para um suco. Estrutura de uma função Estrutura de uma função: * A função recebe um nome que recebe os argumentos e comandos a serem executados. O nome da função será o comando a ser executado sempre que desejado. Após o atribuidor vem o comando function seguindo de (). Dentro de () vem os argumentos (posição ou nomes) que são as variáveis ou outras informações inseridas pelo usuário. Após fechar os parênteses abre-se chaves {} onde entram as equações ou testes a serem executados e as opções de saídas com o comando return quer geralmente encontra-se ao final da função. Não há restrição sobre a estrutura ou tipo de objeto retornado (list, data.frame, matrix, numeric, logical … etc). Após o registro da função no ambiente do R (Veja o global environment), a função fica pronta para uso. minhafunção &lt;- function(arg1, arg2, ... ){ statements return(object) } Vamos criar uma função de divisão. divisao &lt;- function(x, y) { resultado &lt;- x/y print(resultado) } A função se chama divisao. Declare as variáveis x, y entre (); {} guardam os comandos a serem executados; resultado &lt;- x/y e print(resultado) são os comandos a serem executados. ## ## Attaching package: &#39;flow&#39; ## The following object is masked _by_ &#39;.GlobalEnv&#39;: ## ## d divisao(50,25) ## [1] 2 divisao(22,4.4) ## [1] 5 g&lt;-5 x&lt;-10 a&lt;-x divisao(g,a) ## [1] 0.5 divisao(a+g,g) ## [1] 3 Experimentem e vejam o que acontece. divisao(50,) ## Error in divisao(50, ): argumento &quot;y&quot; ausente, sem padrão divisao(50,25,32) ## Error in divisao(50, 25, 32): unused argument (32) divisao(a,m) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 10.000000 2.000000 1.1111111 ## [2,] 5.000000 1.666667 1.0000000 ## [3,] 3.333333 1.428571 0.9090909 ## [4,] 2.500000 1.250000 0.8333333 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 0.7692308 0.5882353 0.4761905 ## [2,] 0.7142857 0.5555556 0.4545455 ## [3,] 0.6666667 0.5263158 0.4347826 ## [4,] 0.6250000 0.5000000 0.4166667 ***Escreva uma função teste chamada multiplicador que multiplica os valores 12.8, 19.2 e pi. _pi_é armazenado internamente pelo R com 6 casas decimais e pode ser chamada escrevendo pi.*** multiplicador &lt;- function(x, y, z) { resultado &lt;- x*y*z print(resultado) } # `print` mostra o resultado de um objeto ou operação multiplicador(12.8, 19.2, pi) ## [1] 772.0778 Escreva uma função teste chamada multiplicador que multiplica os valores um vetor com 50 números por outro de 50 números e armazene o resultado como G sem mostrá-los na tela s&lt;-seq(from= 1,to=10, length.out=50); length(s) ## [1] 50 s ## [1] 1.000000 1.183673 1.367347 1.551020 1.734694 1.918367 2.102041 ## [8] 2.285714 2.469388 2.653061 2.836735 3.020408 3.204082 3.387755 ## [15] 3.571429 3.755102 3.938776 4.122449 4.306122 4.489796 4.673469 ## [22] 4.857143 5.040816 5.224490 5.408163 5.591837 5.775510 5.959184 ## [29] 6.142857 6.326531 6.510204 6.693878 6.877551 7.061224 7.244898 ## [36] 7.428571 7.612245 7.795918 7.979592 8.163265 8.346939 8.530612 ## [43] 8.714286 8.897959 9.081633 9.265306 9.448980 9.632653 9.816327 ## [50] 10.000000 d&lt;-seq(from=1,to=10,length.out = length(s)) d ## [1] 1.000000 1.183673 1.367347 1.551020 1.734694 1.918367 2.102041 ## [8] 2.285714 2.469388 2.653061 2.836735 3.020408 3.204082 3.387755 ## [15] 3.571429 3.755102 3.938776 4.122449 4.306122 4.489796 4.673469 ## [22] 4.857143 5.040816 5.224490 5.408163 5.591837 5.775510 5.959184 ## [29] 6.142857 6.326531 6.510204 6.693878 6.877551 7.061224 7.244898 ## [36] 7.428571 7.612245 7.795918 7.979592 8.163265 8.346939 8.530612 ## [43] 8.714286 8.897959 9.081633 9.265306 9.448980 9.632653 9.816327 ## [50] 10.000000 multiplicador &lt;- function(x, y){ resultado &lt;- x*y assign(&quot;resultado&quot;, resultado, envir=globalenv()) } # `assign` atribui os valores de uma operação a um objeto multiplicador(s,d) resultado ## [1] 1.000000 1.401083 1.869638 2.405664 3.009163 3.680133 ## [7] 4.418576 5.224490 6.097876 7.038734 8.047064 9.122865 ## [13] 10.266139 11.476885 12.755102 14.100791 15.513953 16.994586 ## [19] 18.542691 20.158267 21.841316 23.591837 25.409829 27.295294 ## [25] 29.248230 31.268638 33.356518 35.511870 37.734694 40.024990 ## [31] 42.382757 44.807997 47.300708 49.860891 52.488546 55.183673 ## [37] 57.946272 60.776343 63.673886 66.638900 69.671387 72.771345 ## [43] 75.938776 79.173678 82.476052 85.845898 89.283215 92.788005 ## [49] 96.360267 100.000000 media &lt;- function( x = c( 1, 1, 1, 1)){ #Neste caso utilizamos valores default que permitem testes caso algo saia errado #Calcula média do inpout x out &lt;- sum(x)/length(x) return( out) # `return` devolve/retorna/mostra os resultado de uma operação ou objeto } minha.media &lt;- media( x = 1: 100) # print result print( my.mean) print(minha.media) ## [1] 50.5 As funções também permitem maior interação com usuário para a tomada de uma decisão por exemplo. mensagem &lt;- function( arg1=readline(prompt=&quot;escreva sua mensagem: &quot;), arg2 = readline(prompt=&quot;De novo: &quot;)){ msg1 &lt;- paste0(arg1) msg2 &lt;- paste0(arg2) cat( msg1, msg2) } mensagem() ## escreva sua mensagem: ## De novo: ## 4.2 Pacotes Assista este conteúdo em Cap 3 - Pacotes no PVANet 4.2.1 O que são? De onde vem? Para onde vão? Do que se alimentam? Quando iniciamos o R pouco mais de 2000 funções e outros objetos na memória estão prontos para uso. No R temos os pacotes que são feitos para cálculos estatísticos dos mais variados, pacotes para fazer gráficos, pacotes aplicados à um determinado tipo de dado ou subdivisão da ciência e etc… Eles basicamente permitem vocês expandirem a funcionalidade do R para programação, ao invés de escrever dezenas de linhas de códigos, esses códigos são preparados, empacotados e tudo que você precisa fazer e usá-lo. Os Packages são coleções de funções, dados, e códigos compilados num formato bem definido. O diretório onde os pacotes estão armazenados são chamados library. A função .libPaths() onde sua biblioteca está alojada. .libPaths() ## [1] &quot;C:/Users/jacks/AppData/Local/R/win-library/4.2&quot; ## [2] &quot;C:/Program Files/R/R-4.2.3/library&quot; Milhares de outras funções, para as mais diversas tarefas, podem ser adicionadas por meio de pacotes (packages) disponíveis livremente na internet. No entanto, a principal fonte de pacotes para o R é o CRAN, mas também temos r-forge, github e outras fontes pela internet. CRAN now has 10,000 R packages. Here’s how to find the ones you need. !!!!!!!!!! Não é porque um pacote está no CRAN que ele foi testado e funciona perfeitamente!!!!!!!!! lista de pacotes no CRAN Para instalar um novo pacote, utilize a função install.packages(\"nome do pacote\") ou Tools-&gt;Install Packages-&gt;Install from (Repository CRAN) -&gt; Packages (escreva o nome do pacote). Para carregar na memória um pacote já instalado, library(nome do pacote) ou require(nome do pacote). Ao abrir lista de pacotes vemos quais estão disponíveis. Os que estão marcados estão ativados e disponíveis para uso. Aqueles que não estão marcados podem ser ativados e suas funções utilizadas. lista de pacotes instalados Vamos deletar o pacote ggplot2, basta clicar no x no lado direito. Agora vamos reinstalar pela barra de ferramentas. Mas o que CRAN quer dizer? É o local onde os pacotes são armazenados. R é um open source software então se você quiser, pode criar um pacote ar mazená-lo no CRAN. #install.packages(&quot;analogue&quot;) library(analogue) ## Carregando pacotes exigidos: vegan ## Carregando pacotes exigidos: permute ## Carregando pacotes exigidos: lattice ## This is vegan 2.6-4 ## analogue version 0.17-6 Visite Analogue e explore o que há disponível para o pacote analogue. Use a aba packages para explorar suas funcionalidades Muitas vezes os pacotes disponíveis no CRAN não estão UpToDate por isso talvez seja mais interessante isntalar os pacotes diretamente do github. Veja o pacote packman e vamos instalá-lo pelo github. Mas antes vamos instalar o pacote devtools que , entre outras coisas, nos permite “buscar” os pacotes do github. #install.packages(&quot;devtools&quot;) devtools::install_github(&quot;trinker/pacman&quot;) ## Skipping install of &#39;pacman&#39; from a github remote, the SHA1 (ace09364) has not changed since last install. ## Use `force = TRUE` to force installation Ao utilizar o software R e um pacote na execução de seu trabalho você deve citá-los. citation () # citação do software R ## ## To cite R in publications use: ## ## R Core Team (2023). R: A language and environment for statistical ## computing. R Foundation for Statistical Computing, Vienna, Austria. ## URL https://www.R-project.org/. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {R: A Language and Environment for Statistical Computing}, ## author = {{R Core Team}}, ## organization = {R Foundation for Statistical Computing}, ## address = {Vienna, Austria}, ## year = {2023}, ## url = {https://www.R-project.org/}, ## } ## ## We have invested a lot of time and effort in creating R, please cite it ## when using it for data analysis. See also &#39;citation(&quot;pkgname&quot;)&#39; for ## citing R packages. citation(package = &quot;analogue&quot;) # citação do pacote Analogue ## ## To cite use of &#39;analogue&#39; in publications use: ## ## Simpson, G.L. and Oksanen, J. ( 2021 ). analogue: Analogue matching ## and Modern Analogue Technique transfer function models. (R package ## version 0.17-6 ). (https://cran.r-project.org/package=analogue). ## ## Simpson, G.L. (2007). Analogue Methods in Palaeoecology: Using the ## analogue Package Journal of Statistical Software, 22(2), 1--29 ## ## To see these entries in BibTeX format, use &#39;print(&lt;citation&gt;, ## bibtex=TRUE)&#39;, &#39;toBibtex(.)&#39;, or set ## &#39;options(citation.bibtex.max=999)&#39;. Aqui listo os pacotes carregados agora em meu R. (.packages()) ## [1] &quot;analogue&quot; &quot;vegan&quot; &quot;lattice&quot; &quot;permute&quot; &quot;flow&quot; &quot;purrr&quot; ## [7] &quot;magrittr&quot; &quot;ggplot2&quot; &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; ## [13] &quot;datasets&quot; &quot;methods&quot; &quot;base&quot; Aqui listo os pacotes instalados em meu R. meus.pacotes &lt;- library()$results[,1] meus.pacotes ## [1] &quot;abind&quot; &quot;ade4&quot; &quot;AGD&quot; ## [4] &quot;alphavantager&quot; &quot;ambient&quot; &quot;Amelia&quot; ## [7] &quot;AmesHousing&quot; &quot;analogue&quot; &quot;anytime&quot; ## [10] &quot;ape&quot; &quot;arm&quot; &quot;ash&quot; ## [13] &quot;askpass&quot; &quot;aspace&quot; &quot;assertthat&quot; ## [16] &quot;audio&quot; &quot;automap&quot; &quot;babynames&quot; ## [19] &quot;backports&quot; &quot;base64enc&quot; &quot;beepr&quot; ## [22] &quot;bfast&quot; &quot;bfastSpatial&quot; &quot;BH&quot; ## [25] &quot;bigleaf&quot; &quot;bit&quot; &quot;bit64&quot; ## [28] &quot;bitops&quot; &quot;blob&quot; &quot;bookdown&quot; ## [31] &quot;brew&quot; &quot;brglm&quot; &quot;brio&quot; ## [34] &quot;broom&quot; &quot;BSDA&quot; &quot;bslib&quot; ## [37] &quot;cachem&quot; &quot;CALIBERrfimpute&quot; &quot;callr&quot; ## [40] &quot;car&quot; &quot;carData&quot; &quot;caret&quot; ## [43] &quot;caTools&quot; &quot;cellranger&quot; &quot;checkmate&quot; ## [46] &quot;classInt&quot; &quot;cli&quot; &quot;climateStability&quot; ## [49] &quot;climdex.pcic&quot; &quot;climdex.pcic.ncdf&quot; &quot;clipr&quot; ## [52] &quot;clock&quot; &quot;clue&quot; &quot;cluster&quot; ## [55] &quot;clv&quot; &quot;coda&quot; &quot;colorspace&quot; ## [58] &quot;combinat&quot; &quot;commonmark&quot; &quot;conditionz&quot; ## [61] &quot;conflicted&quot; &quot;contfrac&quot; &quot;coro&quot; ## [64] &quot;corrplot&quot; &quot;cowplot&quot; &quot;cpp11&quot; ## [67] &quot;crayon&quot; &quot;credentials&quot; &quot;crosstalk&quot; ## [70] &quot;crsmeta&quot; &quot;crul&quot; &quot;Cubist&quot; ## [73] &quot;curl&quot; &quot;dados&quot; &quot;data.table&quot; ## [76] &quot;datawizard&quot; &quot;DBI&quot; &quot;dbplyr&quot; ## [79] &quot;decido&quot; &quot;deepnet&quot; &quot;deldir&quot; ## [82] &quot;dendextend&quot; &quot;DEoptimR&quot; &quot;desc&quot; ## [85] &quot;deSolve&quot; &quot;devEMF&quot; &quot;devtools&quot; ## [88] &quot;diagram&quot; &quot;dials&quot; &quot;DiceDesign&quot; ## [91] &quot;dichromat&quot; &quot;diffobj&quot; &quot;digest&quot; ## [94] &quot;dismo&quot; &quot;distributional&quot; &quot;doParallel&quot; ## [97] &quot;doRNG&quot; &quot;doSNOW&quot; &quot;dotCall64&quot; ## [100] &quot;downlit&quot; &quot;downloader&quot; &quot;dplyr&quot; ## [103] &quot;DT&quot; &quot;dtplyr&quot; &quot;dtw&quot; ## [106] &quot;DynACof&quot; &quot;e1071&quot; &quot;earth&quot; ## [109] &quot;easyGgplot2&quot; &quot;editData&quot; &quot;elevatr&quot; ## [112] &quot;ellipse&quot; &quot;ellipsis&quot; &quot;elliptic&quot; ## [115] &quot;emmeans&quot; &quot;ENMeval&quot; &quot;ENMTools&quot; ## [118] &quot;estimability&quot; &quot;evaluate&quot; &quot;evtree&quot; ## [121] &quot;exactextractr&quot; &quot;expm&quot; &quot;extraDistr&quot; ## [124] &quot;fable&quot; &quot;fabletools&quot; &quot;factoextra&quot; ## [127] &quot;FactoMineR&quot; &quot;fansi&quot; &quot;farver&quot; ## [130] &quot;fastmap&quot; &quot;fBasics&quot; &quot;feasts&quot; ## [133] &quot;fields&quot; &quot;flashClust&quot; &quot;flextable&quot; ## [136] &quot;flow&quot; &quot;flowr&quot; &quot;FNN&quot; ## [139] &quot;fontawesome&quot; &quot;fontBitstreamVera&quot; &quot;fontLiberation&quot; ## [142] &quot;fontquiver&quot; &quot;forcats&quot; &quot;foreach&quot; ## [145] &quot;forecast&quot; &quot;forecastHybrid&quot; &quot;Formula&quot; ## [148] &quot;fracdiff&quot; &quot;frbs&quot; &quot;fs&quot; ## [151] &quot;fueleconomy&quot; &quot;functional&quot; &quot;furrr&quot; ## [154] &quot;future&quot; &quot;future.apply&quot; &quot;gamlss&quot; ## [157] &quot;gamlss.data&quot; &quot;gamlss.dist&quot; &quot;gapminder&quot; ## [160] &quot;gargle&quot; &quot;gbm&quot; &quot;GCD&quot; ## [163] &quot;gclus&quot; &quot;gdalUtils&quot; &quot;gdtools&quot; ## [166] &quot;generics&quot; &quot;geobr&quot; &quot;geojsonsf&quot; ## [169] &quot;geometries&quot; &quot;geometry&quot; &quot;gert&quot; ## [172] &quot;gfonts&quot; &quot;ggbiplot&quot; &quot;ggforce&quot; ## [175] &quot;ggformula&quot; &quot;ggmap&quot; &quot;ggOceanMaps&quot; ## [178] &quot;ggOceanMapsData&quot; &quot;ggplot2&quot; &quot;ggpubr&quot; ## [181] &quot;ggrepel&quot; &quot;ggridges&quot; &quot;ggsci&quot; ## [184] &quot;ggsignif&quot; &quot;ggspatial&quot; &quot;ggstance&quot; ## [187] &quot;gh&quot; &quot;GISTools&quot; &quot;git2r&quot; ## [190] &quot;gitcreds&quot; &quot;glmnet&quot; &quot;globals&quot; ## [193] &quot;glue&quot; &quot;goftest&quot; &quot;googledrive&quot; ## [196] &quot;googlesheets4&quot; &quot;gower&quot; &quot;GPfit&quot; ## [199] &quot;gridBase&quot; &quot;gridExtra&quot; &quot;gss&quot; ## [202] &quot;gstat&quot; &quot;gtable&quot; &quot;GWmodel&quot; ## [205] &quot;h2o&quot; &quot;hardhat&quot; &quot;haven&quot; ## [208] &quot;here&quot; &quot;hexbin&quot; &quot;highr&quot; ## [211] &quot;HistogramTools&quot; &quot;Hmisc&quot; &quot;hms&quot; ## [214] &quot;htmlTable&quot; &quot;htmltools&quot; &quot;htmlwidgets&quot; ## [217] &quot;hts&quot; &quot;httpcode&quot; &quot;httpuv&quot; ## [220] &quot;httr&quot; &quot;httr2&quot; &quot;hydroGOF&quot; ## [223] &quot;hydroTSM&quot; &quot;hypergeo&quot; &quot;ids&quot; ## [226] &quot;igraph&quot; &quot;imputeMissings&quot; &quot;infer&quot; ## [229] &quot;ini&quot; &quot;insight&quot; &quot;installr&quot; ## [232] &quot;interp&quot; &quot;intervals&quot; &quot;inum&quot; ## [235] &quot;ipred&quot; &quot;isoband&quot; &quot;iterators&quot; ## [238] &quot;itertools&quot; &quot;janitor&quot; &quot;jpeg&quot; ## [241] &quot;jquerylib&quot; &quot;jsonify&quot; &quot;jsonlite&quot; ## [244] &quot;JuliaCall&quot; &quot;kableExtra&quot; &quot;Kendall&quot; ## [247] &quot;kernlab&quot; &quot;kknn&quot; &quot;knitr&quot; ## [250] &quot;KRLS&quot; &quot;labdsv&quot; &quot;labeling&quot; ## [253] &quot;labelled&quot; &quot;laeken&quot; &quot;Lahman&quot; ## [256] &quot;later&quot; &quot;latticeExtra&quot; &quot;lava&quot; ## [259] &quot;lavaan&quot; &quot;lazyeval&quot; &quot;leafem&quot; ## [262] &quot;leaflet&quot; &quot;leaflet.providers&quot; &quot;leafsync&quot; ## [265] &quot;leaps&quot; &quot;LearnBayes&quot; &quot;lhs&quot; ## [268] &quot;libcoin&quot; &quot;lifecycle&quot; &quot;linprog&quot; ## [271] &quot;listenv&quot; &quot;lme4&quot; &quot;lmom&quot; ## [274] &quot;lmomco&quot; &quot;Lmoments&quot; &quot;lmtest&quot; ## [277] &quot;locfit&quot; &quot;locpol&quot; &quot;longitudinalData&quot; ## [280] &quot;lpSolve&quot; &quot;lsr&quot; &quot;lubridate&quot; ## [283] &quot;lwgeom&quot; &quot;magic&quot; &quot;magrittr&quot; ## [286] &quot;mapproj&quot; &quot;maps&quot; &quot;maptools&quot; ## [289] &quot;markdown&quot; &quot;Matrix&quot; &quot;MatrixModels&quot; ## [292] &quot;matrixStats&quot; &quot;maxnet&quot; &quot;memoise&quot; ## [295] &quot;Metrics&quot; &quot;mi&quot; &quot;mice&quot; ## [298] &quot;mime&quot; &quot;miniUI&quot; &quot;minqa&quot; ## [301] &quot;misc3d&quot; &quot;missForest&quot; &quot;mlbench&quot; ## [304] &quot;mnormt&quot; &quot;modeest&quot; &quot;modeldata&quot; ## [307] &quot;modelenv&quot; &quot;ModelMetrics&quot; &quot;modelr&quot; ## [310] &quot;monmlp&quot; &quot;moonBook&quot; &quot;mosaic&quot; ## [313] &quot;mosaicCore&quot; &quot;mosaicData&quot; &quot;multcompView&quot; ## [316] &quot;munsell&quot; &quot;mvoutlier&quot; &quot;mvpart&quot; ## [319] &quot;MVPARTwrap&quot; &quot;mvtnorm&quot; &quot;nabor&quot; ## [322] &quot;nasaweather&quot; &quot;NbClust&quot; &quot;ncdf4&quot; ## [325] &quot;ncdf4.helpers&quot; &quot;NeuralNetTools&quot; &quot;nloptr&quot; ## [328] &quot;nngeo&quot; &quot;nomnoml&quot; &quot;nortest&quot; ## [331] &quot;numDeriv&quot; &quot;nycflights13&quot; &quot;oai&quot; ## [334] &quot;OCNet&quot; &quot;officer&quot; &quot;openssl&quot; ## [337] &quot;openxlsx&quot; &quot;optimx&quot; &quot;Orcs&quot; ## [340] &quot;packrat&quot; &quot;pacman&quot; &quot;padr&quot; ## [343] &quot;paleofire&quot; &quot;palmerpenguins&quot; &quot;palr&quot; ## [346] &quot;parallelly&quot; &quot;params&quot; &quot;parsnip&quot; ## [349] &quot;partykit&quot; &quot;patchwork&quot; &quot;pbivnorm&quot; ## [352] &quot;pbkrtest&quot; &quot;PCICt&quot; &quot;pdc&quot; ## [355] &quot;PerformanceAnalytics&quot; &quot;permute&quot; &quot;pillar&quot; ## [358] &quot;pixarfilms&quot; &quot;pixmap&quot; &quot;pkgbuild&quot; ## [361] &quot;pkgconfig&quot; &quot;pkgdown&quot; &quot;pkgload&quot; ## [364] &quot;plogr&quot; &quot;plotly&quot; &quot;plotmo&quot; ## [367] &quot;plotrix&quot; &quot;plyr&quot; &quot;png&quot; ## [370] &quot;polyclip&quot; &quot;polynom&quot; &quot;praise&quot; ## [373] &quot;prettymapr&quot; &quot;prettyunits&quot; &quot;princurve&quot; ## [376] &quot;pROC&quot; &quot;processx&quot; &quot;prodlim&quot; ## [379] &quot;profileModel&quot; &quot;profvis&quot; &quot;progress&quot; ## [382] &quot;progressr&quot; &quot;PROJ&quot; &quot;proj4&quot; ## [385] &quot;promises&quot; &quot;proxy&quot; &quot;PRROC&quot; ## [388] &quot;ps&quot; &quot;psych&quot; &quot;purrr&quot; ## [391] &quot;qpdf&quot; &quot;quadmesh&quot; &quot;quadprog&quot; ## [394] &quot;Quandl&quot; &quot;quantmod&quot; &quot;quantreg&quot; ## [397] &quot;quarto&quot; &quot;R.cache&quot; &quot;R.methodsS3&quot; ## [400] &quot;R.oo&quot; &quot;R.utils&quot; &quot;R6&quot; ## [403] &quot;radix&quot; &quot;ragg&quot; &quot;randomForest&quot; ## [406] &quot;rangeModelMetadata&quot; &quot;ranger&quot; &quot;rapidjsonr&quot; ## [409] &quot;rappdirs&quot; &quot;raster&quot; &quot;rasterVis&quot; ## [412] &quot;rayimage&quot; &quot;rayrender&quot; &quot;rayshader&quot; ## [415] &quot;rayvertex&quot; &quot;rbibutils&quot; &quot;rbison&quot; ## [418] &quot;rcmdcheck&quot; &quot;RColorBrewer&quot; &quot;Rcpp&quot; ## [421] &quot;RcppArmadillo&quot; &quot;RcppEigen&quot; &quot;RcppProgress&quot; ## [424] &quot;RcppRoll&quot; &quot;RcppThread&quot; &quot;RcppTOML&quot; ## [427] &quot;RCurl&quot; &quot;Rdpack&quot; &quot;readr&quot; ## [430] &quot;readxl&quot; &quot;rebird&quot; &quot;recipes&quot; ## [433] &quot;rematch&quot; &quot;rematch2&quot; &quot;remotes&quot; ## [436] &quot;repr&quot; &quot;reprex&quot; &quot;reproj&quot; ## [439] &quot;reshape&quot; &quot;reshape2&quot; &quot;rgbif&quot; ## [442] &quot;rgdal&quot; &quot;rgeos&quot; &quot;rgl&quot; ## [445] &quot;RgoogleMaps&quot; &quot;rgrass&quot; &quot;rgrass7&quot; ## [448] &quot;ridigbio&quot; &quot;riingo&quot; &quot;rio&quot; ## [451] &quot;rioja&quot; &quot;rivnet&quot; &quot;rJava&quot; ## [454] &quot;rjson&quot; &quot;rkt&quot; &quot;rlang&quot; ## [457] &quot;rmarkdown&quot; &quot;rmutil&quot; &quot;rnaturalearth&quot; ## [460] &quot;rnaturalearthdata&quot; &quot;rnaturalearthhires&quot; &quot;rngtools&quot; ## [463] &quot;robustbase&quot; &quot;rosm&quot; &quot;roxygen2&quot; ## [466] &quot;rpart.plot&quot; &quot;rprojroot&quot; &quot;rrtable&quot; ## [469] &quot;rsample&quot; &quot;rsconnect&quot; &quot;RSQLite&quot; ## [472] &quot;rstatix&quot; &quot;RStoolbox&quot; &quot;rstudioapi&quot; ## [475] &quot;rticles&quot; &quot;Rtsne&quot; &quot;rversions&quot; ## [478] &quot;rvertnet&quot; &quot;rvest&quot; &quot;rvg&quot; ## [481] &quot;rworldmap&quot; &quot;s2&quot; &quot;sandwich&quot; ## [484] &quot;sass&quot; &quot;scales&quot; &quot;scatterplot3d&quot; ## [487] &quot;sdm&quot; &quot;sdmpredictors&quot; &quot;selectr&quot; ## [490] &quot;servr&quot; &quot;sessioninfo&quot; &quot;sf&quot; ## [493] &quot;sfheaders&quot; &quot;sftime&quot; &quot;sgeostat&quot; ## [496] &quot;shape&quot; &quot;shapefiles&quot; &quot;shiny&quot; ## [499] &quot;shinyBS&quot; &quot;shinydashboard&quot; &quot;shinyjs&quot; ## [502] &quot;shinythemes&quot; &quot;shinyWidgets&quot; &quot;sjlabelled&quot; ## [505] &quot;sjmisc&quot; &quot;skimr&quot; &quot;slickR&quot; ## [508] &quot;slider&quot; &quot;slippymath&quot; &quot;smoothr&quot; ## [511] &quot;snakecase&quot; &quot;snow&quot; &quot;solartime&quot; ## [514] &quot;sourcetools&quot; &quot;sp&quot; &quot;spacefillr&quot; ## [517] &quot;spacetime&quot; &quot;spam&quot; &quot;SparseM&quot; ## [520] &quot;spatialreg&quot; &quot;spatstat&quot; &quot;spatstat.core&quot; ## [523] &quot;spatstat.data&quot; &quot;spatstat.explore&quot; &quot;spatstat.geom&quot; ## [526] &quot;spatstat.linnet&quot; &quot;spatstat.model&quot; &quot;spatstat.random&quot; ## [529] &quot;spatstat.sparse&quot; &quot;spatstat.utils&quot; &quot;spData&quot; ## [532] &quot;spdep&quot; &quot;SPEI&quot; &quot;spex&quot; ## [535] &quot;splancs&quot; &quot;spocc&quot; &quot;spThin&quot; ## [538] &quot;SQUAREM&quot; &quot;SSN&quot; &quot;stable&quot; ## [541] &quot;stabledist&quot; &quot;stars&quot; &quot;statip&quot; ## [544] &quot;stringi&quot; &quot;stringr&quot; &quot;strucchangeRcpp&quot; ## [547] &quot;styler&quot; &quot;svglite&quot; &quot;sys&quot; ## [550] &quot;sysfonts&quot; &quot;systemfonts&quot; &quot;tcltk2&quot; ## [553] &quot;TeachingDemos&quot; &quot;tensor&quot; &quot;terra&quot; ## [556] &quot;terrainmeshr&quot; &quot;testthat&quot; &quot;textshaping&quot; ## [559] &quot;thematic&quot; &quot;thief&quot; &quot;tibble&quot; ## [562] &quot;tidymodels&quot; &quot;tidyquant&quot; &quot;tidyr&quot; ## [565] &quot;tidyselect&quot; &quot;tidyverse&quot; &quot;timechange&quot; ## [568] &quot;timeDate&quot; &quot;timeSeries&quot; &quot;timetk&quot; ## [571] &quot;tinytex&quot; &quot;TLMoments&quot; &quot;tmap&quot; ## [574] &quot;tmaptools&quot; &quot;torch&quot; &quot;traudem&quot; ## [577] &quot;trend&quot; &quot;triebeard&quot; &quot;TSclust&quot; ## [580] &quot;TSdist&quot; &quot;tseries&quot; &quot;tsfeatures&quot; ## [583] &quot;tsibble&quot; &quot;tsibbledata&quot; &quot;TSstudio&quot; ## [586] &quot;TTR&quot; &quot;tune&quot; &quot;tweenr&quot; ## [589] &quot;tzdb&quot; &quot;udunits2&quot; &quot;unikn&quot; ## [592] &quot;units&quot; &quot;urca&quot; &quot;urlchecker&quot; ## [595] &quot;urltools&quot; &quot;usdm&quot; &quot;usethis&quot; ## [598] &quot;utf8&quot; &quot;uuid&quot; &quot;vcd&quot; ## [601] &quot;vctrs&quot; &quot;vegan&quot; &quot;VIM&quot; ## [604] &quot;vip&quot; &quot;viridis&quot; &quot;viridisLite&quot; ## [607] &quot;visdat&quot; &quot;vroom&quot; &quot;waldo&quot; ## [610] &quot;warp&quot; &quot;weathermetrics&quot; &quot;webr&quot; ## [613] &quot;webshot&quot; &quot;wellknown&quot; &quot;wesanderson&quot; ## [616] &quot;whisker&quot; &quot;widgetframe&quot; &quot;withr&quot; ## [619] &quot;wk&quot; &quot;woeBinning&quot; &quot;workflows&quot; ## [622] &quot;workflowsets&quot; &quot;xfun&quot; &quot;xgboost&quot; ## [625] &quot;xlsx&quot; &quot;xlsxjars&quot; &quot;XML&quot; ## [628] &quot;xml2&quot; &quot;xopen&quot; &quot;xtable&quot; ## [631] &quot;xts&quot; &quot;yaml&quot; &quot;yardstick&quot; ## [634] &quot;zeallot&quot; &quot;zip&quot; &quot;zoo&quot; ## [637] &quot;ztable&quot; &quot;zyp&quot; &quot;base&quot; ## [640] &quot;boot&quot; &quot;class&quot; &quot;cluster&quot; ## [643] &quot;codetools&quot; &quot;compiler&quot; &quot;datasets&quot; ## [646] &quot;foreign&quot; &quot;graphics&quot; &quot;grDevices&quot; ## [649] &quot;grid&quot; &quot;KernSmooth&quot; &quot;lattice&quot; ## [652] &quot;MASS&quot; &quot;Matrix&quot; &quot;methods&quot; ## [655] &quot;mgcv&quot; &quot;nlme&quot; &quot;nnet&quot; ## [658] &quot;parallel&quot; &quot;rpart&quot; &quot;spatial&quot; ## [661] &quot;splines&quot; &quot;stats&quot; &quot;stats4&quot; ## [664] &quot;survival&quot; &quot;tcltk&quot; &quot;tools&quot; ## [667] &quot;translations&quot; &quot;utils&quot; Ou poderia simplesmente digitar library(). library() 4.3 Entrando com dados Assista este conteúdo em Cap 3 - Entrando com dados partes 1 e 2 no PVANet Agora que dominamos 100% as estruturas e tratamento de objetos podemos partir para importação de dados das mais variadas fontes. Até agora nós basicamente trabalhamos com dados “café com leite”. Criamos uma tabelinha aqui, uma matrizinha acolá um vetor e por aí vai. Sinto muito em informá-los, mas o mundo é bem mais complexo e cruel. “O mundo não é um mar de rosas. É um lugar sujo, um lugar cruel, que não quer saber o quanto você é durão. Vai botar você de joelhos e você vai ficar de joelhos para sempre se você deixar. Você, eu, ninguém vai bater tão forte como a vida, mas não se trata de bater forte. Se trata de quanto você aguenta apanhar e seguir em frente, o quanto você é capaz de aguentar e continuar tentando. É assim que se consegue vencer.Agora se você sabe do teu valor, então vá atrás do que você merece, mas tem que estar preparado para apanhar. E nada de apontar dedos, dizer que você não consegue por causa dele ou dela, ou de quem quer que seja. Só covardes fazem isso e você não é covarde, você é melhor que isso.” Balboa, Rocky | Os dados no R podem ser importados por diferentes meios (teclado, text file, outros softwares estatísticos, planilhas e etc). Fonte: Kabacoff (2015) 4.3.1 edit() A forma mais simples de inserção de dados é através do teclado. No caso a seguir, o comando Matrícula=numeric(0) cria uma variável de um mode()específico, mas sem dados. O comando edit(), por sua vez, e como nome sugere, permite editar um banco de dados. Um popup abrirá na sua tela que permitirá a sua edição. Após o uso basta fechar que as edições feitas serão salvas. comando edit() Alunos.Eng792 &lt;- data.frame(Nome=character(0),Matrícula=numeric(0), Curço=character(0),Nível.de.R=numeric(0),Nível.de.Pós=character(0)) Alunos.Eng792 ## [1] Nome Matrícula Curço Nível.de.R Nível.de.Pós ## &lt;0 linhas&gt; (ou row.names de comprimento 0) Alunos.Eng792 &lt;- edit(Alunos.Eng792) Alunos.Eng792 ## [1] Nome Matrícula Curço Nível.de.R Nível.de.Pós ## &lt;0 linhas&gt; (ou row.names de comprimento 0) 4.3.2 built-in No R também temos os dados buit-in que são dados que já vem “dentro” do R ou pacotes que permite a execução dos exemplos das funções naturais do R e aquelas instaladas por meio dos pacotes. Temos vários dados built-in no R como ìris, mtcars, anscombe, USArrests, USAccDeaths,AirPassengers e etc. Vamos dar uma olha no USArrests que contém estatísticas de presos por diferentes crimes em EUA em taxas de 100.000. Presidiarios.USA&lt;-(USArrests) Presidiarios.USA ## Murder Assault UrbanPop Rape ## Alabama 13.2 236 58 21.2 ## Alaska 10.0 263 48 44.5 ## Arizona 8.1 294 80 31.0 ## Arkansas 8.8 190 50 19.5 ## California 9.0 276 91 40.6 ## Colorado 7.9 204 78 38.7 ## Connecticut 3.3 110 77 11.1 ## Delaware 5.9 238 72 15.8 ## Florida 15.4 335 80 31.9 ## Georgia 17.4 211 60 25.8 ## Hawaii 5.3 46 83 20.2 ## Idaho 2.6 120 54 14.2 ## Illinois 10.4 249 83 24.0 ## Indiana 7.2 113 65 21.0 ## Iowa 2.2 56 57 11.3 ## Kansas 6.0 115 66 18.0 ## Kentucky 9.7 109 52 16.3 ## Louisiana 15.4 249 66 22.2 ## Maine 2.1 83 51 7.8 ## Maryland 11.3 300 67 27.8 ## Massachusetts 4.4 149 85 16.3 ## Michigan 12.1 255 74 35.1 ## Minnesota 2.7 72 66 14.9 ## Mississippi 16.1 259 44 17.1 ## Missouri 9.0 178 70 28.2 ## Montana 6.0 109 53 16.4 ## Nebraska 4.3 102 62 16.5 ## Nevada 12.2 252 81 46.0 ## New Hampshire 2.1 57 56 9.5 ## New Jersey 7.4 159 89 18.8 ## New Mexico 11.4 285 70 32.1 ## New York 11.1 254 86 26.1 ## North Carolina 13.0 337 45 16.1 ## North Dakota 0.8 45 44 7.3 ## Ohio 7.3 120 75 21.4 ## Oklahoma 6.6 151 68 20.0 ## Oregon 4.9 159 67 29.3 ## Pennsylvania 6.3 106 72 14.9 ## Rhode Island 3.4 174 87 8.3 ## South Carolina 14.4 279 48 22.5 ## South Dakota 3.8 86 45 12.8 ## Tennessee 13.2 188 59 26.9 ## Texas 12.7 201 80 25.5 ## Utah 3.2 120 80 22.9 ## Vermont 2.2 48 32 11.2 ## Virginia 8.5 156 63 20.7 ## Washington 4.0 145 73 26.2 ## West Virginia 5.7 81 39 9.3 ## Wisconsin 2.6 53 66 10.8 ## Wyoming 6.8 161 60 15.6 4.3.3 scan() Uma outra forma de entrada manual se dá através dom comando scan(). Neste formato de entrada de dados podemos digitar informação por informação ou copiar de uma fonte e colá-la. Tudo isso feito no console e em formato numérico. Exemplo com digitação. teste1 &lt;-scan() # Digite 1, 2, 4, 5, 6, 7, 8 teste1 Exemplo com copia e cola. seq(30,38) teste2 &lt;-scan() teste2 4.3.4 Lendo arquivos de texto (.txt) No dia a dia esbarramos em dados que estão disponíveis em formato de texto. Geralmente este dados estão organizados em linhas e colunas onde cada linha representa uma observação e cada coluna uma variável. Para fazer leitura de dados em formato de texto (.txt) podemos utilizar o comando read.table() que lê o arquivo em formato de tabela e armazena em formato de data.frame. A sintaxe do comando é: meu.df &lt;- read.table(file, options) Existem muitas opções ( options) disponíveis, mas podemos destacar algumas mais utilizadas header, sep, row.names, col.names, skip. Para saber quais são as options e o que cada uma delas faz você pode acessar através de ?data.datble. No caso abaixo estamos utilizando sep=\",\", header=T e skip=3. Baixe os dados aqui Cap_3_Notas_ENG792.txt no PVANet notas&lt;-read.table(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Notas_ENG792.txt&quot;, sep=&quot;,&quot;, header = T, skip=3) notas ## Nome Nota.1 Nota.2 Nota.3 Nota.4 ## 1 A 10.9 60.9 53.6 12.0 ## 2 B 71.3 9.9 13.9 47.0 ## 3 C 65.9 0.3 28.9 55.0 ## 4 D 3.6 70.0 37.9 75.3 ## 5 E 70.9 81.9 43.9 8.6 ## 6 F 76.9 53.0 29.9 38.6 ## 7 G 73.6 2.3 23.0 37.3 ## 8 H 2.0 88.0 10.3 28.3 ## 9 I 25.3 11.9 12.3 26.3 ## 10 J 7.0 19.3 82.9 46.3 ## 11 K 52.0 41.0 70.3 31.6 ## 12 L 27.3 74.0 47.6 18.9 ## 13 M 87.9 75.9 17.9 80.6 ## 14 N 76.0 47.9 2.0 19.6 ## 15 O 55.0 60.6 51.9 24.0 ## 16 P 76.6 47.9 90.3 55.6 ## 17 Q 10.3 55.9 18.0 86.3 ## 18 R 17.0 0.9 43.3 14.6 ## 19 S 38.6 22.6 23.6 6.6 ## 20 T 69.0 31.9 75.3 90.6 ## 21 U 26.9 3.6 65.3 48.6 ## 22 X 56.6 32.0 74.6 28.0 ## 23 Y 22.3 42.3 88.9 65.0 ## 24 Z 36.6 44.3 17.9 23.9 str(notas) ## &#39;data.frame&#39;: 24 obs. of 5 variables: ## $ Nome : chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ## $ Nota.1: num 10.9 71.3 65.9 3.6 70.9 76.9 73.6 2 25.3 7 ... ## $ Nota.2: num 60.9 9.9 0.3 70 81.9 53 2.3 88 11.9 19.3 ... ## $ Nota.3: num 53.6 13.9 28.9 37.9 43.9 29.9 23 10.3 12.3 82.9 ... ## $ Nota.4: num 12 47 55 75.3 8.6 38.6 37.3 28.3 26.3 46.3 ... Acima nós criamos o objeto notaspela importação do arquivo Notas_ENG792.txt referente às notas hipotéticas de vocês na disciplina Eng 792 ao término do semestre. Este arquivo está armazenado em meu computador na pasta J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/. Preste atenção na forma como ele foi importado o endereço veio antes do nome do arquivo e as separações entre os diretórios se pelo uso de /, mas também poderia ter utilizado \\\\. Após o endereço do arquivo vieram as options separadas por vírgulas (,). Se você tiver a curiosidade de abrir o arquivo .txt, você verá como os dados estão organizados e entenderá a utilização de cada argumento. No entanto, como eu sou gente boa, vou ajudar vocês embora vocês não mereçam. O argumento sep=\",\"foi utilizado pois os dados de cada “célula” está separado da outra por meio de uma vírgula ,. sep=\"\" indica espaço delimitando os dados sep=\"\\t\" indica tab delimitando os dados sep=\"\\n\" indica new line delimitaNdo os dados O argumento header=T\" indica que nossa tabela tem cabeçalho e é a primeira linha após o skip=3. O argumento skip=3\" indica que as 3 primeiras linhas de nosso arquivo devem ser ignoradas começando assim, nossa tabela a partir da 4ª linha. Note ainda que os nomes das colunas foram automaticamente alterados para atender as convenções de condificação do R. Onde originalmente estava Nota 1 agora temos Nota.1. Notas Eng792 Vejam que na tabela criada houve erros na na codificação dos caracteres especiais. RESOLVA ISSO! E digo mais determine que a primeira coluna (os nomes de vocês) sejam o nome das linhas 4.3.5 read.csv() Embora muito comuns arquivos em formato .txt, a maioria dos cientistas preferem armazenar dados em planilhas eletrônicas como do excel xlsx. ou .csv ( comma-separated values). Baixe o arquivo Cap_1_P2-Mispriced-Diamonds.csv PVANet diamantes&lt;-read.csv(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_1_P2-Mispriced-Diamonds.csv&quot;) str(diamantes) ## &#39;data.frame&#39;: 53940 obs. of 3 variables: ## $ carat : num 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ clarity: chr &quot;SI2&quot; &quot;SI1&quot; &quot;VS1&quot; &quot;VS2&quot; ... ## $ price : int 326 326 327 334 335 336 336 337 337 338 ... head(diamantes) # mostra as 6 primeiras linhas do objeto ## carat clarity price ## 1 0.23 SI2 326 ## 2 0.21 SI1 326 ## 3 0.23 VS1 327 ## 4 0.29 VS2 334 ## 5 0.31 SI2 335 ## 6 0.24 VVS2 336 tail(diamantes) # mostra as 6 últimas linhas do objeto ## carat clarity price ## 53935 0.72 SI1 2757 ## 53936 0.72 SI1 2757 ## 53937 0.72 SI1 2757 ## 53938 0.70 SI1 2757 ## 53939 0.86 SI2 2757 ## 53940 0.75 SI2 2757 Observem que no comando read.csv() nós não adicionamos o argumento header=T, issto por que por padrão headeré igual a TRUE (T), caso seus dados não tenham cabeçalhos você deve argumentar header=F Você já deve ter esbarrado com dados no “brasileiros” nos quais os separadores decimais não são pontos como no padrão internacional, mas vírgulas. Da mesma maneira, em Banânia, os separadores de de células são ponto e vírgula (semi-vírgula - ;). Para evitar problemas como esse na importação dos dados, (Perlin (2018)) sugere que sejam abertos em um editor de texto qualquer e substitua todos os valores de vírgula (,) por ponto (.). Isso deixa o arquivo em um formato internacional. No Windows, programas como o Notepad e o Notepad + + realizam essa tarefa facilmente, no linux o gedit e etc. Perlin (2018) suegre para evitar problemas, antes de prosseguir para a importação de dados em um arquivo .csv, deve-se abrir o arquivo em um editor de texto qualquer e verificar: A existência de texto antes dos dados e a necessidade de ignorar algumas linhas iniciais; A existência ou não dos nomes das colunas; O símbolo separador de colunas; O símbolo de decimal, o qual deve ser o ponto (.). Caso não seja possível converter os dados para o formato internacional, para esta jaboticaba você pode utilizar funções específicas como read.csv2() que assume que o indicador de decimal é a vírgula (,) e o separação de colunas é o ponto-e-vírgula (;). O read.csv()usa como default o padrão internacional sep=”,” e dec=”.” já o read.csv2() tem por default o padrão sep=\";\" e dec=\",\". dec=\"\" (separador de casas decimais) Experimente ambos comandos para abrir o Cap_3_Notas_ENG792.csv. Temos 1 arquivo Cap_3_Notas_ENG792.csv PVANet Notas.csv&lt;-read.csv2(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Notas_ENG792.csv&quot;, row.names = &quot;Nome&quot;) Notas.csv ## Nota.1 Nota.2 Nota.3 Nota.4 ## A 10.9 60.9 53.6 12.0 ## B 71.3 9.9 13.9 47.0 ## C 65.9 0.3 28.9 55.0 ## D 3.6 70.0 37.9 75.3 ## E 70.9 81.9 43.9 8.6 ## F 76.9 53.0 29.9 38.6 ## G 73.6 2.3 23.0 37.3 ## H 2.0 88.0 10.3 28.3 ## I 25.3 11.9 12.3 26.3 ## J 7.0 19.3 82.9 46.3 ## K 52.0 41.0 70.3 31.6 ## L 27.3 74.0 47.6 18.9 ## M 87.9 75.9 17.9 80.6 ## N 76.0 47.9 2.0 19.6 ## O 55.0 60.6 51.9 24.0 ## P 76.6 47.9 90.3 55.6 ## Q 10.3 55.9 18.0 86.3 ## R 17.0 0.9 43.3 14.6 ## S 38.6 22.6 23.6 6.6 ## T 69.0 31.9 75.3 90.6 ## U 26.9 3.6 65.3 48.6 ## V 56.6 32.0 74.6 28.0 ## X 22.3 42.3 88.9 65.0 ## Y 36.6 44.3 17.9 23.9 ## Z 40.0 65.0 77.9 59.0 Notas.csv&lt;-read.csv(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Notas_ENG792.csv&quot;, row.names = &quot;Nome&quot;) ## Error in read.table(file = file, header = header, sep = sep, quote = quote, : more columns than column names Note que o comando read.csv() não funcionou, faça os ajustes necessários para que ele funcine. Explore o comandos rowSums(), colSums(), rowMeans(), colMeans(). 4.3.6 Planilhas excel completas (.xls ou .xlsx) É muito comum encontrarmos dados organizados em diferentes planilhas dentro de um mesmo arquivo como no caso do excel ( .xls ou .xlsx) e semelehantes ( .odt). Estes arquivos e suas diferentes abas podem ser acessados pelo R também, no entanto não há funções nativas que executem esta ação. Precisamos nesse caso instalar pacotes de funções específicas para desempnhar esta operação. Temos algumas opções de pacotes para esta função como XLConnect (Mirai Solutions GmbH (2020)), xlsx (Dragulescu and Arendt (2020)) e readxl (Hadley Wickham and Bryan (2019)). Caso a instalação desses pacotes não funcione e, a mensagem de abaixo apareça. error: No CurrentVersion entry in Software/JavaSoft registry! Try re-installing Java and make sure R and Java have matching architectures. Experimente instalar ou atualizar antes o Java correspondente ao seu sistema operacional e bit. Vamos abrir o Definições iniciais - ENG 792.xlsx. Eu já tenho instalado no meu R, então instale no seu caso não o tenha. install.packages(\"xlsx\") Baixe os dados aqui Baixe o arquivo Cap_3_Informações - Alunos ENG 792.xlsx PVANet library(xlsx) Info.Alunos&lt;-read.xlsx(file=&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.xlsx&quot;, endRow=28,sheetIndex=4,startRow = 2, header = T,encoding=&quot;UTF-8&quot;) Info.Alunos 4.3.7 Exportar arquivos() Uma vez que somo capazes de importar arquivos de formatos específicos, somo também capazes de exportá-los. Podemos exportar data.frame, matrix ou vector para .csv (dos 2 tipos csv e csv2) e para .txt. A estrutura é semelhante para diferentes métodos (write.csv(), write.csv2() ou write.table()): write.csv(Objeto, file = “objeto.csv\", append = FALSE, quote = TRUE, sep = \" \", eol = \"\\n\", na = \"NA\", dec = \".\", row.names = TRUE, col.names = TRUE, qmethod = c(\"escape\", \"double\"), fileEncoding = \"\") Vamos experimentar os diferentes comandos. Antes de prosseguir certifique-se que o endereço de saída está adequado. write.csv(Info.Alunos, file=&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.csv&quot;, sep=&quot;,&quot;,fileEncoding=&quot;UTF-8&quot;) ## Warning in write.csv(Info.Alunos, file = &quot;J:/ENG ## 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.csv&quot;, : ## attempt to set &#39;sep&#39; ignored ## Error in is.data.frame(x): objeto &#39;Info.Alunos&#39; não encontrado write.csv2(Info.Alunos, file=&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.2.csv&quot;,sep=&quot;,&quot;,fileEncoding=&quot;UTF-8&quot;) ## Warning in write.csv2(Info.Alunos, file = &quot;J:/ENG ## 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.2.csv&quot;, : ## attempt to set &#39;sep&#39; ignored ## Error in is.data.frame(x): objeto &#39;Info.Alunos&#39; não encontrado write.table(Info.Alunos, file=&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/Cap_3_Informações - Alunos ENG 792.txt&quot;, sep=&quot;,&quot;,fileEncoding=&quot;UTF-8&quot;) ## Error in is.data.frame(x): objeto &#39;Info.Alunos&#39; não encontrado 4.3.8 Definir diretório de trabalho setwd() Durante a importação e exportação de dados nós forncemos dentro dos comandos os endereço no seu computador ou periférico de onde e para onde os dados deveriam ser importados e exportados, respectivamente. Esta tarefa pode ser simplificada pela determinação de um diretório de trabalho. Após esta definição o R vai comunicar diretamente com esta pasta de maneira que todos os arquivos importados e exportados de a para esta pasta. setwd(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/&quot;) Al.Eng792&lt;-read.xlsx(file=&quot;Cap_3_Informações - Alunos ENG 792.xlsx&quot;, endRow=28,sheetIndex=4,startRow = 2, header =T, encoding=&quot;UTF-8&quot;) write.table(Reposição.de.aula, file=&quot;Cap_3_Informações - Alunos ENG 792.txt&quot;,sep=&quot;,&quot;,fileEncoding=&quot;UTF-8&quot;) Explore o comandos rowSums(), colSums(), rowMeans(), colMeans() e acrescente no data.frame notas uma coluna com soma e média das notas dos alunos e linhas com no fim do arquivo soma e média das notas 1 a 4. Para terminar exporte os arquivos em formato .csv e .txt Para mais informações sobre importação e exportação de dados leia RCoreTeam (2020) . E digo mais, é só isso mesmo. 4.4 Exercícios Defina um objeto chamado a com valores de 60 a 85. Determine o elemento 12 de a. Determine elemento 20 de a. Mostre o 5° e 25° elementos de a. Mostre o 4°, 8°, 12°, 20° e 24° elementos de a. Mostre todos exceto 18°elemento de a. Mostre todos exceto o 2°, 15° e 17° elementos de a. Gere um data frame chamado new_frame com 3 colunas: A primeira com valores de 33 a 47; a segunda começando em 115 e terminando em 157, com incrementos de 3; e a terceira começando em 10, com 15 elementods, e cada elemento decrescendo 8.5. Cada coluna deve ser chamada de X, Y e Z respectivamente. Extraia todos os valores da coluna 1. Extraia das linhas 6 a 10 da coluna 2. Extraia os valores da linha 11 para todas as colunas. Extraia os valores das linhas 4 a 8 das colunas 1 e 3 em formato de data frame Demonstre o número de linhas do new_frame. Demonstre 4 diferentes métodos de extrair os valores de todas as linhas da coluna 1 de new_frame. Crie uma função que multiplique os valores de cada coluna por 2 ao cubo e em seguida aplique para o módulo da mesma seleção log10() criando new_frame2 alojando-o no global environment. Exporte seu new_frame2 para .csv e .txt. 4.5 Dica de leitura Introduction to the pacman Package in R (3 Examples) Quick list of useful R packages 36 Instalando e usando pacotes (packages) do R Installing and Using R Packages 15 Essential packages in R for Data Science A Tutorial on Using Functions in R! R - Functions Creating Functions R Functions Writing Functions in R: Example One How to write Functions in R This R Data Import Tutorial Is Everything You Need Importing Data Into R Importing Data R Data Import/Export Importing Data with the RStudio IDE References "],["produção-gráfica-e-comunicação-visual.html", "Capítulo 5 Produção gráfica e comunicação visual 5.1 Utilizando funções nativas 5.2 Cores no R 5.3 Para mais informações utilize o Google ou os documentos abaixo 5.4 ggplot2 5.5 Para mais informações utilize o Google ou os documentos abaixo", " Capítulo 5 Produção gráfica e comunicação visual Assista este conteúdo em Cap 4 - Produção gráfica e comunicação visual - Parte 1 no PVANet R é capaz de produzir uma grande variedade de gráficos em alta qualidade para publicação e impressão. Tipos básicos de gráficos ( barplot, boxplot, scatterplot, maps e etc). É bastante simples produzir gráficos tradicionais no R, especialmente no nível mais básico e cada gráfico pode ser personalizado para atender as demandas do usuário. Gráficos R Fonte: Revolutions Os comando gráficos podem ser divididos em 3 categorias Mello and Peternelli (2013); 1. comando de alto nível – criam gráficos completos; 2. comando de baixo nível – adicionam informações a gráficos já existentes; 3. comando interativos – permitem ao usuário a interação com a janela gráfica. Os gráficos são plotados na aba Plots. Painel de plotagem O R possui algumas funções nativas para a criação de figuras, tal como plot e hist. De acordo com Perlin (2018) essas e outras funções nativas são restritivas e não recomendadas com customização pouco intuitivas com resultado final pouco atrativo. Eu pessoalmente nunca experimentei tal limitação e, arrisco a dizer respeitosamente que, tudo que você quer fazer com funções do ggplot2 pode ser feito com funções nativas, basta saber manipular corretamente os argumentos. Mas tenho que concordar que com ggplot2 as funções são mais simples e objetivas. De qualquer forma fica o alerta para possíveis limitações. 5.1 Utilizando funções nativas As funções nativas do R para prdoução de gráficos e plotagem são armazenadas pelos pacotes graphics e grDevices que carregam atutomaticamente sempre que o R é iniciado Peng (2020a). graphics: Contém as funções básicas do ambiente gráfico (plot, hist, boxplot e etc) grDevices: É responsável por permitir a comunição dos gráficos produzidos com outras linguagens de tratameneto de imagens ( X11, .pdf, PostScript, PNG e etc). Os gráficos básicos no R possuem uma grande variedade de parâmetros que nos auxiliam na produção e/ou “melhoramento” de um gráfico pré-concebido através da adição de novas informações. 5.1.1 boxplot - boxplot() São gráficos muito úteis que conseguem concatenar e mostrar uma série de informações de uma só vez. Muito úteis principalmente quando temos uma variável categórica associada. No R estes gráficos podem ser feitos utilizando o comando boxplot(). A fórmula tem a forma de eixo-y ~ eixo-x. Vamos utilizar o pacote datasets e os dados InsectSprays que mostra dados de um experimento de agricultura onde insetos foram tratados com diferentes inseticidas. A hipótese é que quanto mais eficiente o inseticida ( spray ) menos insetos ( count ) sobrevivem, ou seja, count é em função de spray. No boxplot cada caixa mostra os dados observados de cada tipos de spray (A até F) e vemos que os inseticidas C, D e E são os mais eficientes. Temos a mediana representada pela linha preta, os limites inferior e superior que representam o primeiro e o terceiro quartil (50% dos dados). As linhas superiores e inferiores correspondem a 2 desvios-padrão e os pontos fora das caixas são os outliers. Para mais detalhes sobre interpretação do boxplot procure um livro de estatística ou acesse a internet como em Boxplot . data(InsectSprays) str(InsectSprays) ## &#39;data.frame&#39;: 72 obs. of 2 variables: ## $ count: num 10 7 20 14 14 12 10 23 17 20 ... ## $ spray: Factor w/ 6 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... head(InsectSprays) ## count spray ## 1 10 A ## 2 7 A ## 3 20 A ## 4 14 A ## 5 14 A ## 6 12 A tail(InsectSprays) ## count spray ## 67 13 F ## 68 10 F ## 69 26 F ## 70 26 F ## 71 24 F ## 72 13 F boxplot(count ~ spray,data = InsectSprays) Experimente adicionar o argumento notch=T. 5.1.2 histograma - hist() Histograma é um tipo de gráfico que combina várias barras verticais representando as frequências das variáveis. hist(InsectSprays$count,right=T, breaks=10, include.lowest=T, col= &quot;orange&quot;, border=&quot;red&quot;, adj=0, col.axis=&quot;blue&quot;) Veja que no histograma gerado nós adicionais alguns argumentos. Estes comandos introduzem variações no gráfico gerado que auxiliam na visualização das informações. right=T: Considera valores fechado à direita (já é o padrão). breaks=30: Define o intervalo das classes no eixo x (abscissas) controlando a espessura das barras. include.lowest=T: Inclui os valor extremos do vetor. col=\"orange: Define a cor do preenchimento da forma. border=red: Define a cor da borda. adj=0: Ajusta o alinhamento dos nomes dos eixos. col.axis=blue: Define a cor dos eixos. 5.1.3 Gráfico de barras - barplot() Linhas verticais descrevendo valores (barplot()). Exemplo abaixo veio do stackoverflow Texture in barplot for 7 bars in R?. Aqui temos gráficos de barras com texturas. # data generation --------------------------------------------------------- set.seed(1) mat &lt;- matrix(runif(4*7, min=0, max=10), 7, 4) rownames(mat) &lt;- 1:7 colnames(mat) &lt;- LETTERS[1:4] # plotting settings ------------------------------------------------------- ylim &lt;- range(mat)*c(1,1.5) angle1 &lt;- rep(c(45,45,135), length.out=7) angle2 &lt;- rep(c(45,135,135), length.out=7) density1 &lt;- seq(5,35,length.out=7) density2 &lt;- seq(5,35,length.out=7) col &lt;- 1 # rainbow(7) # plot -------------------------------------------------------------------- op &lt;- par(mar=c(3,3,1,1)) barplot(mat, beside=TRUE, ylim=ylim, col=col, angle=angle1, density=density1) barplot(mat, add=TRUE, beside=TRUE, ylim=ylim, col=col, angle=angle2, density=density2) legend(&quot;top&quot;, legend=1:7, ncol=7, fill=TRUE, col=col, angle=angle1, density=density1) par(bg=&quot;transparent&quot;) legend(&quot;top&quot;, legend=1:7, ncol=7, fill=TRUE, col=col, angle=angle2, density=density2) par(op) 5.1.4 Gráfico de setores (pizza) - pie() Divide um círculo em setores de acorco com os valores de cada categoria. pie(1:15, col = rainbow(15)) col=rainbow(15)= Preenche as áreas internas do gráfico com 15 cores utilizando a paleta de cores do arco-íris. 5.1.5 Função plot() A função plot() é uma função genérica amplamente utilizada para gerar gráficos. Nós vamos utilizá-la muito de agora em diante. plot()é provavelmente o comando de alto nível mais simples para criação de gráficos. Com ele podemos visualizar desde gráficos de dispersão até imagens de satélites. O tipo de plot a ser gerado depende da classe (class(x)) do primeiro argumento(x). Se x e y são vetores (plot(x, y)) produzirá um gráfico de dispersão ( scatter plot). Se x é um vetor numérico plot(x) produzirá um gráfico dos valores de X contra os valores dos índices. Se x é uma série temporal plot(x) produzirá um gráfico de uma série temporal. Se x é um factor, plot(x) produzirá um bar plot de x. Se x é um factor e y um vetor numérico plot(x,y) produzirá um boxplot de y para cada nível de x. Se x é um data.frame, y é qualquer objeto e expr é uma lista de nomes de objetos separados por “+” (por exemplo, a + b + c). plot(df) e plot(~ expr) produzirão gráficos de distribuição das variáveis em uma tabela quadro de dados (1º plot) ou de vários objetos nomeados (2° plot). plot(y ~ expr) produzirá um plot de y em relação a cada objeto nomeado em expr. v&lt;-1:20 m&lt;-v^2 plot(v,m) points(rev(v),m) # points () adiciona pontos a um gráfico já existente lines(v,400-m, col=&quot;red&quot;) #lines() adiciona linhas a um gráfico já existente text(10,200, &quot;Anuncie aqui&quot;) X&lt;-c(2, 3, 4, 5, 6, 7) #X maiúsculos mesmo Y&lt;-c(15, 46, 56, 15, 81, 11) #Y maiúsculo mesmo Nomes&lt;-LETTERS[1:6] Cidades&lt;-data.frame(X, Y, row.names=Nomes) Cidades ## X Y ## A 2 15 ## B 3 46 ## C 4 56 ## D 5 15 ## E 6 81 ## F 7 11 plot(Cidades) identify(Cidades) ## integer(0) 5.1.6 Formatando eixos Os exemplos anteriores serviram apenas para ilustração, mas se quisermos algo para publicação ou qualquer comunicação de melhor qualidade temos que trabalhar um pouco mais. Inicialmente podemos inserir os título e nomear os eixos. main=: Insere um título no gráfico; xlab=: Adiciona título ao eixo x do gráfico; ylab=: Adiciona título ao eixo y do gráfico. plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;) Nesse caso nós manipulamos os tamanhos dos eixos x e y concatenando vetores para xlim e ylim respectivamente. xlim=: Determina o intervalo do eixo x. ylim=: Determina o intervalo do eixo y. plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90)) Os rótulos dos eixos são geralmente posicionados na horizontal, no entanto os rótulos podem ser ajustados para o critério do usuário utilizando o argumento las=x (x=valor inteiro entre 0 e 3). * 1: sempre paralelo ao eixo (default) * 2: sempre horizontal * 3: sempre perpendicular ao eixo * 4: sempre vertical Podemos também plotar vários gráficos na mesma janela. Para isso precismamos controlar o painel com o comando par() combinado com mfrowou mfcol. mfrow=(x,y): Distribui os gráficos em linhas em que x é o número de linhas e y o número de colunas. mfcol=(x,y): Distribui os gráficos em colunas em que x é o número de linhas e y o número de colunas. par(mfrow=c(2,2)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3) par(mfcol=c(2,2)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3) Podemos alterar também os símbolos dos gráficos Por padrão o R usa círculos abertos nos gráficos. Isso pode ser alterado de acordo com preferência do usuário usando o argumento pch = x (x=valor inteiro entre 0 e 25) dentro do plot(). par(mfcol=c(2,2)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, pch=2) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1,pch=4) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2,pch=8) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,pch=16) O tamanho dos símbolos também pode ser ajustado utilizando o argumento cex=x. par(mfcol=c(2,2)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, pch=2, cex=0.3) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1,pch=4, cex=0.8) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2,pch=8, cex=1.3) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,pch=16, cex=1.8) O usuário não precisa unicamente utilizar os símbolos de pch para fazer seus gráficos, a conexão entres os pontos podem ser importante em alguns casos acrescentando o argumento type=\"x\" (x pode ser p, l, b, c, o, h, s, S, n). “p” para pontos; “l” para linhas; “b” para ambos; “c” apenas as linhas sem os pontos; “o” para ambos sobrepostos; “h” para tipo histograma (ou “alta densidade”) linhas verticais; “s” para degraus; “S” para outros tipos de degraus; “n” sem plot; par(mfcol=c(3,3)) plot(trees$Girth, trees$Height,main=&quot;1° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, cex=1, type=&quot;p&quot;) plot(trees$Girth, trees$Height,main=&quot;2° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1,cex=1, type=&quot;l&quot;) plot(trees$Girth, trees$Height,main=&quot;3° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2, cex=1,type=&quot;b&quot;) plot(trees$Girth, trees$Height,main=&quot;4° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,cex=1,type=&quot;c&quot;) plot(trees$Girth, trees$Height,main=&quot;5° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, cex=1, type=&quot;o&quot;) plot(trees$Girth, trees$Height,main=&quot;6° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;blue&quot;,las=1,cex=1, type=&quot;h&quot;) plot(trees$Girth, trees$Height,main=&quot;7° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;black&quot;,las=2, cex=1,type=&quot;s&quot;) plot(trees$Girth, trees$Height,main=&quot;8° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,cex=1,type=&quot;S&quot;) plot(trees$Girth, trees$Height,main=&quot;9° Relação Altura x Circunferência&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;purple&quot;,las=3,cex=1,type=&quot;n&quot;) Os gráficos podem também ser feitos por diferentes tipos de linhas. Uma vez defino que ele será do tipo l por xemplo (type=\"l\") podemos variar como a linha será apresentada com lty=x (x = número de 0 a 6). Experimente acrescentar o comando lwd=x (x é um número) para ir variando a espessura da linha. Fonte: sthda par(mfcol=c(3,2)) # Já que lty = 0 produz uma gráfico em branco não vamos mostrá-lo. for(i in 1:6){ plot(trees$Girth, trees$Height,main=paste(i,&quot;Relação Altura x Circunferência&quot;), xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;, xlim=c(5,25), ylim=c(60,90),col=&quot;red&quot;,las=0, cex=1, type=&quot;l&quot;,lty=i) legend(&quot;bottomright&quot;,c(paste(&quot;lty=&quot;,i)),col=c(&quot;red&quot;)) } Podemos também fazer a sobreposição de gráficos ou adicionar elementos em um gráfico existente. par(new=T): habilita a sobreposição no mesmo painel de um outro gráfico. Lembre-se de desativar os outros parâmetros como eixos, labels, nomes e etc. Deixe apenas os pontos e informações do eixo necessário. axes=FALSE: Desativa a inclusão dos eixos xlab=\"\" e ylab=\"\": Deixa os labels dos eixos vazios. plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência x Volume&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;,ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) Veja no gráfico acima que o eixo secundário da informação voluma não foi incluído por isso precisamos adicioná-lo. Contudo antes de adicioná-lo, vamos ter que ajustar o painel, caso contrário ele será plotado, mas não aparecerá. Precisamos entender antes de tudo que a região de plotagem é possui 4 lados (4 margens) numeradas da seguinte forma. 1 - inferior 2 - esquerda 3 - superior 4 - direita Fonte: http://applied-r.com/ O tamanho destas margens podem ser controladas utilizando o argumento mar=c(A,B,C,D) em que c(A, B, C e D) é um vetor numérico que determina o tamanho das margens referentes à 1ª, 2ª, 3ª e 4ª posição, respectivamente. Vamos liberar um espaço à direita para adicionar um eixo secundário no exemplo anterior. O eixo secundário é inserido “ativando” a margem 4 com comando axis(side=4, las=1) e em seguinda, acrescentando as informaçõpes necessárias com mtext(side=4, line=2.5, \"Volume da madeira (pés cúbicos)\"). side=4: Indica que as informações serão inseridas no lado 4. line=2.5: Indica a posição onde o texto será inserio no lado 4. par(mar=c(4, 4, 2, 4)) plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência x Volume&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) Podemos adicionar informações fora do gráfico (como título do eixo secundário) de uma outra forma. Para isto precisamos determinar xpd=T que viabiliza utilizar as margens externas do gráfico atual (padrão é xpd=F). Caso determine xpd=NA você pode utilizar qualquer região da área de plotagem. par(oma=c(0,0,4,3)): oma (Outer Margin Area) - especifica que as margens 3 e 4 terão 4 e 3 linhas, respectivamente. Investigue também os argumentos omi, mai, mgp, outer e omd. par(mar=c(4, 4, 2, 4),par(oma=c(0,0,4,3))) ## Warning in par(mar = c(4, 4, 2, 4), par(oma = c(0, 0, 4, 3))): argument 2 does ## not name a graphical parameter plot(trees$Girth, trees$Height,main=&quot;Relação Altura x Circunferência x Volume&quot;, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(22.6, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) Pesquise por outer=T. A legenda pode ser adicionada com argumento legend(). bty=\"n\": não permite desenhar uma caixa em torno da legenda. \\n : Permite quebrar o texto como no título agora inserido com comando title(). cex.main=: Tamanho da fonte font.main= Tipo da fonte par(mfrow=c(1,2),mar=c(2, 2, 2, 2),par(oma=c(1,1,1,1))) ## Warning in par(mfrow = c(1, 2), mar = c(2, 2, 2, 2), par(oma = c(1, 1, 1, : ## argument 3 does not name a graphical parameter plot(trees$Girth, trees$Height, xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) title(&quot;Medidas de altura, diâmentro e\\n volume para 31 cerejeiras&quot;, cex.main=0.5,font.main=2) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(25, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) legend(&quot;topleft&quot;, c(&quot;Altura da árvore&quot;, &quot;Volume da madeira&quot;), pch=c(16, 4),col=c(&quot;springgreen&quot;, &quot;blue&quot;), bty=&quot;n&quot;) ##################### plot(trees$Girth, trees$Height,xlab=&quot;Circunferência da árvore (polegadas)&quot;, ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) title(&quot;Medidas de altura, diâmentro e\\n volume para 31 cerejeiras&quot;, cex.main=1,font.main=4) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(25, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) legend(12,20, c(&quot;Altura da árvore&quot;, &quot;Volume da madeira&quot;), pch=c(16, 4), col=c(&quot;springgreen&quot;, &quot;blue&quot;), bty=&quot;n&quot;) Outra maneira de plotar vários gráficos é manipulando os layouts. layout.matrix &lt;- matrix(c(2,1, 0, 3), nrow = 2, ncol = 2) layout(mat = layout.matrix, heights = c(1, 2), # Altura das duas linhas widths = c(2, 2)) # Largura das duas colunas layout.show(3) layout.matrix &lt;- matrix(c(2,1, 0, 3), nrow = 2, ncol = 2) layout(mat = layout.matrix, heights = c(1, 2), # Altura das duas linhas widths = c(2, 2)) # Largura das duas colunas plot(trees$Girth, trees$Height, xlab=&quot;Circunferência da árvore (polegadas)&quot;,ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) title(&quot;Medidas de altura, diâmentro e\\n volume para 31 cerejeiras&quot;, cex.main=1,font.main=2) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(25, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) legend(&quot;topleft&quot;, c(&quot;Altura da árvore&quot;, &quot;Volume da madeira&quot;), pch=c(16, 4),col=c(&quot;springgreen&quot;, &quot;blue&quot;), bty=&quot;n&quot;) par(mar = c(0, 4, 4, 0)) boxplot(trees$Girth, xaxt = &quot;n&quot;,yaxt = &quot;n&quot;, bty = &quot;n&quot;,col = &quot;white&quot;, frame = FALSE, horizontal = TRUE, main=&quot;Boxplot circunferência&quot;) par(mar = c(5, 0, 4, 0)) boxplot(trees$Height,xaxt = &quot;n&quot;,yaxt = &quot;n&quot;, bty = &quot;n&quot;,col = &quot;white&quot;, frame = F,main=&quot;Boxplot Altura&quot;) Para salvar os gráficos ou figuras podemos fazê-lo manualmente no painel Plots -&gt; export e escolher o formato de saída bem como as dimensões. Podemos também exportar as figuras por linhas de comando. png(filename = &quot;ENG792.Plot.png&quot;, width = 480, height = 480) layout.matrix &lt;- matrix(c(2,1, 0, 3), nrow = 2, ncol = 2) layout(mat = layout.matrix, heights = c(1, 2), # Altura das duas linhas widths = c(2, 2)) # Largura das duas colunas plot(trees$Girth, trees$Height, xlab=&quot;Circunferência da árvore (polegadas)&quot;,ylab=&quot;Altura da árvore (pés)&quot;,xlim=c(5,25), ylim=c(60,90), las=1, pch=16, col=&quot;springgreen&quot;) title(&quot;Medidas de altura, diâmentro e\\n volume para 31 cerejeiras&quot;, cex.main=1,font.main=2) par(new=TRUE) plot(trees$Girth, trees$Volume, axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, pch=4, col=&quot;blue&quot;) axis(side=4, las=1) #mtext(side=4, line=2.5, &quot;Volume da madeira (pés cúbicos)&quot;) text(25, 70, adj=0, srt=-90, &quot; Volume da madeira (pés cúbicos)&quot;, xpd=TRUE) legend(&quot;topleft&quot;, c(&quot;Altura da árvore&quot;, &quot;Volume da madeira&quot;), pch=c(16,4),col=c(&quot;springgreen&quot;, &quot;blue&quot;), bty=&quot;n&quot;) par(mar = c(0, 4, 4, 0)) boxplot(trees$Girth, xaxt = &quot;n&quot;,yaxt = &quot;n&quot;, bty = &quot;n&quot;,col = &quot;white&quot;, frame = FALSE, horizontal = TRUE,main=&quot;Boxplot circunferência&quot;) par(mar = c(5, 0, 4, 0)) boxplot(trees$Height,xaxt = &quot;n&quot;,yaxt = &quot;n&quot;, bty = &quot;n&quot;,col = &quot;white&quot;, frame = F,main=&quot;Boxplot Altura&quot;) dev.off() ## png ## 2 Para mais exemplos sobre as fontes acesse aqui. Para saber mais dos parâmetros: names(par()) ## [1] &quot;xlog&quot; &quot;ylog&quot; &quot;adj&quot; &quot;ann&quot; &quot;ask&quot; &quot;bg&quot; ## [7] &quot;bty&quot; &quot;cex&quot; &quot;cex.axis&quot; &quot;cex.lab&quot; &quot;cex.main&quot; &quot;cex.sub&quot; ## [13] &quot;cin&quot; &quot;col&quot; &quot;col.axis&quot; &quot;col.lab&quot; &quot;col.main&quot; &quot;col.sub&quot; ## [19] &quot;cra&quot; &quot;crt&quot; &quot;csi&quot; &quot;cxy&quot; &quot;din&quot; &quot;err&quot; ## [25] &quot;family&quot; &quot;fg&quot; &quot;fig&quot; &quot;fin&quot; &quot;font&quot; &quot;font.axis&quot; ## [31] &quot;font.lab&quot; &quot;font.main&quot; &quot;font.sub&quot; &quot;lab&quot; &quot;las&quot; &quot;lend&quot; ## [37] &quot;lheight&quot; &quot;ljoin&quot; &quot;lmitre&quot; &quot;lty&quot; &quot;lwd&quot; &quot;mai&quot; ## [43] &quot;mar&quot; &quot;mex&quot; &quot;mfcol&quot; &quot;mfg&quot; &quot;mfrow&quot; &quot;mgp&quot; ## [49] &quot;mkh&quot; &quot;new&quot; &quot;oma&quot; &quot;omd&quot; &quot;omi&quot; &quot;page&quot; ## [55] &quot;pch&quot; &quot;pin&quot; &quot;plt&quot; &quot;ps&quot; &quot;pty&quot; &quot;smo&quot; ## [61] &quot;srt&quot; &quot;tck&quot; &quot;tcl&quot; &quot;usr&quot; &quot;xaxp&quot; &quot;xaxs&quot; ## [67] &quot;xaxt&quot; &quot;xpd&quot; &quot;yaxp&quot; &quot;yaxs&quot; &quot;yaxt&quot; &quot;ylbias&quot; 5.2 Cores no R O R nativo possui uma grande variedade de cores que podem ser utilizadas e combinadas. Podemos utilizar cores (cm.colors, rainbow, heat.colors, terrain.colors ou topo.colors) do grDevices. Podemos utilizar pacotes de cores também como RColorBrewer, unikn, viridis 5.2.1 RColorBrewer 5.2.2 unkin 5.2.3 viridis 5.3 Para mais informações utilize o Google ou os documentos abaixo Uma grande fonte de inspiração para produção de gráficos é o The R Graph Gallery Mastering r plot - part 1 Mastering r plot - part 2 Mastering r plot - part 3 An Introduction to R Graphics parameters list The R Graphics Package Graphical Parameters - cheat sheet R Graphics: Plot Parameters Graphical parameters - STHDA Styling Base R Graphics R Base Graphics: An Idiot’s Guide R Function of the Day - par(mar, mgp, las) Set or Query Graphical Parameters Graphical Layouts An xpd-tion into R plot margins Barplots with Pattern Fill AN INTRODUCTION TO PATTERNPLOT PACKAGE Colors in R Top R Color Palettes to Know for Great Data Visualization R color cheatsheet Creating a composite gif with multiple gganimate panels Leia também Murrel (2011), Venables and Smith (2020), Chang (2020) e Neth (2021) 5.4 ggplot2 Assista este conteúdo em Cap 4 - ggplot2 no PVANet O pacote ggplot2 é parte da coleção de pacotes chamado tidyverse que se destina à ciência de dados. Todos estes pacotes possuem a mesma espinha dorsal, ideia e/ou filosofia desde sua concepção até sua utilização. Caso queira se aventurar no universo tidy (altamente recomendado) instale todos os pacotes de uma só ves pelo comando: install.packages(\"tidyverse\") Vai demorar um pouco, pois são muitos arquivos enquanto isso você pode ir lendo o livro R for Data Science. Como nosso assunto hoje é apenas o ggplot2 podemos instalar apenas ele. Você pode instalá-lo diretamente do CRAN install.packages(\"ggplot2\") ou do github install.packages(\"devtools\") em seguida devtools::install_github(\"tidyverse/ggplot2\"). Para instalar do github você vai precisar de um pacote como devtools que permite, entre outras coisas, abrir conexão com github através da URL do pacote para instalá-lo. Uma vez instalado o pacote pode ser carregado por library(tidyverse)(carrega todos os pacotes da coleção) ou library(ggplot2) (carrega apenas o ggplot2) Veremos que, embora o potencial do comando nativo plot() seja enorme o comando ggplot() e seus argumentos deixam as coisas bem mais simples e objetivas. Seguirei aquilo que foi apresentado no livro R for Data Science por H. Wickham and Grolemund (2019). O ggplot2()possui uma estrutura lógica de construção de grágicos que nos permite entender melhor ou de maneira mais fácil como os dados podem ser visualizados. Estrutura do ggplot Atenção quando forem trabalhar os dados (quantitativos, qualitativos, cronológicos ou geográficos), cada tipo de dados possui características que são melhores exploradas/visualizadas por tipos específicos de gráficos. Vamos utilizar os dados mpg para iniciar nossas análises. Estes dados guardam informações coletadas pela Agência de Proteção Ambiental dos Estados Unidos sobre 38 modelos de carros. Carros com motores maiores consomem mais combustível? library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.1 ✔ stringr 1.5.0 ## ✔ forcats 1.0.0 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ✔ readr 2.1.4 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ tidyr::extract() masks magrittr::extract() ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ✖ purrr::set_names() masks magrittr::set_names() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors # ou library(ggplot2) str(mpg) ## tibble [234 × 11] (S3: tbl_df/tbl/data.frame) ## $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... ## $ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... ## $ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... ## $ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... ## $ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... ## $ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... ## $ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... ## $ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... ## $ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... ## $ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... ## $ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... ggplot(data=mpg)+ geom_point(mapping=aes(x=displ, y=hwy)) Veja que a estrutura do gráfico com ggplot() é a seguinte: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) ggplot() cria um sistema de coordenadas ao qual outras informações são adicionadas. O usuário diz a origem dos dados (data=), escolhe a função geom_ (geom_point nesse caso) para definir o tipo de gráfico que quer (ponto, linhas, barras e etc) seguido de parênteses com os argumentos da estética do (aes) que estabelece o que vai em cada eixo. No gráfico acima, observamos alguns pontos à direta que estão fora da tendência linear e gostaríamos de saber quais pontos são esses. Para isso podemos adicionar uma terceira informação ao nosso gráfico relacionado às cores (color ou colour funcionam da mesma maneira) para o atributo class. Não se esqueça que o sinal + deve ficar no final da linha a qual quer continuar abaixo. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class)) Desta forma, para associar uma variável ou atributo à um elemento gráfico adicione tudo dentro de aes() como no caso acima associamos classe às cores e um legenda foi automaticamente gerada. Percebemos que os pontos fora da tendência são pontos de carros de 2 lugares que não são necessariamente híbridos, mas esportivos. Da mesma maneira que associamos às cores podemos associar ao tamanho utilizando size=class. Mas observe que temos um aviso sobre o inconveniente que é associar variável discreta à tamanho. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = class)) ## Warning: Using size for a discrete variable is not advised. Poderíamos ainda associar class à transparência alpha, como já apresentado na Semana 1 - Aula 1, ou a formato. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, alpha = class)) ## Warning: Using alpha for a discrete variable is not advised. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = class)) ## Warning: The shape palette can deal with a maximum of 6 discrete values because ## more than 6 becomes difficult to discriminate; you have 7. Consider ## specifying shapes manually if you must have them. ## Warning: Removed 62 rows containing missing values (`geom_point()`). Pela análise do gráfico acima ficamos pensando o que acontece com as SUV’s, notamos assim que temos apenas 6 tipos de shapes para nossas variáveis e os demais grupos ficam de fora da classificação. Uma vez definido as características estéticas (aes) a seleção dos demais atributos como a paleta de cores será automaticamente definida pelo ggplot2. Se definirmos a cor como blue por exemplo, não temos ganho de informação no nosso gráfico uma vez que ficou tudo azul. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = &quot;blue&quot;) 5.4.1 Facetas (subgráficos) - facets Uma maneira de prozir múltiplos gráficos com ggplot2 é utilizar o comand facet Para gerar gráficos de facetas com uma única variável utilize facet_wrap() e adicione os argumento que achar necessários como número de linhas ncol=2. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2) Para combinar 2 variáveis utilize facet_grid(). Desta vez o argumento é uma fórmula drv ~ cyl ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ cyl) Se optar por gráficos não atrelados às dimensões de linhas ou colunas, use ponto (.) no lugar do nome de uma variável. # Orientação por linha ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ .) # Orientação por coluna ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(. ~ cyl) # Organizados em 2 linhas por class ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2) 5.4.2 Objetos geométricos Observe os gráficos abaixo e vejam em que eles diferem. Obviamente um mostra pontos e o outro uma linha suavizada. O comando comando responsável por esta diferença é o geom_COMPLEMENTO. #install.packages(&quot;ggpubr&quot;) library(ggpubr) ggarrange(ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)), ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy))) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; “Um geom é um objeto geométrico que um gráfico usa para representar dados. As pessoas descrevem o geom como o tipo de gráfico que ele usa. Por exemplo, gráfico de barras usam geoms de barras, gráficos de linha usam geoms de linha … . Gráficos de dispersão quebram a tendência, eles utilizam geom de ponto. …” “Cada função geom recebe um argumento mapping. Entretanto, nem toda estética funciona com todo geom. Você pode configurar a forma de um ponto, mas não pode configurar a”forma” de uma linha. Por outro lado, você pode configurar o tipo de linha. mpg$drv ## [1] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [19] &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [37] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [55] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [73] &quot;4&quot; &quot;4&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [91] &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [109] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [127] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;r&quot; &quot;r&quot; &quot;r&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [145] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; ## [163] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; ## [181] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [199] &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;4&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ## [217] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv)) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; # 4 = tração 4x4 # f = tração dianteira # r = tração traseira ggplot2 tem mais de 30 geoms clique aqui e confira. ggplot2 vai automaticamente agrupar os dados para esses geoms de qualquer mapeamento estético para variável discreta. Podemos utilizar o argumento group com uma variável para agrupar vários objetos. ggarrange(ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy)), ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, group = drv)), ggplot(data = mpg) + geom_smooth( mapping = aes(x = displ, y = hwy, color = drv), show.legend = FALSE), ncol=3) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Para exibir mais de um geom no mesmo gráfico você pode combiná-los. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_smooth(mapping = aes(x = displ, y = hwy)) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Nesse caso há uma duplicação de informações e caso queira fazer alterações em uma variável e esquecesse a outra poderia ter problemas. Por isso podemos evitar repetições combinando os geoms. Veja que temos o mesmo gráfico sem tantos argumentos. ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; O ggplot2 tratará os mapeamentos locais para cada camada caso determine mapeamentos em função de geom possibilitando exibir estéticas diferentes. ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Podemos utilizar a mesma ideia para especificar um conjunto de dados diferentes para cada camada. No exemplo abaixo a linha exibe o comportamento de um outro banco de dados. ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth(data = filter(mpg, class == &quot;subcompact&quot;), se = FALSE) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 5.4.3 Transformações estatísticas 5.4.3.1 Gráfico de barras Número total de diamantes agrupados por cut. É aquele conjunto de dados de diamantes que trabalhamos nas aulas anteriores, mas agora com outras variáveis além de price, carat e clarity. Agora temos também color e cut. No eixo x temos cut e no y temos count mesmo não sendo uma variável de diamonds. Esta figura mostra como funciona a transformação para produção do gráfico de barras utilizando o algorítimo stat. str(diamonds) ## tibble [53,940 × 10] (S3: tbl_df/tbl/data.frame) ## $ carat : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... ## $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... ## $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... ## $ depth : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... ## $ table : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ... ## $ price : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ... ## $ x : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... ## $ y : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... ## $ z : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) Podemos analisar qual stat cada geom utiliza entrando com os comando adequados (geom_bar() usa stat_count()) geom_bar() ## geom_bar: just = 0.5, width = NULL, na.rm = FALSE, orientation = NA ## stat_count: width = NULL, na.rm = FALSE, orientation = NA ## position_stack stat_count() ## geom_bar: na.rm = FALSE, orientation = NA, width = NULL ## stat_count: na.rm = FALSE, orientation = NA, width = NULL ## position_stack ggplot(data = diamonds) + stat_count(mapping = aes(x = cut)) Podemos alterar o mapeamento padrão de variáveis transformadas para estética. Exibir um gráfico de barras de proporção, em vez de count. ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = stat(prop), group = 1) ) ## Warning: `stat(prop)` was deprecated in ggplot2 3.4.0. ## ℹ Please use `after_stat(prop)` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. Um pouco mais de detalhe. ggplot(data = diamonds) + stat_summary( mapping = aes(x = cut, y = depth), fun.min = min, fun.max = max, fun = median ) ?stat_bin para mais informações sobre os mais de 20 stats. 5.4.3.2 Ajustes de Posição Você também pode colorir as barras do gráficos utilizando o argumento estético color ou fill. ggarrange(ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, colour = cut)), ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut))) Se alternar e coloar fill=clarity as barras ficam empilhadas. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity)) O empilhamento acontece automaticamente pelo ajuste de posição. Se você não quiser o gráfico empilhado, pode usar ma outra opção como identity, dodge ou fill. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity), position = &quot;dodge&quot;) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity), position = &quot;identity&quot;) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity), position = &quot;fill&quot;) ggarrange(ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + geom_bar(alpha = 1/5, position = &quot;identity&quot;), ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + geom_bar(fill = NA, position = &quot;identity&quot;), ncol=2) Para gráficos de dispersão podemos utilizar position=jitter que adiciona um pouco de ruído no espalhamento dos pontos. ggarrange(ggplot(data=mpg)+ geom_point(mapping=aes(x=displ, y=hwy)), ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), position = &quot;jitter&quot;)) Para saber mais sobre ajuste de posição ?position_dodge,?position_fill,?position_identity,?position_jitter,?position_stack. 5.4.4 Sistema de coordenadas O sistema de coordenadas padrão do ggplot2 é cartesiano (x e y agem independentemente para encontrar a localização de cada ponto). cord_flip alterna os eixos x e y. ggarrange(ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot(), ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() + coord_flip()) coord_quickmap() ajusta a tela para mapas. nz &lt;- map_data(&quot;nz&quot;) ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, colour = &quot;black&quot;) ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, colour = &quot;black&quot;) + coord_quickmap() Experimente alternar os temas. gg&lt;-ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, colour = &quot;black&quot;)+ coord_quickmap() gg + theme_light() gg + theme_minimal() gg + theme_classic() coord_polar() usa coordendas polares. bar &lt;- ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL) ggarrange(bar + coord_flip(), bar + coord_polar()) 5.4.5 Rótulos 5.4.5.1 Título, subtítulo e caption (canto inferior direito). ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = FALSE) + labs(title = &quot;Fuel efficiency generally decreases with engine size&quot;) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = FALSE) + labs( title = &quot;Fuel efficiency generally decreases with engine size&quot;, subtitle = &quot;Two seaters (sports cars) are an exception because of their light weight&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Podemos tambpem usar labs() para renomear os eixos. ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_smooth(se = FALSE) + labs( x = &quot;Engine displacement (L)&quot;, y = &quot;Highway fuel economy (mpg)&quot;, colour = &quot;Car type&quot; ) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 5.4.5.2 Anotações Podemos rotular as observações do gráfico com geom_text(). best_in_class &lt;- mpg %&gt;% group_by(class) %&gt;% filter(row_number(desc(hwy)) == 1) ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_text(aes(label = model), data = best_in_class) Melhorando a visualização 1. ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_label(aes(label = model), data = best_in_class, nudge_y = 2, alpha = 0.5) Melhorando a visualização 2. ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_point(size = 3, shape = 1, data = best_in_class) + ggrepel::geom_label_repel(aes(label = model), data = best_in_class) Alterando os rótulos das legendas (legend.position=none). Rótulos diretamente no gráfico. class_avg &lt;- mpg %&gt;% group_by(class) %&gt;% summarise( displ = median(displ), hwy = median(hwy) ) ggplot(mpg, aes(displ, hwy, colour = class)) + ggrepel::geom_label_repel(aes(label = class), data = class_avg, size = 6, label.size = 0, segment.color = NA ) + geom_point() + theme(legend.position = &quot;none&quot;) Adicionando um único rótulos aos gráficos (geom_text()). Note o ajuste de hjust e vjust. label &lt;- mpg %&gt;% summarise( displ = max(displ), hwy = max(hwy), label = &quot;Increasing engine size is \\nrelated to decreasing fuel economy.&quot; ) ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_text(aes(label = label), data = label, vjust = &quot;top&quot;, hjust = &quot;right&quot;) # Texto exatamente nas bordas use -inf e +Inf label &lt;- tibble( displ = Inf, hwy = Inf, label = &quot;Increasing engine size is \\nrelated to decreasing fuel economy.&quot; ) ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_text(aes(label = label), data = label, vjust = &quot;top&quot;, hjust = &quot;right&quot;) 5.4.6 Eixos Podemos alterar os eixos e os intervalos dos eixos (x e y). No exemplo abaixo vamos utilizar scale_y_continuous para habilitar a edição do eixo y e determinar seus limites (limits=) e intervalos (breaks). p&lt;-ggplot(mpg, aes(displ, hwy)) + geom_point() + scale_y_continuous(breaks = seq(5,45,5), limits = c(5,45)) p Para adicionar um eixo y secundário precisamos utilizar o argumento sec.axis dentro de scale_y_continuous. p &lt;- ggplot(mpg, aes(x = displ))+ geom_point(aes(y = hwy, colour = &quot;hwy&quot;))+ geom_line(aes(y = cty, colour = &quot;cty&quot;))+ scale_y_continuous(sec.axis = sec_axis(~ . , name = &quot;cty&quot;, seq(1,1000,10)))+ scale_colour_manual(values = c(&quot;green&quot;, &quot;red&quot;))+ labs(y = &quot;hwy&quot;,x = &quot;displ&quot;,colour = &quot;Legenda&quot;)+ theme(legend.position = c(0.8, 0.9)) p 5.4.7 Escalas Uma outra forma de melhorar o aspecto de nosso gráfico é alterando as escalas que são automaticamente geradas. breaks() e label.breaks() controlam a posição das marcas ou os valores associados. ggarrange(ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)), ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + scale_x_continuous() + scale_y_continuous() + scale_colour_discrete(), ggplot(mpg, aes(displ, hwy)) + geom_point() + scale_y_continuous(breaks = seq(15, 40, by = 5)), ncol=2) ## $`1` ## ## $`2` ## ## attr(,&quot;class&quot;) ## [1] &quot;list&quot; &quot;ggarrange&quot; Pode determinar labels=NULL para omitir os rótulos. ggplot(mpg, aes(displ, hwy)) + geom_point() + scale_x_continuous(labels = NULL) + scale_y_continuous(labels = NULL) breaks() também pode destacar exatamente onde as observações ocorreram. # Quando cada presidente americano começou e terminou seu mandato presidential %&gt;% mutate(id = 33 + row_number()) %&gt;% ggplot(aes(start, id)) + geom_point() + geom_segment(aes(xend = end, yend = id)) + scale_x_date(NULL, breaks = presidential$start, date_labels = &quot;&#39;%y&quot;) 5.4.8 layout da legenda Para controlar a posição da legenda precismos da função theme() que controla as partes sem dados do gráfico. legend.position()controla onde a legenda será desenhada. base &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) ggarrange(base + theme(legend.position = &quot;left&quot;), base + theme(legend.position = &quot;top&quot;), base + theme(legend.position = &quot;bottom&quot;), base + theme(legend.position = &quot;right&quot;),ncol=2, nrow=2) # the default Para controlar a exibição das legendas use guides() junto de gui_legend() ou guide_colorbar(). O exemplo abaixo temos nrow=1 controla número de linhas da legenda. ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_smooth(se = FALSE) + theme(legend.position = &quot;bottom&quot;) + guides(colour = guide_legend(nrow = 1, override.aes = list(size = 4))) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 5.4.8.1 Substituindo uma escala. Se vezes não queremos ajustar uma escala, mas queremos substituí-la. Temos abaixo a relação de carat e price em escala logarítimica facilitando a visualização. ggarrange(ggplot(diamonds, aes(carat, price)) + geom_bin2d(), ggplot(diamonds, aes(log10(carat), log10(price))) + geom_bin2d(),ncol=2) A desvantagem é que os eixos estão rotulados com os valores transformados. Assim, em vez de fazer trasnformação no mapeamentos podemos fazê-la na escala. ggplot(diamonds, aes(carat, price)) + geom_bin2d() + scale_x_log10() + scale_y_log10() Outra escala frequentemente customizada é a cor. ggarrange(ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = drv)), ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = drv)) + scale_colour_brewer(palette = &quot;Set1&quot;), ncol=2) ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = drv, shape = drv)) + scale_colour_brewer(palette = &quot;Set1&quot;) presidential %&gt;% mutate(id = 33 + row_number()) %&gt;% ggplot(aes(start, id, colour = party)) + geom_point() + geom_segment(aes(xend = end, yend = id)) + scale_colour_manual(values = c(Republican = &quot;red&quot;, Democratic = &quot;blue&quot;)) 5.4.9 Dando zoom Há 3 formas de controlar os limites do gráfico. 1 - ajustando os dados do gráfico. 2 - Configurando limites em cada escala. 3 - Configurando xlim e ylimem coord_cartesian()). ggplot(mpg, mapping = aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth() + coord_cartesian(xlim = c(5, 7), ylim = c(10, 30)) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; mpg %&gt;% filter(displ &gt;= 5, displ &lt;= 7, hwy &gt;= 10, hwy &lt;= 30) %&gt;% ggplot(aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Extraindo classes de carro e fazendo gráficos delas separadamente deixa difícil a comparação uma vez que cada um tem sua escala. suv &lt;- mpg %&gt;% filter(class == &quot;suv&quot;) compact &lt;- mpg %&gt;% filter(class == &quot;compact&quot;) ggarrange(ggplot(suv, aes(displ, hwy, colour = drv)) + geom_point(), ggplot(compact, aes(displ, hwy, colour = drv)) + geom_point(), ncol=2) Podemos superar isso formatando as escalas com os limites de todos os gráficos. x_scale &lt;- scale_x_continuous(limits = range(mpg$displ)) y_scale &lt;- scale_y_continuous(limits = range(mpg$hwy)) col_scale &lt;- scale_colour_discrete(limits = unique(mpg$drv)) ggplot(suv, aes(displ, hwy, colour = drv)) + geom_point() + x_scale + y_scale + col_scale ggplot(compact, aes(displ, hwy, colour = drv)) + geom_point() + x_scale + y_scale + col_scale 5.5 Para mais informações utilize o Google ou os documentos abaixo Articles - ggpubr: Publication Ready Plots ggplot2 Quick Reference: geom gganimate r-grph-gallery-ggplot2 GRÁFICOS COM GGPLOT2 O Que é ggplot2? ggplot2 esquisse R is Getting an Official Pipe Operator My aversion to pipes Draw Composition of Plots Using the patchwork Package in R (3 Examples) A. Kassambara (2019) References "],["rmarkdown.html", "Capítulo 6 RMarkdown 6.1 Fontes 6.2 Formatação de texto 6.3 Variando Cores 6.4 Inline 6.5 Fórmulas Matemáticas 6.6 Matriz 6.7 Tabelas 6.8 Listas 6.9 Criando links 6.10 Comandos R 6.11 Dica de leitura 6.12 Bibliografia", " Capítulo 6 RMarkdown Assista este conteúdo em Cap 5 - RMarkdown no PVANet O conteúdo apresentado aqui não será apresentado corretamente no material online. Para saber o real output veja o arquivo gerado R-Markdown—Kit-de-Sobrevivência.pdf. `— title: “R Markdown - Kit de Sobrevivência” author: “Jackson Rodrigues” date: “30 março, 2023” output: pdf_document: toc: true toc_depth: 3 number_sections: true line-height: 1.5em fontsize: 12pt link-citations: yes font-family: times new roman biblio-style: apalike subtitle: O mínimo que você precisa saber para gerar um .pdf bibliography: book.bib —` O RMarkdown é uma excelente ferramenta para comunicação e compartilhamento de informações. Nele podemos combinar textos, códigos, resultados (gráficos e tabelas) que permitirão outro usuário repetir passo a passo tudo que foi desenvolvido por você. Isso facilita muito, pois você não precisa enviar scripts cheios de comentários mais os dados utilizados. Você pode selvar os dados numa nuvem e deixar o link para leitura no seu arquivo. Os arquivos de saída do RMarkdown são diversos. Podemos ter saída em .pdf, .ppt, .doc., .html e etc. Podemos também contruir sites, blogs e escrever nossos artigos, teses e dissertações utilizando o RMarkdown. A estrutura inicial é bastante simples, mas vai complicando à medida que avançamos no conteúdo. Da mesma maneira que a produção gráfica é veloz e com uma infinidade de recursos, temos no RMarkdown o mesmo comportamento. Por isso, não se preocupe em decorar os comandos, aos poucos eles serão assimilados por você. O importante é saber o que você quer fazer e utilizar os recursos de ajuda com eficiência. Por isso vamos ver o básico de sobrevivência no RMarkdown, mas se quiser se aprofundar no conteúdo você pode ler Allaire et al. (2020), Xie, Allaire, and Grolemund (2021), Xie, Dervieux, and Riederer (2020), Xie (2015) ou H. Wickham and Grolemund (2019). install.packages(&quot;rmarkdown&quot;) library(rmarkdown) Vá em new file e escolha R Markdown.... Abrirá um pop up em sua tela onde você já pode definir algumas coisas como título, autor e formato a ser exportado. Para facilitar, deixe do jeito que está e dê OK. A nova aba aberta já é um template RMarkdown pronto para ser executado. Nele já temos as estruturas básicas que compõem o básico para produção de um arquivo como YAML, textos, chunks e alguns definidores de títulos. Com estes elementos já podemos gerar relatórios. Basta clicar em Knit que o arquivo ( YAML, chunks, equações, textos, códigos e etc) será processado no knitr gerando um arquivo .md que será processao pelo pandoc que vai fazer a conversão para, no nosso caso, um html. rmarkdown flow PC 6.1 Fontes # Título ## Subtítulo (2x menor) ### Subsubtítulo (3x menor) #### Subsubsubsubsubtítulo (4x menor) ##### Subsubsubsubsubtítulo (5x menor) ###### Subsubsubsubsubsubtítulo (6x menor) 6.2 Formatação de texto ~~Tachado~~: Tachado *Itálico* ou _Itálico_: Itálico **Negrito** ou __Negrito__: Negrito “A vingança nuca é plena, mata a alma e envenena.” Madruga, Seu “O trabalho não é ruim. Ruim é ter de trabalhar!” Madruga, Seu \\tiny Texto 1 –&gt; Texto 1 \\scriptsize Texto 2 –&gt; Texto 2 \\footnotesize Texto 3 –&gt; Texto 3 \\small Texto 4 –&gt; Texto 4 \\normalsize Texto 5 –&gt; Texto 5 \\large Texto 6 –&gt; Texto 6 \\Large Texto 7 –&gt; Texto 7 \\LARGE Texto 8 –&gt; Texto 8 \\huge Texto 9 –&gt; Texto 9 \\Huge Texto 10 –&gt; Texto 10 6.3 Variando Cores \\textcolor{red}{vermelho} –&gt; \\textcolor{blue}{azul} –&gt; \\textcolor{green}{verde} –&gt; 6.4 Inline Utilize cráse antes e depois da palavra que deseja que se pareça com código \\(`head`\\). Para você obter os primeiros dados de um vetor usar a função head(). 6.5 Fórmulas Matemáticas Para incluírmos as fórmulas matemáticas no documento, usar $$ LaTeX $$ (bloco) ou $ LaTeX $ (na linha) 6.5.1 Soma $$a+b$$ → \\(a+b\\) 6.5.2 Subtração $a-b$ → \\(a-b\\) 6.5.3 Multiplição $$a \\times b$$ → \\[a \\times b\\] 6.5.4 Divisão $$a/b$$ → \\[a/b\\] ou $\\frac{a}{b}$ → \\(\\frac{a}{b}\\) 6.5.5 Potenciação $a^b$ → \\(a^b\\) 6.5.6 Raiz Quadrada $$\\sqrt{a}$$ → \\[\\sqrt{a}\\] 6.5.7 Raiz Quadrada de fração $\\sqrt{\\frac{a}{b}}$ → \\(\\sqrt{\\frac{a}{b}}\\) 6.5.8 Subscrito $x_{a_b}$ → \\(x_{a_b}\\) 6.5.9 Sobrescrito $x^{y^z}$ → \\(x^{y^z}\\) 6.5.10 Conjunto $\\mathbb{N} = \\{1, 2,\\ldots\\}$ → \\(\\mathbb{N} = \\{1, 2,\\ldots\\}\\) 6.6 Matriz 6.6.1 Matriz 1 x 4 $$ \\begin{matrix} 0.8944272 &amp; 0.4472136 -0.4472136 &amp; -0.8944272 \\end{matrix} $$ \\[ \\begin{matrix} 0.8944272 &amp; 0.4472136 -0.4472136 &amp; -0.8944272 \\end{matrix} \\] 6.6.2 Matriz 2 x 2 $$ \\begin{matrix} 0.8944272 &amp; 0.4472136\\\\ -0.4472136 &amp; -0.8944272 \\end{matrix} $$ \\[ \\begin{matrix} 0.8944272 &amp; 0.4472136\\\\ -0.4472136 &amp; -0.8944272 \\end{matrix} \\] 6.6.3 Matriz 2 x 2 entre parênteses $$ \\begin{pmatrix} 0.8944272 &amp; 0.4472136\\\\ -0.4472136 &amp; -0.8944272 \\end{pmatrix} $$ \\[ \\begin{pmatrix} 0.8944272 &amp; 0.4472136\\\\ -0.4472136 &amp; -0.8944272 \\end{pmatrix} \\] Experimente também vbmatrix, Bmatrix, vmatrix, Vmatrix. Veja mais em matrizes. $$ \\left(\\begin{array}{cc} 0.8944272 &amp; 0.4472136\\\\ -0.4472136 &amp; -0.8944272 \\end{array}\\right) \\left(\\begin{array}{cc} 10 &amp; 0\\\\ 0 &amp; 5 \\end{array}\\right) $$ \\[ \\left(\\begin{array}{cc} 0.8944272 &amp; 0.4472136\\\\ -0.4472136 &amp; -0.8944272 \\end{array}\\right) \\left(\\begin{array}{cc} 10 &amp; 0\\\\ 0 &amp; 5 \\end{array}\\right) \\] 6.7 Tabelas | delimitam as colunas - delimitam os títulos : Define o alinhamento que por padrão é a esquerda ìtem Produto Valor 1 Arroz R$ 31,00 2 Feijão R$ 9,00 3 Kinder Ovo R$ 2.500,00 6.8 Listas 6.8.1 Lista ordenada Arroz Feijão Batata 6.8.2 Lista não ordenada Lichia Pistache Pitaya 6.8.3 Sublista Refrigerante preto Batata frita Podrão 2 Hambúrgueres Alface Queijo Molho especial Cebola Picles Pão com Gergelim 6.9 Criando links Para criar links, é só envolver o texto a ser exibido por colchetes [ ] e o link entre parênteses ( ). \\([UFV](https://www.ufv.br/)\\) fica assim → UFV ou colocar o link direto entre &lt;&gt; assim \\(&lt;https://www.ufv.br/&gt;\\) fica assim → https://www.ufv.br/. 6.10 Comandos R Sempre que precisar adicionar códigos a serem executados dentro do seu Rmarkdown você deve obedecer algumas regras. Seu código deve ficar dentro de um chunk. Veja que iniciamos è finalizamos com aspas simples triplas (```) seguindo de r dentro de chaves { }. Após o r podemos ainda adicionar argumentos como o nome do chunk e outros comandos. É altamente recomendado que nomeie os chunks com nomes intuitivos para o que está sendo executado. Isso failita muito a navegação e execução. ```{r} Comandos a serem executados ``` ```` library(magrittr) Notas &lt;- read.table(&quot;J:/ENG 792/ENG_792-AVDR/Cap_5_Notas_ENG792.txt&quot;, header = T, sep=&quot;,&quot;, dec=&quot;.&quot;,skip=3, encoding = &quot;UTF-8&quot;) Notas %&gt;% knitr::kable() Nome Nota.1 Nota.2 Nota.3 Nota.4 A 10.9 60.9 53.6 12.0 B 71.3 9.9 13.9 47.0 C 65.9 0.3 28.9 55.0 D 3.6 70.0 37.9 75.3 E 70.9 81.9 43.9 8.6 F 76.9 53.0 29.9 38.6 G 73.6 2.3 23.0 37.3 H 2.0 88.0 10.3 28.3 I 25.3 11.9 12.3 26.3 J 7.0 19.3 82.9 46.3 K 52.0 41.0 70.3 31.6 L 27.3 74.0 47.6 18.9 M 87.9 75.9 17.9 80.6 N 76.0 47.9 2.0 19.6 O 55.0 60.6 51.9 24.0 P 76.6 47.9 90.3 55.6 Q 10.3 55.9 18.0 86.3 R 17.0 0.9 43.3 14.6 S 38.6 22.6 23.6 6.6 T 69.0 31.9 75.3 90.6 U 26.9 3.6 65.3 48.6 X 56.6 32.0 74.6 28.0 Y 22.3 42.3 88.9 65.0 Z 36.6 44.3 17.9 23.9 Dê uma olhada em R Markdown Cheat Sheet library(ggplot2) library(ggpubr) bar &lt;- ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL) ggarrange(bar + coord_flip(), bar + coord_polar()) A média de count é 9.5. 6.11 Dica de leitura knitr Pandoc Aligning equations with amsmath R Markdown: The Definitive Guide Knitr texblog R for Data Science R Markdown Exploratory Data Analysis with R An Oxford University Thesis Template for R Markdown How to customize font size in R Markdown documents Customizing Fonts and Appearance Style your apps with CSS XsPDF APOSTILA DE LATEX R Markdown Cookbook R Markdown Basics Markdown Dominando RMarkdown YAML PDF Document pdf_document settings YAML HMTL Document pdf_document settings 6.12 Bibliografia References "],["elementos-de-estatística-básica-no-r.html", "Capítulo 7 Elementos de estatística básica no R 7.1 Parte 1 7.2 Parte 2", " Capítulo 7 Elementos de estatística básica no R 7.1 Parte 1 Assista este conteúdo em Cap 6 - Parte 1 no PVANet Sempre que nos apoderamos de uma banco de dados antes de qualquer coisa precisamos entender o que eles guardam. Precisamos explorá-los e tentar extrair informações que possam representar os padrões ou ausência de padrões ou a variância dentro destes bancos de dados. Vários métodos podem ser utilizados para extrair informações de um banco de dados. Podemos começar métodos mais simples e ir aumentando a complexidade a medida que vamos aprofundando nosso conhecimento sobre nosso banco de dados. Para tirar conclusões ou fazer inferências precisaremos ir além dos métodos de descrição dos dados. No entanto, vamos inicialmente lançar mão em métodos de estatístrica descritiva. Como fazer isso no R? 7.1.1 Estatística Descritiva De acordo com Mello and Peternelli (2013) estatística descritiva, como o próprio nome sugere, descreve e avalia certo grupo de dados, seja ele população ou amostra. Os autores ainda argumentam que temo na estatística descritva temos o método numérico e o método gráfico. Vamos da uma olhada nos dados de consumo de cigarro nos Estados Unidos por ano. Do jeito que a tabela está apresentada, ela pouco nos informa a respeito do comportamento dos dados. Mal podemos vê-la por completo deixando qualquer tentativa de sumarizar informações bastante frustrante. Cons.Ciga&lt;-read.csv(&quot;https://vincentarelbundock.github.io/Rdatasets/csv/Ecdat/Cigar.csv&quot;, header = T, row.names = 1) str(Cons.Ciga) ## &#39;data.frame&#39;: 1380 obs. of 9 variables: ## $ state: int 1 1 1 1 1 1 1 1 1 1 ... ## $ year : int 63 64 65 66 67 68 69 70 71 72 ... ## $ price: num 28.6 29.8 29.8 31.5 31.6 35.6 36.6 39.6 42.7 42.3 ... ## $ pop : num 3383 3431 3486 3524 3533 ... ## $ pop16: num 2236 2277 2328 2370 2394 ... ## $ cpi : num 30.6 31 31.5 32.4 33.4 34.8 36.7 38.8 40.5 41.8 ... ## $ ndi : num 1558 1684 1810 1915 2024 ... ## $ sales: num 93.9 95.4 98.5 96.4 95.5 ... ## $ pimin: num 26.1 27.5 28.9 29.5 29.6 32 32.8 34.3 35.8 37.4 ... library(rmarkdown) paged_table(Cons.Ciga) Se tentarmos graficamente já dá uma melhorada, mas ainda não atender todas as expectativas. par(mfrow=c(3,3), mar=c(2,2,1.5,1.5)) for(i in 1:ncol(Cons.Ciga)){ plot(Cons.Ciga[,i], col=i+1, type=&quot;l&quot;, main=colnames(Cons.Ciga[i])) } No entanto podemos começar buscando métodos “simples” de retirar informações. 7.1.1.1 Medidas de tendência central 7.1.1.1.1 Média A média das observações é a famosa soma dos valores dividido pelo número de observações. A função mean() calcula média de um vector. Caso queira médias por variáveis ou observações você pode utilizar colMeans(). (20+31+54+78+12)/5 ## [1] 39 mean(c(20,31,54,78,12)) ## [1] 39 mean(Cons.Ciga$price) ## [1] 68.69993 colMeans(Cons.Ciga) ## state year price pop pop16 cpi ndi ## 26.82609 77.50000 68.69993 4537.11319 3366.61609 73.59667 7525.02302 ## sales pimin ## 123.95087 62.89928 media.linhas&lt;-as.matrix(rowMeans(Cons.Ciga)) plot(media.linhas, type=&quot;l&quot;) paged_table(as.data.frame(media.linhas)) Se você quiser apenas a soma use sum(), rowSums e colSums(). (20+31+54+78+12) ## [1] 195 sum(c(20,31,54,78,12)) ## [1] 195 sum(Cons.Ciga$price) ## [1] 94805.9 colSums(Cons.Ciga) ## state year price pop pop16 cpi ndi ## 37020.0 106950.0 94805.9 6261216.2 4645930.2 101563.4 10384531.8 ## sales pimin ## 171052.2 86801.0 Soma.linhas&lt;-as.matrix(rowSums(Cons.Ciga)) plot(Soma.linhas, type=&quot;l&quot;) paged_table(as.data.frame(Soma.linhas)) 7.1.1.1.2 Média Aparada No mundo real, em dados observados, muitas vezes encontramos dados que fogem do padrão dos outros elementos. Imagine que você coletou um banco de dados com os seguintes valores. -435, 34, 20, 18, 33, 26, 27, 29, 31, 19 Há algo de estranho com esse -435. Ele provavelmente é um outlier, um valor que foi de maneira equivocada coletado por falha do pesquisador ou falha no equipamento. De acordo com Navarro (2013) quando encaramos esse tipo de condição com valores extremos no meio de nossos dados, uma média aritmética não é o método mais indicado, pois ela sofre muita influêncioa dos valores extremos. Para casos como esses podemos calcular uma mediana ou uma média aparada. Para calcular uma média aparada vamos descartar os valores extremos preservando os valores “reais” ou “corretos” de nossas observações. Tendo as características preservadas em nosso banco de dados poderemos então partir para análises mais sofisticadas. A média aparada é descrita em termos de porcentagem de observações. Por exemplo, uma média aparada em 10% descarta os 10% dos dados maiores e os 10% menores calculando assim a média aritmética dos 80% restantes. Para calcular a média aparada no R utilize o argumento trim=x (x é uma valor que vai de 0.0 (0%) até 1 (100%)) dentro com comando mean(). set.seed(1234) temp&lt;-c(-100,runif(n=10, min = 20, max = 38)) temp ## [1] -100.00000 22.04666 31.20139 30.96695 31.22083 35.49648 ## [7] 31.52559 20.17092 24.18591 31.98951 29.25652 mean(temp) ## [1] 17.09643 mean(temp, trim=0.0) ## [1] 17.09643 mean(temp, trim=0.1) ## [1] 28.0627 7.1.1.1.3 Mediana Medida utilizada para indicar o centro de um conjunto de dados ou o valor intermediário. Se n for ímpar a posição da mediana será (n+1)/2. Em 9, 25, 36, 49, 49 a mediana é 36. Se n for par, a mediana será a média aritmética dos valores que ocupam as posições n/2 e n/2+1. Em 9, 25, 35, 36, 49, 49 a mediana é 35.5. A mediana é uma medida útil quando temos valores extremos discrepantes dos demais (Mello and Peternelli (2013)). No R pode ser alcançada utilizando o comando median(). median(c(9, 25, 36, 49, 49)) ## [1] 36 median(c(9, 25, 35, 36, 49, 49)) ## [1] 35.5 for(i in 1:ncol(Cons.Ciga)){ print(noquote(paste(c(&#39;Mediana de&#39;, colnames(Cons.Ciga[i]), &#39;é&#39;, round(median(Cons.Ciga[,i]),digits=2))))) } ## [1] Mediana de state é 26.5 ## [1] Mediana de year é 77.5 ## [1] Mediana de price é 52.3 ## [1] Mediana de pop é 3174 ## [1] Mediana de pop16 é 2315.3 ## [1] Mediana de cpi é 62.9 ## [1] Mediana de ndi é 6281.2 ## [1] Mediana de sales é 121.2 ## [1] Mediana de pimin é 46.4 par(mfrow=c(3,3),mar=c(2,2,1.5,1.5)) for(i in 1:ncol(Cons.Ciga)){ (boxplot(Cons.Ciga[,i], main=colnames(Cons.Ciga[i]))) } 7.1.1.1.4 Moda Um conjunto de dados pode ser unimodal, bimodal ou amodal. A moda pode ser usada para indicar tendência central de um conjunto de observações (moda amostral). No R podemos calcular a moda pela utilização da função mfv() ou mfv1() de alguns pacotes como modeest ou criar uma função para isso uma vez que não conhecemos uma função nativa que calcule a moda. #install.packages(&quot;modeest&quot;) library(modeest) ## Registered S3 method overwritten by &#39;rmutil&#39;: ## method from ## print.response httr # Atenção, pois `mfv()` e `mfv1()`produzem resultados diferentes. for(i in 1:ncol(Cons.Ciga)){ print(noquote(paste(c(&#39;A moda de&#39;, colnames(Cons.Ciga[i]), &#39;é&#39;, round(mfv1(Cons.Ciga[,i]),digits=2))))) } ## [1] A moda de state é 1 ## [1] A moda de year é 63 ## [1] A moda de price é 30.1 ## [1] A moda de pop é 703 ## [1] A moda de pop16 é 523.3 ## [1] A moda de cpi é 30.6 ## [1] A moda de ndi é 13318 ## [1] A moda de sales é 122.3 ## [1] A moda de pimin é 30.1 #Criando a própria função para MODA moda &lt;- function(v) { uniqv &lt;- unique(v) uniqv[which.max(tabulate(match(v, uniqv)))] } for(i in 1:ncol(Cons.Ciga)){ print(noquote(paste(c(&#39;A moda de&#39;, colnames(Cons.Ciga[i]), &#39;é&#39;, round(moda(Cons.Ciga[,i]),digits=2))))) } ## [1] A moda de state é 1 ## [1] A moda de year é 63 ## [1] A moda de price é 30.1 ## [1] A moda de pop é 703 ## [1] A moda de pop16 é 559.3 ## [1] A moda de cpi é 30.6 ## [1] A moda de ndi é 13318 ## [1] A moda de sales é 122.3 ## [1] A moda de pimin é 30.1 Temos também a função maxFreq()que retorna a frequência modal. #install.packages(&quot;lsr&quot;) library(lsr) seleções.campeãs&lt;-as.factor(c(&quot;Uruguai&quot;,&quot;Itália&quot;,&quot;Itália&quot;,&quot;Sem Copa&quot;,&quot;Sem Copa&quot;,&quot;Uruguai&quot;,&quot;Alemanha&quot;,&quot;Brasil&quot;, &quot;Brasil&quot;,&quot;Inglaterra&quot;,&quot;Brasil&quot;,&quot;Alemanha&quot;,&quot;Argentina&quot;,&quot;Itália&quot;,&quot;Argentina&quot;, &quot;Alemanha&quot;,&quot;Brasil&quot;,&quot;França&quot;,&quot;Brasil&quot;,&quot;Itália&quot;,&quot;Espanha&quot;,&quot;Alemanha&quot;,&quot;França&quot;)) table(seleções.campeãs) ## seleções.campeãs ## Alemanha Argentina Brasil Espanha França Inglaterra Itália ## 4 2 5 1 2 1 4 ## Sem Copa Uruguai ## 2 2 modeOf(seleções.campeãs) # Mostra a moda (aquele que mais se repete) ## [1] &quot;Brasil&quot; maxFreq(seleções.campeãs) # Mostra a frequência daquele que mais se repete ## [1] 5 7.1.1.2 Medidas de Variabilidade 7.1.1.2.1 Amplitude É simplesmente a diferença entre o maior e menor valor dentro de um conjunto de dados. Podemos utilizar os comandos max() e min() para acessar os valores máximos e mínimos do conjunto de dados ou range() que mostra os dois valores (máximo e mínimo) ao mesmo tempo. max(Cons.Ciga$price)-min(Cons.Ciga$price) ## [1] 178.5 range(Cons.Ciga$price) ## [1] 23.4 201.9 range(Cons.Ciga$price)[2] ## [1] 201.9 range(Cons.Ciga$price)[1] ## [1] 23.4 range(Cons.Ciga$price)[2]-range(Cons.Ciga$price)[1] ## [1] 178.5 for(i in 1:ncol(Cons.Ciga)){ print(noquote(paste(c(&#39;A Amplitude de&#39;, colnames(Cons.Ciga[i]), &#39;é&#39;, round(max(Cons.Ciga[,i])-min(Cons.Ciga$price),digits=2))))) } ## [1] A Amplitude de state é 27.6 ## [1] A Amplitude de year é 68.6 ## [1] A Amplitude de price é 178.5 ## [1] A Amplitude de pop é 30679.9 ## [1] A Amplitude de pop16 é 22896.6 ## [1] A Amplitude de cpi é 116.9 ## [1] A Amplitude de ndi é 23050.6 ## [1] A Amplitude de sales é 274.5 ## [1] A Amplitude de pimin é 155.1 7.1.1.2.2 Classificação percentil A classificação percentil de um dado qualquer define a porcentagem dos casos em uma distribuição que se enquandram naquele valor ou abaixo dele. Imagine que temos as seguintes notas de um conjunto de alunos e queremos saber quantas notas ficaram dentro de 60% total das notas. Podemos proceder com classificação percentil utilizando quantile(x=, probs = ). 94, 92, 91, 88, 85, 84, 80, 79, 77, 76, 74, 74, 71, 69, 65, 62, 56, 53, 48, 40 notas&lt;-c(94, 92, 91, 88, 85, 84, 80, 79, 77, 76, 74, 74, 71, 69, 65, 62, 56, 53, 48, 40) quantile(x = notas, probs = .60) ## 60% ## 77.8 quantile( x = Cons.Ciga$price, probs = .50) ## 50% ## 52.3 print(noquote(paste(c(&#39;Observamos que 50% das estão abaixo de&#39;,(quantile(x = Cons.Ciga$price, probs = .50)[[1]]),&quot;.&quot;)))) ## [1] Observamos que 50% das estão abaixo de ## [2] 52.3 ## [3] . 7.1.1.2.3 Variação interquartil A variação interquartil (IQR - Interquartile range) mede a amplitude entre os quartis 1 (contém 25% dos dados) e 3 (contém 75% dos dados). quantile( x = Cons.Ciga$price, probs = .25) ## 25% ## 34.775 quantile( x = Cons.Ciga$price, probs = .75) ## 75% ## 98.1 quantile( x = Cons.Ciga$price, probs = c(0.25,0.75)) ## 25% 75% ## 34.775 98.100 library(mosaic) ## Registered S3 method overwritten by &#39;mosaic&#39;: ## method from ## fortify.SpatialPolygonsDataFrame ggplot2 ## ## The &#39;mosaic&#39; package masks several functions from core packages in order to add ## additional features. The original behavior of these functions should not be affected by this. ## ## Attaching package: &#39;mosaic&#39; ## The following object is masked from &#39;package:Matrix&#39;: ## ## mean ## The following objects are masked from &#39;package:dplyr&#39;: ## ## count, do, tally ## The following objects are masked from &#39;package:analogue&#39;: ## ## compare, mat ## The following object is masked from &#39;package:permute&#39;: ## ## shuffle ## The following object is masked from &#39;package:purrr&#39;: ## ## cross ## The following object is masked from &#39;package:ggplot2&#39;: ## ## stat ## The following objects are masked from &#39;package:stats&#39;: ## ## binom.test, cor, cor.test, cov, fivenum, IQR, median, prop.test, ## quantile, sd, t.test, var ## The following objects are masked from &#39;package:base&#39;: ## ## max, mean, min, prod, range, sample, sum IQR(x = Cons.Ciga$price ) ## [1] 63.325 par(mar=c(0.5, 4, 0.2, 0.2), mfrow=c(2,1), oma = c(4, 4, 0.2, 0.2)) boxplot(Cons.Ciga$price, ylim=c(min(0), max(Cons.Ciga$price)), xlab = &quot;&quot;,ylab = &quot;&quot;,col = &quot;orange&quot;,xaxt=&#39;n&#39;, yaxt=&quot;n&quot;,border = &quot;brown&quot;,horizontal = TRUE,notch = TRUE) quant&lt;-quantile(Cons.Ciga$price,probs = c(0.25,0.5,0.75)) plot.ecdf(Cons.Ciga$price, pch = 1, xlim=c(min(0), max(Cons.Ciga$price)), col=&quot;orange&quot;, main=&quot;&quot;,ylab=&quot;&quot;, xlab=&quot;&quot;) mtext(text = &quot;Preço do cigarro&quot;,side = 1,line = 2) mtext(text = &quot;Frequência relativa acumulada&quot;,side = 2,line = 2) segments(-10,0.25,quant[[1]],0.25, col=&quot;blue&quot;,lwd=2) arrows(quant[[1]],0.25,quant[[1]],0, col=&quot;blue&quot;,lwd=2) text(x = -5, y = 0.30, paste0(&quot;Q1 = &quot;,quant[[1]]), cex = 0.8, col = &quot;blue&quot;, family=&quot;mono&quot;, font=2, adj=0) segments(-10,0.5,quant[[2]],0.5, col=&quot;darkviolet&quot;,lwd=2) arrows(quant[[2]],0.5,quant[[2]],0, col=&quot;darkviolet&quot;,lwd=2) text(x = -5, y = 0.60, paste(&quot;Q2 ou \\nMediana = &quot;,quant[[2]]), cex = 0.8, col = &quot;darkviolet&quot;, family=&quot;mono&quot;, font=2, adj=0) segments(-10,0.75,quant[[3]],0.75, col=&quot;red&quot;,lwd=2) arrows(quant[[3]],0.75,quant[[3]],0, col=&quot;red&quot;,lwd=2) text(x = -5, y = 0.8, paste(&quot;Q3 = &quot;,quant[[3]]), cex = 0.8, col = &quot;red&quot;, family=&quot;mono&quot;, font=2, adj=0) text(x = 150, y = 0.4, paste(&quot;Variação \\nInterquartil \\n(IQR) = &quot;,IQR(Cons.Ciga$price)), cex = 1, col = &quot;black&quot;, family=&quot;mono&quot;, font=2, adj=0.5) 7.1.1.2.4 Desvios Até o momento vimos 2 maneiras de medir a dispersão dos dados (amplitude e o variação interquartil). Podemos, baseado em um valor de referência, avaliar a o desvio médio absoluto, que nada mais é do que o somatório das distâncias dos dados em relação à sua média ou mediana. \\[\\begin{align} (X) = \\frac{1}{N} \\sum_{i = 1}^N |X_i - \\bar{X}| \\end{align}\\] Para ser honesto, eu nunca vi isso sendo utilizado como produto final, mas é um passo importante para entender seus dados e as próximas análises a serem desenvolvidas. De acordo com Navarro (2013) a o desvio com base na mediana é melhor que utilizando a média. Mas vamos dar uma olhada em ambas. Primeiramente temos que definir nossa base por exemploe a média. Retornando para nosso exemplo de preços de cigarro temos que a média dos preços é 68.69993. Vamos dar uma olhada nos valores apenas no Quartil 1. No R podemos fazer passo a passo ou utilizando o pacotelsr. library(rmarkdown) mean(Cons.Ciga$price) ## [1] 68.69993 Q1&lt;-subset(Cons.Ciga,price&lt;quant[[1]]) Q1.desv&lt;-abs(Q1$price-(mean(Q1$price))) Desvio&lt;-as.data.frame(cbind(Q1$price,Q1.desv)) colnames(Desvio)&lt;-c(&quot;X&quot;,&quot;X-Xmed&quot;) paged_table((Desvio)) print(mean(Desvio$`X-Xmed`)) # Desvio absoluto médio ## [1] 2.290828 library(lsr) aad(Desvio$X) ## [1] 2.290828 O desvio absoluto médio do primeiro quartil é 2.291. Isto mostra a média das distância entre cada dado do Quatil 1 e a média. 7.1.1.2.5 Variância Diferentemente do desvio médio absoluto, a variância eleva a soma dos desvios ao quadrado. \\[\\begin{align} \\sigma^2 = \\frac{\\sum_{i=1}^{n}(x_i - \\mu)^2} {n} \\end{align}\\] No R podemos fazer passo a passo ou utilizando o comando var(). sum((Desvio$X-mean(Desvio$X))^2/(length(Desvio$X)-1)) ## [1] 7.905433 var(Desvio$X) ## [1] 7.905433 7.1.1.2.6 Desvio Padrão Quando elevamos os desvios ao quadrado criamos um problema, pois mudamos a unidade dos dados originais. Para colocar a medida de variabilidade na escala original, calculamos a raiz quadrada da variância e, com isso, temos o desvio padrão. \\[\\begin{align} \\hat\\sigma = \\sqrt{ \\frac{1}{N-1} \\sum_{i=1}^N \\left( X_i - \\bar{X} \\right)^2 } \\end{align}\\] Mesmo assim a interpretação do desvio padrão é um tanto complexa. Vamos pensar em termos de desviopadrão da média numa distribuição de normal. Quanto mais longe do média, maior o desvio padrão. Como discutido exaustivamente na lista 1, esperamos que aproximadamente 68% dos valores de dados normalmente distribuídos fiquem entre -1 e +1 desvio padrão da média, aproximadamente 95% entre -2 e +2 e paroximadamente 99% entre -3 e +3. Obviamente esta definição se aplica à dados perfeitamente encaixados na distribuição normal, mas no mundo real isso é um pouco mais complexo e quanto menor a amostra pior fica. No R podemos calcular manualmente ou utilizando o comando sd(). Veja abaixo que a distribuição mesocúrtica dos nossos dados de preços de cigarro (linha azul), apenas do 1° quartil, se assemelha à distribuição normal “perfeita” (linha vermelha) principalemnte nos extremos possuindo e excetuando em aproximadamente -1 e + 1 desvio padrão. sqrt(sum((Desvio$X-mean(Desvio$X))^2/(length(Desvio$X)-1))) ## [1] 2.81166 sd(Desvio$X) ## [1] 2.81166 library(tidyverse) Desvio&lt;-Desvio %&gt;% mutate(zscore = (Desvio$X - mean(Desvio$X))/sd(Desvio$X)) head(Desvio) ## X X-Xmed zscore ## 1 28.6 1.18376812 -0.42102104 ## 2 29.8 0.01623188 0.00577306 ## 3 29.8 0.01623188 0.00577306 ## 4 31.5 1.71623188 0.61039803 ## 5 31.6 1.81623188 0.64596420 ## 6 23.9 5.88376812 -2.09263124 plot(density(Desvio$zscore), frame = FALSE, col = &quot;blue&quot;, xlim=c(-3,3),lwd=3, ylim=c(0,0.4),main = &quot;Densidade do Quartil 1&quot;, type=&quot;l&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;) abline(v=mean(Desvio$zscore), col=&quot;blue&quot;, lwd=2,lty=4) par(new=T) x.values = seq(-3,3, length = 345) y.values = dnorm(x.values) plot(x.values, y.values, type=&quot;l&quot;, lty=1, xlab=&quot;&quot;, xlim=c(-3,3),ylim=c(0,0.4), ylab=&quot;&quot;,col=&quot;red&quot;) abline(v=mean(x.values), col=&quot;red&quot;, lwd=2, lty=3) abline(v=c(-1,1), col=&quot;grey&quot;, lwd=2, lty=4) Desv.pad.68.perc&lt;-(Desvio$zscore[(Desvio$zscore &gt;= -1.0) &amp; (Desvio$zscore &lt;= 1.0)]) (length(Desv.pad.68.perc)/length(Desvio$zscore))*100 ## [1] 61.44928 Veja que o preço dos cigarros do 1° quartil entre -1 e +1 desvio padrão ficam em 61.45%. Experimente fazer com toda a amostra. Navarro (2013) faz um resumo interessante sobre quando utilizar cada um das medidas até discutidas. Amplitude: Mostra a dispersão máxima dos dados. É sensível a valores extremos ou outliers sendo utilizada quando queremos avaliar a variação entre os extremos como no caso da temperatura na meteorologia. Variação Interquartil: Excelente método de exploração de dados fornecendo um conjunto de informações de uma só vez principalemnte quando acompanhando de boxplot. Desvio médio absoluto: Mostra quão distante da média as observações estão. Variância: Descreve a variação dos dados ao redor da média com a limitação da dificuldade de interpretação em razão da escala ser diferente dos dados originais. Desvio Padrão: É oe método mais utilizado para medida de variação dos dados. É dado pela raiz quadrada da variância sendo mais simples de interpretar que a variância uma vez que está na mesma unidade de medida que os dados originais. 7.1.2 Leituras complementares Descriptive statistics in R Yamamoto (2020) Kabacoff (2015) 7.2 Parte 2 Assista este conteúdo em Cap 6 - Parte 2 no PVANet 7.2.1 Teste de diferença entre médias Todos os trabalhos que conduzimos necessitam minimamente de algum teste estatístico. Seja ele descritivo, inferencial ou para testar hipóteses. Especificamente no ultimo caso, quando tratamos de experimentos precisamos conduzir testes para indentificar se nossa hipótese é plausível ou não (Mello and Peternelli (2013)). Suponhamos que queremos comprar um fertilizante para nossa lavoura de milho, mas não sabemos se vale a pena. Para decidir qual é o melhor, podemos conduzir experimentos na produção de milho para testá-lo com objetivo de saber se há ganho na produtividade. set.seed(1234) exper&lt;-runif(25, min = 4350, max = 4900) Suponhamos que a produtividade média sem fertilizante seja 4.350 kg ha e com o uso do fertilizante foi 4580.47 kg ha. Podemos dizer que o uso do fertilizante namédia aumentou a produtividade, mas será que vale a pena gastar mais para ter esse aumento? Talvez, talvez não. Não podemos tirar muitas conclusões baseados apenas nestas informações. Poderíamos calcular, as médias (4580.47), a mediana (4516.48), a variância (2.12961^{4}) o desvio padrão (145.93) e todos os outro métodos de análise descritiva que vimos até agora, mas mesmo assim seria inapropriado tomar uma decisão sobre a compra do fertilizante baseando-nos apenas numa medida central. Uma maior segurança em nossa tomada de decisão seria balizada por uma comparação da eficiência do uso de fertilizante com o não uso. Para realizar tal procedimento vamos seguir os passos sugeridos por Freire (2021a): 7.2.1.1 1 - Estabelecer um hipótese a ser testada A hipótese a ser testada é a hipótese nula (\\(H_0\\)) e a hipótese que será confrontada será a hipótese de pesquisa é (\\(H_1\\)). Na hipótese nula assumimos que as médias das amostras ou populações que estamos comparando são iguais e nossa hipótese de pesquisa diz que não são iguais. \\(H_0: \\mu_A = 4.350\\) \\(H_1: \\mu_A \\ne 4.350\\) 7.2.1.2 2 - Decidir qual teste utilizar A partir da hipótese nula podemos decidir qual teste será mais apropriado. No nosso exemplo poderíamos selecionar uma amostra de 25 espigas de milho de cada tratamento e compararmos as médias (kg) das amostras conforme estabelecido pela hipótese nula (\\(H_0\\)). Teremos assim um distribuição t de Student com n-1 graus de liberdade. 7.2.1.3 3 - Selecionar o nível de significância (\\(\\alpha\\)) O nível de \\(\\alpha\\) define a região crítica da distribuição. Com este valor vamos identificar se a diferença amostral é estatísticamente significativa - se é o resultado da diferença de população real, e não apenas um erro amostral. Se o valor da estatística calculada a partir da amostra selecionada cair na região crítica, a hipótese nula (\\(H_0\\)) será rejeitada e ficamos com a hipótese de pesquisa (\\(H_1\\)). Assumimos rejeitamos a hipótese nula se a probabilidade for muito pequena ( por exemplo, menos de 5 em 100), o que significqa que a diferença entre de amostra seria um produto do erro amostral. Caso contrário não a rejeitamos \\(H_0\\). Normalmente os valores de \\(\\alpha\\) são 0.1 (10%), 0.05 (5%) e 0.01 (1%). Cuidado com o termo “aceitar \\(H_0\\)”. O correto é “não rejeitar \\(H_0\\)”. Considerando que a estatística t, definida no passo 2, segue a distribuição t de Student na figura abaixo destacando as regiões críticas Fonte: Freire (2021a) Podemos definir nosso nível de significância em 10%, 5% e 1%. No R podemos calcular com a função qt qt(0.95,24) #0.05 de cada lado ## [1] 1.710882 qt(0.975,24) #0.025 de cada lado ## [1] 2.063899 qt(0.995,24) #0.005 de cada lado ## [1] 2.79694 Desta forma termos nosso nível de significância para 10% igual 1.7108821, para 5% igual 2.0638986 e para 1% igual a 2.7969395. Fonte: Levin, Fox, and Forde (2012) 7.2.1.4 4 - Selecionar a amostra, realizar os cálculos e tomar a decisão Após os passos 1, 2 e 3 procedemos a seleção da amostra do estudo, a partir da qual o valor da estatística será calculado e comparado com os valores críticos. Caso o valor da estatística caia dentro da região crítica do teste, a hipótese nula será rejeitada. Neste caso, dizemos que o resultado do teste é estatisticamente significativo. Caso contrário, ela não será rejeitada e o resultado do teste não é estatisticamente significativo. 7.2.1.5 Tipos de erros inerentes ao testes de hipótese Ao realizarmos os testes estamos sujeitos a comenter 2 tipos erros. ERRO tipo 1: Rejeitar \\(H_0\\) quando \\(H_0\\) é verdadeira. Isto pode acontecer quando extraímos uma amostra da população e a estatística calculada a partir dessa amostra cai na região crítica. Ao fixarmos α, fixamos a probabilidade deste erro. ERRO tipo 2: Não rejeitar \\(H_0\\) quando esta for falsa.Isto acontece quando extraímos uma amostra da população e a estatística calculada a partir dessa amostra cai na região crítica. 7.2.1.6 P-value (Valor P ou P valor) Ao testar uma hipótese podemos a priori dcefinir o nível de significância \\(\\alpha\\). O valor de \\(\\alpha\\) se refere ao tamanho das regiões da extremidade sob a curva que nos levarão a rejeitar a hipótese nula. Ou seja, é a área à direita ou equerda do valor crítico. O valor de P (P value) é a probabilidade exata de se obter dados de uma amostra quando a hipótese nula é verdadeira. Desta forma, o valor de \\(\\alpha\\) é o limiar do qual a probabilidade é considerada tão pequena (P&lt;\\(\\alpha\\)) que decidimos rejeitar a hipótese nula. options(scipen = 999) t.test(exper) ## ## One Sample t-test ## ## data: exper ## t = 156.94, df = 24, p-value &lt; 0.00000000000000022 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## 4520.229 4640.704 ## sample estimates: ## mean of x ## 4580.466 Acima visualizamos o teste bilateral, mas temos também testes unilaterais. Em outros cenários, o interesse pode ser em testar se o desvio em relação à hipótese nula ocorre em somente uma direção. Por exemplo, ao testar um medicamento para reduzir a pressão arterial de pacientes hipertensos, os investigadores estão interessados somente se ocorre uma redução da pressão arterial após o uso do medicamento testado. Se houver um aumento da pressão ou nenhuma alteração no valor da pressão arterial, então o medicamento será considerado ineficaz. Neste caso, sendo μ a variação média do valor da pressão arterial, a hipótese nula será \\(\\mu\\ge0\\) e a hipótese alternativa será \\(\\mu&lt;0\\), ou seja, a hipótese nula será rejeitada somente se a variação média da pressão arterial for menor que o valor crítico, determinado a partir do nível de significância (α) e da distribuição da estatística utilizada. Neste caso, o teste é chamado de teste unilateral (one-sided test). O valor de p será igual à probabilidade, sob a hipótese nula, de se observar um valor da estatística utilizada no teste de hipótese abaixo ou igual ao valor calculado na amostra utilizada no estudo. Como outro exemplo de teste unilateral, agora na direção oposta, em um teste de um medicamento vasodilatador, os investigadores estão interessados somente se ocorre um aumento do diâmetro dos vasos sanguíneos após o uso do medicamento testado. Se houver uma redução ou nenhuma alteração no diâmetro dos vasos, então o medicamento será considerado ineficaz. Neste caso, sendo μ a variação média do valor do diâmetro do vaso sanguíneo, a hipótese nula será \\(\\mu\\le0\\), e a hipótese alternativa será \\(\\mu &gt; 0\\) , ou seja, a hipótese nula será rejeitada somente se a variação média do diâmetro do vaso for maior que o valor crítico, determinado a partir do nível de significância (α) e da distribuição da estatística utilizada. Neste caso, o valor de p será igual à probabilidade, sob a hipótese nula, de se observar um valor da estatística utilizada no teste de hipótese acima ou igual ao valor calculado na amostra utilizada no estudo. 7.2.2 Test t (Student) 7.2.2.1 Para uma média Utilizado para testar a afirmação sobre a média populacional ou fazer comparações entre médias de duas populações. Voltando ao nosso exemplo de vamos analisar se o uso de nosso fertilizante melhorou mesmo nossa produtividade. Para calcular o test t no R podemos utilizar o comando t.test() e ajustar os demais parâmetros. t.test(x, y = NULL, alternative = c(\"two.sided\", \"less\", \"greater\"), mu = 0, paired = FALSE, var.equal = FALSE, conf.level = 0.95, ...) set.seed(1234) exper&lt;-runif(25, min = 4200, max = 4800) exper ## [1] 4268.222 4573.380 4565.565 4574.028 4716.549 4584.186 4205.697 4339.530 ## [9] 4599.650 4508.551 4616.155 4526.985 4369.640 4754.060 4375.390 4702.377 ## [17] 4371.734 4360.092 4312.034 4339.336 4389.967 4381.616 4295.428 4223.998 ## [25] 4331.280 options(scipen = 999) t.test(exper, mu=4350, alternative=&quot;greater&quot;,conf.level = 0.95) ## ## One Sample t-test ## ## data: exper ## t = 3.1853, df = 24, p-value = 0.00199 ## alternative hypothesis: true mean is greater than 4350 ## 95 percent confidence interval: ## 4396.944 Inf ## sample estimates: ## mean of x ## 4451.418 Agora basta interpretar o resultado. Para saber se \\(H_0\\) foi rejeitado ou não, apenas verifique o valor de p-value e estipule um nível de sgnificância. Neste exemplo o nível de significância (\\(\\alpha\\)) foi 5%, então \\(H_0\\) seria rejeitada, uma vez que p-value foi menor que 0.05. Neste caso observamos que a média do experimento é oriunda de uma população com média estatisticamente maior que 4350 kg ha com nível de significância de 5%. Ou seja, a utilização de fertilizante aumentou nossa produtividade de milho. Com o argumento alternative=\"greater\" fizemos um teste unilateral para saber se houve aumento da produtividade. Podemos variar este argumento com less para sber se foi menor ou two.sided para um teste bilateral. options(scipen = 999) t.test(exper,mu=4350, alternative=&quot;two.sided&quot;, conf.level = 0.95) ## ## One Sample t-test ## ## data: exper ## t = 3.1853, df = 24, p-value = 0.00398 ## alternative hypothesis: true mean is not equal to 4350 ## 95 percent confidence interval: ## 4385.704 4517.132 ## sample estimates: ## mean of x ## 4451.418 Para facilitar a visualização podemos utilziar o pacote webrque gerar uma gráfico destacando a região de rejeição de nossa hipótese e a posição do p-value. a região rosa é a região de rejeição de \\(H_0\\) e ponto azul o t calculado. #if (!require(&quot;webr&quot;)) install.packages(&quot;webr&quot;) library(webr) ## Registered S3 method overwritten by &#39;psych&#39;: ## method from ## plot.residuals rmutil plot(t.test(exper, mu=4350, alternative=&quot;greater&quot;, conf.level = 0.95)) plot(t.test(exper, mu=4350, alternative=&quot;less&quot;, conf.level = 0.95)) plot(t.test(exper, mu=4350, alternative=&quot;two.sided&quot;, conf.level = 0.95)) 7.2.2.2 Duas amostras independentes Vamos considerar agora que um novo experimento foi feito com um novo fertilizante lançado no mercado. Gostaríamos de saber se apresentam comprtamento semelhante, pois quero comprar o mais barato e, se forem iguais, fico com o mais barato. Vamos considerá-las com variâncias não homogêneas var.equal = F. set.seed(1234) exper2&lt;-runif(25, min = 3500, max = 5200) exper2 ## [1] 3693.296 4557.909 4535.767 4559.745 4963.556 4588.528 3516.143 3895.336 ## [9] 4632.342 4374.227 4679.105 4426.457 3980.647 5069.837 3996.937 4923.403 ## [17] 3986.580 3953.595 3817.429 3894.784 4038.241 4014.579 3770.378 3567.993 ## [25] 3871.959 plot(t.test(exper,exper2,var.equal = F, alternative=&quot;less&quot;, conf.level = 0.95)) plot(t.test(exper,exper2,var.equal = F, alternative=&quot;greater&quot;, conf.level = 0.95)) plot(t.test(exper,exper2,var.equal = F, alternative=&quot;two.sided&quot;, conf.level = 0.95)) Rejeitamos as hipótese nula apenas no primeiro caso, pois p-value foi maior que *0.05. Nos demais não rejeitamos a hipótese nula assumimos então que a produtividade com os 2 fertilizantes são diferentes, estatisticamente , a 5% de significância. 7.2.2.3 Para duas amostras dependentes Quando temos pares de amostras (X e Y) coletadas dos mesmos indivíduos, temos um teste pareado. Neste caso basta acrescentar o argumento paired=T. plot(t.test(exper,exper2,var.equal = F,paired=T, alternative=&quot;less&quot;, conf.level = 0.95)) plot(t.test(exper,exper2,var.equal = F,paired=T, alternative=&quot;greater&quot;, conf.level = 0.95)) plot(t.test(exper,exper2,var.equal = F,paired=T, alternative=&quot;two.sided&quot;, conf.level = 0.95)) 7.2.3 Teste F Métodos utilizado verificar se as variâncias de amostras normalmente distribuídas são homogêneas. \\(H_0: \\sigma^2_A = \\sigma^2_B\\) \\(H_1: \\sigma^2_A &gt; \\sigma^2_B\\) exper ## [1] 4268.222 4573.380 4565.565 4574.028 4716.549 4584.186 4205.697 4339.530 ## [9] 4599.650 4508.551 4616.155 4526.985 4369.640 4754.060 4375.390 4702.377 ## [17] 4371.734 4360.092 4312.034 4339.336 4389.967 4381.616 4295.428 4223.998 ## [25] 4331.280 exper2 ## [1] 3693.296 4557.909 4535.767 4559.745 4963.556 4588.528 3516.143 3895.336 ## [9] 4632.342 4374.227 4679.105 4426.457 3980.647 5069.837 3996.937 4923.403 ## [17] 3986.580 3953.595 3817.429 3894.784 4038.241 4014.579 3770.378 3567.993 ## [25] 3871.959 n1&lt;-length(exper) n2&lt;-length(exper2) vm1&lt;-var(exper) vm2&lt;-var(exper2) fcal&lt;-(vm1/vm2) fcal ## [1] 0.1245675 pval&lt;-pf(fcal, n1-1, n2-1, lower=F) pval ## [1] 0.9999986 Nest caso nosso nível de significância é 5% e o p-value foi 0.9999986. \\(H_0\\) não é rejeitada, pois o p-value foi maior que que o nível de significância. Assim, a variância da produtividade em A não é estatisticamente maior que da produtividade em B. Acima fizemos um passo a passo, mas existe uma forma mais fácil de conduzir esta análise utilizando o comando var.test(). x1&lt;-var.test(exper, exper2, alternative=&quot;greater&quot;) x1;plot(x1) ## ## F test to compare two variances ## ## data: exper and exper2 ## F = 0.12457, num df = 24, denom df = 24, p-value = 1 ## alternative hypothesis: true ratio of variances is greater than 1 ## 95 percent confidence interval: ## 0.06279363 Inf ## sample estimates: ## ratio of variances ## 0.1245675 x2&lt;-var.test(exper, exper2, alternative=&quot;less&quot;) x2;plot(x2) ## ## F test to compare two variances ## ## data: exper and exper2 ## F = 0.12457, num df = 24, denom df = 24, p-value = 0.000001415 ## alternative hypothesis: true ratio of variances is less than 1 ## 95 percent confidence interval: ## 0.0000000 0.2471119 ## sample estimates: ## ratio of variances ## 0.1245675 x3&lt;-var.test(exper, exper2, alternative=&quot;two.sided&quot;) x3;plot(x3) ## ## F test to compare two variances ## ## data: exper and exper2 ## F = 0.12457, num df = 24, denom df = 24, p-value = 0.000002829 ## alternative hypothesis: true ratio of variances is not equal to 1 ## 95 percent confidence interval: ## 0.05489302 0.28267814 ## sample estimates: ## ratio of variances ## 0.1245675 7.2.3.1 Kolmogorov-Smirnov O teste de Kolmogorov-Smirnov é utilizado para sabermos se um banco de dados segue alguma distribuição específica (Mello and Peternelli (2013)). No R o teste Kolmogorov-Smirnov para testar uma ditribuição pode ser acessado pelo comando ks.test(x,\"pdistribuição\", mean(), sd()). ks.test(exper,&quot;pnorm&quot;,mean(exper),sd(exper)) ## ## Exact one-sample Kolmogorov-Smirnov test ## ## data: exper ## D = 0.21025, p-value = 0.1899 ## alternative hypothesis: two-sided p-value não é menor que 0.05, desta forma podemos assumir que os dado exper não são significativamente diferentes de distribuição normal. 7.2.3.2 Teste de Shapiro Outro teste para normalidade de dados é o teste de shapiro. No R pode ser implementado utilizando shapiro.test() shapiro.test(exper) ## ## Shapiro-Wilk normality test ## ## data: exper ## W = 0.93315, p-value = 0.1028 shapiro.test(exper2) ## ## Shapiro-Wilk normality test ## ## data: exper2 ## W = 0.93315, p-value = 0.1028 The p-value de exper e exper2 são {r shapiro.test(exper)} e {r shapiro.test(exper2)}, respectivamente. Ambos são maiores que 0.05, desta forma concluimos que a distribuição de ambos experiemntos não são significativamente diferentes de uma distribuição normal. Podemos tentar compreender melhor as distribuições utilizando gráficos. Se a dispersão dos pontos segue um padrão aproximado de uma linha entyendemos assim que os dados são normalmente distribuídos. qqnorm(exper);qqline(exper) qqnorm(exper2);qqline(exper2) Existe uma infinidade de testes para serem conduzidos para explorar seus dados. Por isso procure um bom livro de estatística para compreender qual o melhor teste para seu caso. Para implementação destes teste no R, vimos que não é tão complexo e encontramos facilmente material de suporte na internet. Caso queiram explorar os testes conduzidos no R digitem no console apropos(\"test\") que lista tudo que tenha a palavra test ou help.search(\"test\") que listará os comandos encontrados nos pacotes instalados. apropos(&quot;test&quot;) ## [1] &quot;.valueClassTest&quot; &quot;ansari.test&quot; ## [3] &quot;associationTest&quot; &quot;bartlett.test&quot; ## [5] &quot;binom.test&quot; &quot;binom.test&quot; ## [7] &quot;Box.test&quot; &quot;chisq.test&quot; ## [9] &quot;clamtest&quot; &quot;cor.test&quot; ## [11] &quot;cor.test&quot; &quot;cor_test&quot; ## [13] &quot;cox.stuart.test&quot; &quot;fieller.MOStest&quot; ## [15] &quot;file_test&quot; &quot;fisher.test&quot; ## [17] &quot;fligner.test&quot; &quot;flow_test&quot; ## [19] &quot;friedman.test&quot; &quot;goodnessOfFitTest&quot; ## [21] &quot;independentSamplesTTest&quot; &quot;kruskal.test&quot; ## [23] &quot;ks.test&quot; &quot;mantelhaen.test&quot; ## [25] &quot;mauchly.test&quot; &quot;mcnemar.test&quot; ## [27] &quot;mood.test&quot; &quot;MOStest&quot; ## [29] &quot;oneSampleTTest&quot; &quot;oneway.test&quot; ## [31] &quot;ordiareatest&quot; &quot;pairedSamplesTTest&quot; ## [33] &quot;pairwise.prop.test&quot; &quot;pairwise.t.test&quot; ## [35] &quot;pairwise.wilcox.test&quot; &quot;permutest&quot; ## [37] &quot;poisson.test&quot; &quot;power.anova.test&quot; ## [39] &quot;power.prop.test&quot; &quot;power.t.test&quot; ## [41] &quot;PP.test&quot; &quot;prop.test&quot; ## [43] &quot;prop.test&quot; &quot;prop.trend.test&quot; ## [45] &quot;prop_test&quot; &quot;protest&quot; ## [47] &quot;quade.test&quot; &quot;runs.test&quot; ## [49] &quot;shapiro.test&quot; &quot;stat_anova_test&quot; ## [51] &quot;stat_friedman_test&quot; &quot;stat_kruskal_test&quot; ## [53] &quot;stat_welch_anova_test&quot; &quot;t.test&quot; ## [55] &quot;t.test&quot; &quot;t_test&quot; ## [57] &quot;testInheritedMethods&quot; &quot;testVirtual&quot; ## [59] &quot;theme_test&quot; &quot;var.test&quot; ## [61] &quot;wilcox.test&quot; &quot;xchisq.test&quot; help.search(&quot;test&quot;) Para mais detalhes sobre os testes e sobre sua utilização no R podem acessar o material online como Pires et al. (2018) e Freire (2021a). Outras fontes muito interessantes para implemenação de estatíticas no R com exemplos são Yamamoto (2020), Midway (2020) e Kabacoff (2015). References "],["outra-maneira-de-fazer-loop.html", "Capítulo 8 Outra maneira de fazer loop 8.1 Vamos dar uma olhada na família apply", " Capítulo 8 Outra maneira de fazer loop 8.1 Vamos dar uma olhada na família apply Assista este conteúdo em Cap_7_Apply family no PVANet Antes de começar vamos dar uma olhada na família apply. Esta família pertence ao grupos de funções básicas do R e guarda um conjunto de funções que facilitam muito nossa vida, principalmente quando precisamos fazer loops e não queremos utilizar os métodos apresentados anteriormente. Entre os irmãos da família temos apply, lapply, sapply, mapply e rep. Temos também os parentes Sweep e aggregate. Em se tratando dos irmãos, cada um trabalha com uma estrutura de dados diferente ( vector, matrix, list e etc) Dito isto, para iniciarmos o conteúdo de multivariada precisaremos instalar alguns pacotes. Vejam como foi feita a instalação e o carregamento dos pacotes. pacotes&lt;-c(&quot;datasets&quot;,&quot;cluster&quot;, &quot;factoextra&quot;, &quot;vegan&quot;, &quot;analogue&quot;) #lapply(pacotes, install.packages, character.only = TRUE) lapply(pacotes, library, character.only = TRUE) ## Welcome! Want to learn more? See two factoextra-related books at https://goo.gl/ve3WBa ## [[1]] ## [1] &quot;webr&quot; &quot;mosaic&quot; &quot;mosaicData&quot; &quot;ggformula&quot; &quot;Matrix&quot; ## [6] &quot;lsr&quot; &quot;modeest&quot; &quot;rmarkdown&quot; &quot;ggpubr&quot; &quot;lubridate&quot; ## [11] &quot;forcats&quot; &quot;stringr&quot; &quot;dplyr&quot; &quot;readr&quot; &quot;tidyr&quot; ## [16] &quot;tibble&quot; &quot;tidyverse&quot; &quot;viridis&quot; &quot;viridisLite&quot; &quot;unikn&quot; ## [21] &quot;RColorBrewer&quot; &quot;analogue&quot; &quot;vegan&quot; &quot;lattice&quot; &quot;permute&quot; ## [26] &quot;flow&quot; &quot;purrr&quot; &quot;magrittr&quot; &quot;ggplot2&quot; &quot;stats&quot; ## [31] &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [36] &quot;base&quot; ## ## [[2]] ## [1] &quot;cluster&quot; &quot;webr&quot; &quot;mosaic&quot; &quot;mosaicData&quot; &quot;ggformula&quot; ## [6] &quot;Matrix&quot; &quot;lsr&quot; &quot;modeest&quot; &quot;rmarkdown&quot; &quot;ggpubr&quot; ## [11] &quot;lubridate&quot; &quot;forcats&quot; &quot;stringr&quot; &quot;dplyr&quot; &quot;readr&quot; ## [16] &quot;tidyr&quot; &quot;tibble&quot; &quot;tidyverse&quot; &quot;viridis&quot; &quot;viridisLite&quot; ## [21] &quot;unikn&quot; &quot;RColorBrewer&quot; &quot;analogue&quot; &quot;vegan&quot; &quot;lattice&quot; ## [26] &quot;permute&quot; &quot;flow&quot; &quot;purrr&quot; &quot;magrittr&quot; &quot;ggplot2&quot; ## [31] &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; ## [36] &quot;methods&quot; &quot;base&quot; ## ## [[3]] ## [1] &quot;factoextra&quot; &quot;cluster&quot; &quot;webr&quot; &quot;mosaic&quot; &quot;mosaicData&quot; ## [6] &quot;ggformula&quot; &quot;Matrix&quot; &quot;lsr&quot; &quot;modeest&quot; &quot;rmarkdown&quot; ## [11] &quot;ggpubr&quot; &quot;lubridate&quot; &quot;forcats&quot; &quot;stringr&quot; &quot;dplyr&quot; ## [16] &quot;readr&quot; &quot;tidyr&quot; &quot;tibble&quot; &quot;tidyverse&quot; &quot;viridis&quot; ## [21] &quot;viridisLite&quot; &quot;unikn&quot; &quot;RColorBrewer&quot; &quot;analogue&quot; &quot;vegan&quot; ## [26] &quot;lattice&quot; &quot;permute&quot; &quot;flow&quot; &quot;purrr&quot; &quot;magrittr&quot; ## [31] &quot;ggplot2&quot; &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; ## [36] &quot;datasets&quot; &quot;methods&quot; &quot;base&quot; ## ## [[4]] ## [1] &quot;factoextra&quot; &quot;cluster&quot; &quot;webr&quot; &quot;mosaic&quot; &quot;mosaicData&quot; ## [6] &quot;ggformula&quot; &quot;Matrix&quot; &quot;lsr&quot; &quot;modeest&quot; &quot;rmarkdown&quot; ## [11] &quot;ggpubr&quot; &quot;lubridate&quot; &quot;forcats&quot; &quot;stringr&quot; &quot;dplyr&quot; ## [16] &quot;readr&quot; &quot;tidyr&quot; &quot;tibble&quot; &quot;tidyverse&quot; &quot;viridis&quot; ## [21] &quot;viridisLite&quot; &quot;unikn&quot; &quot;RColorBrewer&quot; &quot;analogue&quot; &quot;vegan&quot; ## [26] &quot;lattice&quot; &quot;permute&quot; &quot;flow&quot; &quot;purrr&quot; &quot;magrittr&quot; ## [31] &quot;ggplot2&quot; &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; ## [36] &quot;datasets&quot; &quot;methods&quot; &quot;base&quot; ## ## [[5]] ## [1] &quot;factoextra&quot; &quot;cluster&quot; &quot;webr&quot; &quot;mosaic&quot; &quot;mosaicData&quot; ## [6] &quot;ggformula&quot; &quot;Matrix&quot; &quot;lsr&quot; &quot;modeest&quot; &quot;rmarkdown&quot; ## [11] &quot;ggpubr&quot; &quot;lubridate&quot; &quot;forcats&quot; &quot;stringr&quot; &quot;dplyr&quot; ## [16] &quot;readr&quot; &quot;tidyr&quot; &quot;tibble&quot; &quot;tidyverse&quot; &quot;viridis&quot; ## [21] &quot;viridisLite&quot; &quot;unikn&quot; &quot;RColorBrewer&quot; &quot;analogue&quot; &quot;vegan&quot; ## [26] &quot;lattice&quot; &quot;permute&quot; &quot;flow&quot; &quot;purrr&quot; &quot;magrittr&quot; ## [31] &quot;ggplot2&quot; &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; ## [36] &quot;datasets&quot; &quot;methods&quot; &quot;base&quot; Foi criado um um objeto vector com os nomes do pacotes que precisamos. Em seguida, iniciamos com lapply que fazer um loop dentro do objeto que foi criado (pacotes) depois vem o comando que quero que seja executado (install.packages) seguindo de um definição lógica (character.only = TRUE) onde que indica que o que tem dentro de pacotes é character. Atenção! character.only = TRUE não está relacionado com lapply, mas com instalação ou carregamento de pacotes Para mais dealhes clique aqui. Vamos observar uns exemplos mais completos seguindo as sugestões de Perlin (2018). 8.1.1 lapply Com lapply a entrada é uma lista e a saída também é um lista. Esta função vai fazer um loop dentro de cada elemento da lista e retornar o resultado em forma de lista. Abaixo vamos criar uma lista com 3 vetores e calcular a média de cada vetor utilizando lapply. lista.1 &lt;- list(vec1 = 33:47, vec2 = seq(115,157,by=3), vec3 = seq(10,by=-8.5, length.out=15)) typeof(lista.1) ## [1] &quot;list&quot; lista.1.mean &lt;- lapply(X = lista.1, FUN = mean) # print result typeof(lista.1.mean) ## [1] &quot;list&quot; lista.1.mean ## $vec1 ## [1] 40 ## ## $vec2 ## [1] 136 ## ## $vec3 ## [1] -49.5 Também é possível combinar com argumento por exemplo na.rm = TRUE. lista.2 &lt;- list( c( 33:40, NA, 50), c( 2:5, NA), 10:-109) lista.2.mean &lt;- lapply(X = lista.1, FUN = mean, na.rm = TRUE) lista.2.mean ## $vec1 ## [1] 40 ## ## $vec2 ## [1] 136 ## ## $vec3 ## [1] -49.5 função para gerar arquivos setwd(““J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR”) criar.arquivo &lt;- function(nome.arquivo, N = 100){ if (class(nome.arquivo)!=&quot;character&quot;){stop(&quot;ERRO: Nome não é caractere!&quot;)} if (!( class(N) %in% c(&quot;numeric&quot;,&quot;integer&quot;))){stop(&quot;ERRO: N não é integer ou numeric!&quot;)} temp.df &lt;- data.frame(x = runif(N)) write.csv(x = temp.df, file = nome.arquivo) return(TRUE) } n.files &lt;- 5 pattern.name &lt;- &#39;meus_arquivos_com_lapply_&#39; out.dir &lt;- &#39;muitos arquivos/&#39; file.names &lt;- paste0(out.dir, pattern.name, seq(1, n.files), &#39;. csv&#39;) if(!dir.exists(out.dir)){dir.create(out.dir)} file.remove(list.files(out.dir, full.names = TRUE)) ## [1] TRUE TRUE TRUE TRUE TRUE saida.l &lt;- lapply(X = file.names, FUN = criar.arquivo, N = 100) saida.l ## [[1]] ## [1] TRUE ## ## [[2]] ## [1] TRUE ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] TRUE ## ## [[5]] ## [1] TRUE 8.1.2 sapply Funciona de maneira semelhante ao lapply mas tentando simplificar a saída. Veja que no exemplo abaixo a saída é um vetor numérico. lista.3 &lt;- list(vec1 = 33:47, vec2 = seq(115,157,by=3), vec3 = seq(10,by=-8.5, length.out=15)) is.list(lista.3);is.vector(lista.3) ## [1] TRUE ## [1] TRUE lista.3.vec &lt;- sapply(lista.3, mean) class(lista.3.vec);is.list(lista.3.vec);is.vector(lista.3.vec) ## [1] &quot;numeric&quot; ## [1] FALSE ## [1] TRUE lista.3.vec ## vec1 vec2 vec3 ## 40.0 136.0 -49.5 Criando um função para testar se a lista.4 é numeric e integer. lista.4 &lt;- list( runif(10), runif(15), rnorm(1000)) my.fct &lt;- function( x){ if (!(class(x)%in%c(&quot;numeric&quot;,&quot;integer&quot;))) {stop(&quot;ERRO: Class de x não é numeric ou integer.&quot;) } x &lt;- na.omit(x) out &lt;- c(mean(x),sd(x)) return(out) } Utilizando a função criada com sapply. lista.4.vec &lt;- sapply(lista.4, my.fct) # check result class(lista.4.vec) ## [1] &quot;matrix&quot; &quot;array&quot; lista.4.vec ## [,1] [,2] [,3] ## [1,] 0.3956025 0.7014711 -0.03105341 ## [2,] 0.3011568 0.2377516 0.97647518 8.1.3 tapply Função utilizada para cálculos em grupos (factor) de dados individualmente permitindo a criação de amostras para então aplicar os cáculos necessários. Abaixo temos o cálculode média para cada grupo A, B e C. meu.vetor &lt;- 1:150 factor.1 &lt;- factor(c(rep(&quot;C&quot;, 50), rep(&quot;B&quot;, 50), rep(&quot;A&quot;, 50))) factor.1.mean.vec &lt;- tapply(X = meu.vetor, INDEX = factor.1, FUN = mean) print(factor.1.mean.vec) ## A B C ## 125.5 75.5 25.5 Abaixo o operador %in% é utilizado para identificar se um parâmetro pertence a um tipo de restrição definida. Abaixo quero saber se a classe de x não é numeric ou integer. Se for vai omitir os valores NA e calcular a média, valor máximo e mínimo. descr.vec &lt;- function(x){ if (!(class(x)%in%c(&#39;numeric&#39;,&#39;integer&#39;))){stop(&#39; ERROR: Class de x não é numeric ou integer.&#39;) } x &lt;- na.omit(x) out &lt;- c( mean = mean(x), max = max(x), min = min(x)) return( out)} Temos aqui a função do.call que permite aplicar uma função a toda uma lista. Ozone Solar.R Wind Temp Month Day 41 190 7.4 67 5 1 36 118 8.0 72 5 2 12 149 12.6 74 5 3 18 313 11.5 62 5 4 NA NA 14.3 56 5 5 28 NA 14.9 66 5 6 23 299 8.6 65 5 7 19 99 13.8 59 5 8 8 19 20.1 61 5 9 NA 194 8.6 69 5 10 7 NA 6.9 74 5 11 16 256 9.7 69 5 12 11 290 9.2 66 5 13 14 274 10.9 68 5 14 18 65 13.2 58 5 15 14 334 11.5 64 5 16 34 307 12.0 66 5 17 6 78 18.4 57 5 18 30 322 11.5 68 5 19 11 44 9.7 62 5 20 1 8 9.7 59 5 21 11 320 16.6 73 5 22 4 25 9.7 61 5 23 32 92 12.0 61 5 24 NA 66 16.6 57 5 25 NA 266 14.9 58 5 26 NA NA 8.0 57 5 27 23 13 12.0 67 5 28 45 252 14.9 81 5 29 115 223 5.7 79 5 30 37 279 7.4 76 5 31 NA 286 8.6 78 6 1 NA 287 9.7 74 6 2 NA 242 16.1 67 6 3 NA 186 9.2 84 6 4 NA 220 8.6 85 6 5 NA 264 14.3 79 6 6 29 127 9.7 82 6 7 NA 273 6.9 87 6 8 71 291 13.8 90 6 9 39 323 11.5 87 6 10 NA 259 10.9 93 6 11 NA 250 9.2 92 6 12 23 148 8.0 82 6 13 NA 332 13.8 80 6 14 NA 322 11.5 79 6 15 21 191 14.9 77 6 16 37 284 20.7 72 6 17 20 37 9.2 65 6 18 12 120 11.5 73 6 19 13 137 10.3 76 6 20 NA 150 6.3 77 6 21 NA 59 1.7 76 6 22 NA 91 4.6 76 6 23 NA 250 6.3 76 6 24 NA 135 8.0 75 6 25 NA 127 8.0 78 6 26 NA 47 10.3 73 6 27 NA 98 11.5 80 6 28 NA 31 14.9 77 6 29 NA 138 8.0 83 6 30 135 269 4.1 84 7 1 49 248 9.2 85 7 2 32 236 9.2 81 7 3 NA 101 10.9 84 7 4 64 175 4.6 83 7 5 40 314 10.9 83 7 6 77 276 5.1 88 7 7 97 267 6.3 92 7 8 97 272 5.7 92 7 9 85 175 7.4 89 7 10 NA 139 8.6 82 7 11 10 264 14.3 73 7 12 27 175 14.9 81 7 13 NA 291 14.9 91 7 14 7 48 14.3 80 7 15 48 260 6.9 81 7 16 35 274 10.3 82 7 17 61 285 6.3 84 7 18 79 187 5.1 87 7 19 63 220 11.5 85 7 20 16 7 6.9 74 7 21 NA 258 9.7 81 7 22 NA 295 11.5 82 7 23 80 294 8.6 86 7 24 108 223 8.0 85 7 25 20 81 8.6 82 7 26 52 82 12.0 86 7 27 82 213 7.4 88 7 28 50 275 7.4 86 7 29 64 253 7.4 83 7 30 59 254 9.2 81 7 31 39 83 6.9 81 8 1 9 24 13.8 81 8 2 16 77 7.4 82 8 3 78 NA 6.9 86 8 4 35 NA 7.4 85 8 5 66 NA 4.6 87 8 6 122 255 4.0 89 8 7 89 229 10.3 90 8 8 110 207 8.0 90 8 9 NA 222 8.6 92 8 10 NA 137 11.5 86 8 11 44 192 11.5 86 8 12 28 273 11.5 82 8 13 65 157 9.7 80 8 14 NA 64 11.5 79 8 15 22 71 10.3 77 8 16 59 51 6.3 79 8 17 23 115 7.4 76 8 18 31 244 10.9 78 8 19 44 190 10.3 78 8 20 21 259 15.5 77 8 21 9 36 14.3 72 8 22 NA 255 12.6 75 8 23 45 212 9.7 79 8 24 168 238 3.4 81 8 25 73 215 8.0 86 8 26 NA 153 5.7 88 8 27 76 203 9.7 97 8 28 118 225 2.3 94 8 29 84 237 6.3 96 8 30 85 188 6.3 94 8 31 96 167 6.9 91 9 1 78 197 5.1 92 9 2 73 183 2.8 93 9 3 91 189 4.6 93 9 4 47 95 7.4 87 9 5 32 92 15.5 84 9 6 20 252 10.9 80 9 7 23 220 10.3 78 9 8 21 230 10.9 75 9 9 24 259 9.7 73 9 10 44 236 14.9 81 9 11 21 259 15.5 76 9 12 28 238 6.3 77 9 13 9 24 10.9 71 9 14 13 112 11.5 71 9 15 46 237 6.9 78 9 16 18 224 13.8 67 9 17 13 27 10.3 76 9 18 24 238 10.3 68 9 19 16 201 8.0 82 9 20 13 238 12.6 64 9 21 23 14 9.2 71 9 22 36 139 10.3 81 9 23 7 49 10.3 69 9 24 14 20 16.6 63 9 25 30 193 6.9 70 9 26 NA 145 13.2 77 9 27 14 191 14.3 75 9 28 18 131 8.0 76 9 29 20 223 11.5 68 9 30 ## $`5` ## mean max min ## 65.54839 81.00000 56.00000 ## ## $`6` ## mean max min ## 79.1 93.0 65.0 ## ## $`7` ## mean max min ## 83.90323 92.00000 73.00000 ## ## $`8` ## mean max min ## 83.96774 97.00000 72.00000 ## ## $`9` ## mean max min ## 76.9 93.0 63.0 ## mean max min ## 5 65.54839 81 56 ## 6 79.10000 93 65 ## 7 83.90323 92 73 ## 8 83.96774 97 72 ## 9 76.90000 93 63 8.1.4 mapply Esta função pode ser utilizada numa lista de múltiplas listas ou vários vetores. Abaixo vamos criar uma lista de 10 vetores de tamanhos diferentes. N &lt;- 10 # Prealocando a lista minha.lista &lt;- list() for (i in seq(1,N)){ minha.lista[[i]]&lt;-seq(1,i)} minha.lista ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 1 2 ## ## [[3]] ## [1] 1 2 3 ## ## [[4]] ## [1] 1 2 3 4 ## ## [[5]] ## [1] 1 2 3 4 5 ## ## [[6]] ## [1] 1 2 3 4 5 6 ## ## [[7]] ## [1] 1 2 3 4 5 6 7 ## ## [[8]] ## [1] 1 2 3 4 5 6 7 8 ## ## [[9]] ## [1] 1 2 3 4 5 6 7 8 9 ## ## [[10]] ## [1] 1 2 3 4 5 6 7 8 9 10 Aqui fazemos a mesma coisa utilizando o mapply. minha.lista &lt;- mapply(FUN = seq, rep(1,N), seq(1,N)) print(minha.lista) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 1 2 ## ## [[3]] ## [1] 1 2 3 ## ## [[4]] ## [1] 1 2 3 4 ## ## [[5]] ## [1] 1 2 3 4 5 ## ## [[6]] ## [1] 1 2 3 4 5 6 ## ## [[7]] ## [1] 1 2 3 4 5 6 7 ## ## [[8]] ## [1] 1 2 3 4 5 6 7 8 ## ## [[9]] ## [1] 1 2 3 4 5 6 7 8 9 ## ## [[10]] ## [1] 1 2 3 4 5 6 7 8 9 10 8.1.5 apply Utilizado em arrays. minha.matriz &lt;- matrix( 1: 15, nrow = 5) minha.matriz ## [,1] [,2] [,3] ## [1,] 1 6 11 ## [2,] 2 7 12 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 soma.linha &lt;- apply( X = minha.matriz, MARGIN = 1, FUN=sum) soma.linha ## [1] 18 21 24 27 30 soma.coluna &lt;- apply( X = minha.matriz, MARGIN = 2, FUN = sum) soma.coluna ## [1] 15 40 65 # mostra os valores máximos por linha print(apply(X = minha.matriz, MARGIN = 1, FUN = max)) ## [1] 11 12 13 14 15 # mostra os valores máximos por coluna print(apply( X = minha.matriz, MARGIN = 2, FUN = max)) ## [1] 5 10 15 8.1.6 Leituras complementares Tutorial on the R Apply Family Apply Family apply family in r apply(), lapply(), sapply(), mapply() and tapply() The Apply Family of Functions in R References "],["análise-multivariada.html", "Capítulo 9 Análise multivariada 9.1 Cluster Analysis (Análise de Agrupamento)", " Capítulo 9 Análise multivariada 9.1 Cluster Analysis (Análise de Agrupamento) Assista este conteúdo em Cap_8_Cluster Analysis no PVANet Análise de cluster ou agrupamento, como o próprio nome sugere, é uma análise exploratória que consiste em buscar padrões ou estruturas que descrevam um banco de dados para que possam ser agrupados(separados) baseados em sua similaridade(dissimilaridade) ou distância. A partir deste agrupamento realizado poderemos ter uma compreensão um pouco melhor dos nossos dados para então interpretá-los de maneira mais satisfatória. É importante salientar que a análise cluster tal qual outras análises exploratórias não são testes estatísticos definitivos que te darão a resposta final sobre alguma coisa. Estes são métodos exploratórios de análise que contribuem com nossa compreensão facilitando nossas análises. Contudo, para alcançar uma melhor compreensão dos dados temos que dar alguns passos importantes tomando decisões igualmente importantes como: Devemos padronizar nossos dados? Qual método de (dis)similaridade utilizar? Qual método de agrupamento utilizar? Quantos grupos reter? Para compreender um pouco mais deixo logo no início esta seleção de trabalhos sobre cluster analysis que vale a pena ser estudada. Um dos melhores guias para análise de cluster e multivariada em geral no R é o material Numerical Ecology with R, por isso vamos seguir os passos sugeridos pelos autores. Em Daniel Borcard (2018) os autores listam alguns métodos de agrupamento que dependem das decisões acima mencioadas. 1 - Sequencial ou algoritmos simultâneos - Ocorre a repetição de procedimentos até que todos os objetos encontrem seus grupos. 2 - Aglomerativo ou Divisivo - Aglomerativos agrupa objetos incialmente separados enquando os Divisivos separam os objetos que inicialmente estão todos juntos. 3 - Monotético ou Politético - São procedimentos relacionados ao método divisivo que utiliza um único descritor (monotético), o melhor encontrado, para particionar os grupos enqquanto o politético utiliza todos os descritores. 4 - Hierárquico e não Hierárquico - No primeiro, o membros de um ranking inferior se tornam membros de um gruposd maior enquanto no segundo é produzido apenas uma única partição sem qualquer hierarquia. 5 - Probailístico e não Probabilístico - O probailístico baseia-se na definição dos grupos de maneira que dentro do grupo (entre seus objetos) tenham uma dada probabilidade de serem homogêneos. 6 - Restrito e não restrito - Não restrito baseia-se na existência de 2 matrizes sendo: 1 - que será agrupada e 2 - com variáveis exploratórias que guiarão o procedimento da matriz 1. 9.1.1 Primeiro Passo - Importando e analisando nossos dados setwd(&quot;J:\\\\ENG 792\\\\ENG_792-AVDR\\\\ENG.792-AVDR&quot;) library(vegan) library(factoextra) library(gclus) ## Registered S3 method overwritten by &#39;gclus&#39;: ## method from ## reorder.hclust vegan ## ## Attaching package: &#39;gclus&#39; ## The following object is masked from &#39;package:unikn&#39;: ## ## ac camp.bras19&lt;-read.csv(&quot;Brasileiro_2019_Completo.csv&quot;, sep=&quot;;&quot;, header=T, row.names = 2) library(magrittr) urls&lt;-c(&quot;www.ogol.com.br&quot;) linkID&lt;-c(&quot;O Gol&quot;) camp.bras19 %&gt;% knitr::kable(caption = paste(&quot;Fonte: [&quot;,linkID,&quot;](https://&quot;,urls,&quot;)&quot;)) Table 9.1: Fonte: O Gol Posicao P V E D GP GC SG Aprov. VC EC DC VF EF DF GPC GCC GPF GCF RVV A X2A VE VCS ECS DCS JSSP JSP JSG GS GS.1.15 GS.16.30 GS.31.45 GS.46.60 GS.61.75 GS.76.90 GS.90 GS.91.105 GS.106.120 GS.120 G GM.1.15 GM.16.30 GM.31.45 GM.46.60 GM.61.75 GM.76.90 GM.90 GM.91.105 GM.106.120 GM.120 PEN PENF PEND Destino Flamengo 1 90 28 6 4 86 37 49 78 17 2 0 11 4 4 56 18 30 19 6 90 2 1 8 1 1 24 0 1 37 4 5 8 6 6 5 3 0 0 0 86 11 3 23 13 16 15 5 0 0 0 6 2 2 Libertadores Santos 2 74 22 8 8 60 33 27 64 14 4 1 8 4 7 44 15 16 18 2 108 6 4 7 1 2 8 1 0 33 3 4 6 9 4 3 4 0 0 0 60 13 6 11 10 11 8 1 0 0 0 5 2 1 Libertadores Palmeiras 3 74 21 11 6 61 32 29 64 13 4 2 8 7 4 40 13 21 19 1 73 1 3 7 4 3 10 2 0 32 7 5 7 3 4 4 2 0 0 0 61 12 5 9 11 8 12 4 0 0 0 5 1 1 Libertadores Gremio 4 65 19 8 11 64 39 25 57 12 3 4 7 5 7 38 18 26 21 2 81 1 1 5 3 2 7 0 1 39 8 3 12 6 3 4 3 0 0 0 64 10 6 14 7 11 11 5 0 0 0 7 2 0 Libertadores Athletico Paranaense 5 64 18 10 10 51 32 19 56 12 3 4 6 7 6 26 11 25 21 3 82 1 0 4 1 2 13 13 1 32 8 2 8 1 1 9 3 0 0 0 51 3 6 10 10 8 9 5 0 0 0 3 1 2 Libertadores Sao Paulo 6 63 17 12 9 39 30 9 55 10 6 3 7 6 6 23 12 16 18 1 86 2 4 5 4 2 9 2 0 30 4 1 10 6 4 4 1 0 0 0 39 7 3 7 10 3 6 3 0 0 0 3 1 0 Libertadores Internacional 7 57 16 9 13 44 39 5 50 11 6 2 5 3 11 28 15 16 24 1 93 0 3 4 2 2 4 1 0 39 4 3 6 6 11 7 2 0 0 0 44 4 5 7 7 7 12 2 0 0 0 1 2 1 Sulamericana Corinthians 8 56 14 14 10 42 34 8 49 11 2 6 4 6 9 25 13 17 21 2 69 0 1 3 2 2 10 0 1 34 1 5 10 6 6 4 2 0 0 0 42 4 6 8 6 7 8 3 0 0 0 0 0 0 Sulamericana Fortaleza 9 53 15 8 15 50 49 1 46 11 3 5 4 4 11 26 17 24 32 2 86 5 1 2 1 2 7 7 0 49 10 4 8 4 11 10 2 0 0 0 50 9 5 11 8 10 6 1 0 0 0 8 1 1 Sulamericana Goias 10 52 15 7 16 46 64 -18 45 10 7 2 4 7 8 31 23 15 41 2 87 3 4 4 2 3 4 1 0 64 5 11 13 10 8 11 6 0 0 0 46 7 5 9 2 7 8 8 0 0 0 0 0 0 Sulamericana Bahia 11 49 12 13 13 44 43 1 42 9 2 8 4 2 13 24 18 20 25 3 68 4 2 3 2 3 9 0 2 43 7 4 6 8 8 8 2 0 0 0 44 2 7 9 4 8 12 2 0 0 0 9 1 1 Sulamericana Vasco 12 49 12 13 13 39 45 -6 42 10 2 7 3 7 9 20 22 19 23 3 103 2 2 3 2 2 5 3 2 45 5 3 7 10 8 9 3 0 0 0 39 5 5 7 4 8 8 2 0 0 0 8 4 0 Sulamericana Atletico Mineiro 13 48 13 9 16 45 49 -4 42 7 8 4 5 5 9 28 23 17 26 1 73 3 2 3 2 6 6 0 1 49 3 7 11 8 9 8 3 0 0 0 45 4 7 7 10 4 8 5 0 0 0 5 2 1 NA Fluminense 14 46 12 10 16 38 46 -8 40 6 7 6 6 3 10 18 15 20 31 1 89 4 5 2 3 3 6 6 0 46 7 6 6 4 11 8 4 0 0 0 38 3 4 14 7 3 5 2 0 0 0 4 1 0 NA Botafogo 15 43 13 4 21 31 45 -14 37 7 6 6 5 7 7 19 17 12 28 2 95 2 1 3 1 4 3 1 3 45 6 4 7 4 12 9 3 0 0 0 31 2 6 7 3 7 4 2 0 0 0 0 0 0 NA Ceara 16 39 10 9 19 36 41 -5 34 8 6 5 2 3 14 23 14 13 27 2 86 1 1 2 2 3 3 1 7 41 1 7 13 4 3 8 5 0 0 0 36 3 6 7 2 4 10 4 0 0 0 3 3 0 NA Cruzeiro 17 36 7 15 16 27 46 -19 31 6 5 8 2 3 14 13 17 14 29 0 89 5 1 2 4 5 11 0 9 46 5 5 8 6 8 10 4 0 0 0 27 4 1 6 6 5 3 2 0 0 0 4 1 2 Rebaixamento CSA 18 32 8 8 22 24 58 -34 28 5 8 6 2 7 10 17 24 7 34 1 95 3 1 2 3 5 3 0 3 58 10 6 10 8 6 15 3 0 0 0 24 1 1 4 3 7 5 3 0 0 0 0 0 0 Rebaixamento Chapecoense 19 32 7 11 20 31 52 -21 28 4 5 10 3 6 10 16 22 15 30 0 79 1 4 2 2 4 3 2 1 52 6 2 9 14 5 11 5 0 0 0 31 7 3 5 4 2 7 3 0 0 0 0 0 0 Rebaixamento Avai 20 20 3 11 24 18 62 -44 17 1 9 9 2 2 15 10 24 8 38 0 78 2 8 2 2 8 2 1 18 62 8 7 12 8 9 14 4 0 0 0 18 1 4 2 4 1 4 2 0 0 0 4 1 0 Rebaixamento P = Pontos;V = Vitórias; E = Empates; D = Derrotas; GP = Gols Pró; GC = Gols Sofridos; AG = Gols Contra; SG = Saldo de Gols; GTIT = Gols como Titular; GSUP = Gols como Reserva; V3 = Vitórias por 3 ou mais Gols; VC = Vitórias em casa; EC = Empates em casa; DC = Derrotas em casa; VF = Vitórias Fora; EF = Empates Fora; DF = Derrotas Fora; MPG = Min. para marcar 1 gol; GPC = Gols Pró em Casa; GCC = Gols Sofridos Fora; GPF = Gols Pró Fora; GCF = Gols Sofridos Fora; RVV = Viradas; A = Amarelos; X2A = Segundos Amarelos; VE = Vermelhos; VCS = Máx. Vitórias Consecutivas; ECS = Máx. Empates Consecutivos; DCS = Máx Derrotas Consecutivas; JSSP = Máx. Jogos seguidos sem Perder; JSP = Jogos sem Perder; JSG = Jogos sem Ganhar; GS = Gols Sofridos; GS.1.15 = GS min 1 a 15; GS.16.30 = GS min 16 a 30; GS.31.45 = GS min 31 a 45; GS.46.60 = GS min 46 a 60; GS.61.75 = GS min 61 a 75; GS.76.90 = GS min 76 a 90; GS.90 = GS min 90+; GP.1.15 = GP min 1 a 15; GP.16.30 = GP min 16 a 30; GP.31.45 = GP min 31 a 45; GP.46.60 = GP min 46 a 60; GP.61.75 = GP min 61 a 75; GP.76.90 = GP min 76 a 90; GP.90 = GP min 90+; PEN = Gols de Pênalti; PENF = Pênaltis Falhados; PEND = Pênaltis Defendidos Ao analisar a tabela do Campeonato Brasileiro de 2019 identificamos algumas demandas antes de iniciarmos nossa análise. Inicialmente, deveremos fazer um tipo de “balanceamento” das informações, isto porque temos “variáveis” com valores muito altos e outras muito baixas (ex. Pontos e Saldo de Gols), além de escalas de grandeza diferentes (ex. Aproveitamento que está em %). O próximo passo é saber se devemos normalizar nossos dados. Quando mencionamos “normalizar” estamos nos referindo a transformar nossos dados de modo que ele fiquem dentro de uma mesma escala de grandeza. Este passo é importante para balancear os pesos das variáveis , pois valores altos ou baixos demais podem influenciar na confecção de nossas análises. Desta forma, o objetivo principal das transformações é obter uma distribuição simétrica, que é a ideal, pois os valores estão igualmente distribuídos em torno da tendência central dos dados Yamamoto (2020). Quando não fazemos esse “balanceamento” estamos correndo o risco de ter resultados fortemente influenciados pelos valores mais altos reduzindo desproporcionalmente a importância de outras de valores baixos que podem ser fundamentais para descrever o comportamento dos dados. O método mais comum utilizado para standatizar nossos dados consiste em transformar nossa média em 0 (zero) e variar o desvio padrão em torno desta média. A transformação mais comum que observamos é a padronização por meio do cálculo do resíduo que transforma nossos dados em novos dados com média 0 e desvio padrão igual a 1. No R utilize a função scale(). \\(z_{score} = \\frac{x_{i}-\\bar{x}}{\\sigma_{x}}\\) No R esta transformação é feita com comando scale(). Vamos então “estandartizar” nossos dados para trazê-los todos para mesmo formato, espectro de variação, todos serão transformados em z score. Não confunda estandartizar com normalizar. Podemos também fazer a transformação logarítmica que tem po objetivo a obtenção de uma distribuição normal. No R utilize a função log(). \\(y=ln(x)\\) Transformada Gaussiana gera sempre um histograma normal com média zero e desvio padrão igual a um, qualquer que seja o histograma dos dados originais. \\(P(Y(u)\\le{y})=G(y)\\) G é a distribuição acumulada Gaussiana. Transformação de Hellinger é útil para abundância de espécies atribuindo valores baixos para espécies com contagens baixas e muitos zeros. Esta consiste baiscamente em calcular a raiz quadrada da divisão de cada valor da matriz de dados pela soma de sua respectiva linha. Diferentes pacotes no R fazem essa transformação. \\(y^{\\prime}_{ij} = \\sqrt{\\frac{y_{ij}}{y_{i.}}}\\) Uma outra transformação baste utilizada é a aplicação da raiz quadrada. Reduz a amplitude dos dados comprimindo os valores grandes em menores. Útil para transformações de variáveis com proporção pequena de grandes valores se destacando da distribuição geral. No R utiliza-se sqrt(). destino&lt;-camp.bras19[,55] camp.bras19.stan&lt;-scale(camp.bras19[,2:54]) library(magrittr) camp.bras19.stan %&gt;% knitr::kable() P V E D GP GC SG Aprov. VC EC DC VF EF DF GPC GCC GPF GCF RVV A X2A VE VCS ECS DCS JSSP JSP JSG GS GS.1.15 GS.16.30 GS.31.45 GS.46.60 GS.61.75 GS.76.90 GS.90 GS.91.105 GS.106.120 GS.120 G GM.1.15 GM.16.30 GM.31.45 GM.46.60 GM.61.75 GM.76.90 GM.90 GM.91.105 GM.106.120 GM.120 PEN PENF PEND Flamengo 2.2718440 2.3768498 -1.3746024 -1.860723 2.6960012 -0.6877908 2.1704285 2.2538301 2.0722105 -1.2914930 -1.7936379 2.5146974 -0.4911441 -1.6307094 2.6616214 0.1078222 2.1502724 -1.0918365 3.0983303 0.4261121 -0.2355302 -0.7503581 2.3242992 -1.1937336 -1.2907138 3.3176256 -0.6367261 -0.3441236 -0.6877908 -0.6193514 0.1319600 -0.3556156 -0.1866652 -0.2712677 -0.9110408 -0.1613301 NaN NaN NaN 2.6960012 1.4575275 -0.9713242 3.1700902 1.9638692 2.5715514 2.1697015 1.037412 NaN NaN NaN 0.7664232 0.7009845 1.8569190 Santos 1.3127542 1.3508715 -0.6511274 -1.123803 1.0349578 -1.0923737 1.1959504 1.2903607 1.2752065 -0.4008082 -1.4275893 1.2779610 -0.4911441 -0.6899155 1.5880262 -0.6109924 -0.2677046 -1.2424346 0.1822547 2.1305603 2.1197714 0.8021070 1.7899775 -1.1937336 -0.7040257 0.1295169 -0.3261280 -0.5735393 -1.0923737 -1.0064461 -0.3079067 -1.1923582 0.8315086 -0.9095447 -1.5084446 0.6453204 NaN NaN NaN 1.0349578 1.9973525 0.7427774 0.4816745 1.0504417 1.1663321 -0.0156094 -1.267948 NaN NaN NaN 0.4257907 0.7009845 0.5305483 Palmeiras 1.3127542 1.1798751 0.4340850 -1.492263 1.0988441 -1.1935194 1.2845393 1.2903607 1.0095385 -0.4008082 -1.0615408 1.2779610 1.1460030 -1.6307094 1.2301612 -1.0902021 0.5958586 -1.0918365 -0.5467642 -1.1836446 -0.8243555 0.2846186 1.7899775 1.7906005 -0.1173376 0.5280305 -0.0155299 -0.5735393 -1.1935194 0.5419325 0.1319600 -0.7739869 -1.2048389 -0.9095447 -1.2097427 -0.9679805 NaN NaN NaN 1.0988441 1.7274400 0.1714102 0.0336052 1.3549175 0.3232005 1.2331397 0.461072 NaN NaN NaN 0.4257907 -0.2336615 0.5305483 Gremio 0.7732662 0.8378823 -0.6511274 -0.571113 1.2905029 -0.4854994 1.1073615 0.8086261 0.7438704 -0.8461506 -0.3294437 0.8657155 0.0545716 -0.6899155 1.0512286 0.1078222 1.4594218 -0.7906402 0.1822547 -0.4261121 -0.8243555 -0.7503581 0.7213342 0.7958224 -0.7040257 -0.0697399 -0.6367261 -0.3441236 -0.4854994 0.9290272 -0.7477733 1.3178696 -0.1866652 -1.2286832 -1.2097427 -0.1613301 NaN NaN NaN 1.2905029 1.1876150 0.7427774 1.1537784 0.1370141 1.1663321 0.9209524 1.037412 NaN NaN NaN 1.1070558 0.7009845 -0.7958224 Athletico Paranaense 0.7133230 0.6668859 0.0723475 -0.755343 0.4599812 -1.1935194 0.8415947 0.7398068 0.7438704 -0.8461506 -0.3294437 0.4534700 1.1460030 -1.0035135 -0.0223666 -1.5694118 1.2867092 -0.7906402 0.9112736 -0.3314205 -0.8243555 -1.2678465 0.1870126 -1.1937336 -0.7040257 1.1258009 3.4010493 -0.3441236 -1.1935194 0.9290272 -1.1876400 -0.3556156 -1.8836214 -1.8669601 0.2837668 -0.1613301 NaN NaN NaN 0.4599812 -0.7017725 0.7427774 0.2576398 1.0504417 0.3232005 0.2965779 1.037412 NaN NaN NaN -0.2554744 -0.2336615 1.8569190 Sao Paulo 0.6533799 0.4958895 0.7958224 -0.939573 -0.3066542 -1.3958108 0.3986501 0.6709876 0.2125344 0.4898766 -0.6954922 0.8657155 0.6002873 -1.0035135 -0.2907654 -1.3298069 -0.2677046 -1.2424346 -0.5467642 0.0473458 -0.2355302 0.8021070 0.7213342 1.7906005 -0.7040257 0.3287737 -0.0155299 -0.5735393 -1.3958108 -0.6193514 -1.6275067 0.4811270 -0.1866652 -0.9095447 -1.2097427 -1.7746310 NaN NaN NaN -0.3066542 0.3778775 -0.9713242 -0.4144641 1.0504417 -1.0820189 -0.6399839 -0.115268 NaN NaN NaN -0.2554744 -0.2336615 -0.7958224 Internacional 0.2937213 0.3248931 -0.2893900 -0.202653 0.0127773 -0.4854994 0.2214723 0.3268914 0.4782024 0.4898766 -1.0615408 0.0412245 -1.0368599 0.5644763 0.1565660 -0.6109924 -0.2677046 -0.3388458 -0.5467642 0.7101868 -1.4131809 0.2846186 0.1870126 -0.1989556 -0.7040257 -0.6675103 -0.3261280 -0.5735393 -0.4854994 -0.6193514 -0.7477733 -1.1923582 -0.1866652 1.3244247 -0.3136370 -0.9679805 NaN NaN NaN 0.0127773 -0.4318600 0.1714102 -0.4144641 0.1370141 0.0421566 1.2331397 -0.691608 NaN NaN NaN -0.9367395 0.7009845 0.5305483 Corinthians 0.2337781 -0.0170996 1.5192974 -0.755343 -0.1149953 -0.9912279 0.3543557 0.2580721 0.4782024 -1.2914930 0.4026534 -0.3710209 0.6002873 -0.0627196 -0.1118328 -1.0902021 -0.0949920 -0.7906402 0.1822547 -1.5624109 -1.4131809 -0.7503581 -0.3473091 -0.1989556 -0.7040257 0.5280305 -0.6367261 -0.3441236 -0.9912279 -1.7806354 0.1319600 0.4811270 -0.1866652 -0.2712677 -1.2097427 -0.9679805 NaN NaN NaN -0.1149953 -0.4318600 0.7427774 -0.1904294 -0.1674617 0.0421566 -0.0156094 -0.115268 NaN NaN NaN -1.2773721 -1.1683075 -0.7958224 Fortaleza 0.0539488 0.1538968 -0.6511274 0.165807 0.3960950 0.5259577 0.0442945 0.0516144 0.4782024 -0.8461506 0.0366049 -0.3710209 -0.4911441 0.5644763 -0.0223666 -0.1317827 1.1139965 0.8659393 0.1822547 0.0473458 1.5309460 -0.7503581 -0.8816307 -1.1937336 -0.7040257 -0.0697399 1.5374606 -0.5735393 0.5259577 1.7032165 -0.3079067 -0.3556156 -0.8654477 1.3244247 0.5824687 -0.9679805 NaN NaN NaN 0.3960950 0.9177025 0.1714102 0.4816745 0.4414900 0.8852882 -0.6399839 -1.267948 NaN NaN NaN 1.4476883 -0.2336615 0.5305483 Goias -0.0059943 0.1538968 -1.0128649 0.350037 0.1405498 2.0431433 -0.7973003 -0.0172048 0.2125344 0.9352190 -1.0615408 -0.3710209 1.1460030 -0.3763176 0.4249648 1.3058464 -0.4404172 2.2213224 0.1822547 0.1420374 0.3532952 0.8021070 0.1870126 -0.1989556 -0.1173376 -0.6675103 -0.3261280 -0.5735393 2.0431433 -0.2322568 2.7711600 1.7362409 1.1708998 0.3670093 0.8811706 2.2586212 NaN NaN NaN 0.1405498 0.3778775 0.1714102 0.0336052 -1.3853651 0.0421566 -0.0156094 2.766432 NaN NaN NaN -1.2773721 -1.1683075 -0.7958224 Bahia -0.1858236 -0.3590924 1.1575599 -0.202653 0.0127773 -0.0809166 0.0442945 -0.2236625 -0.0531336 -1.2914930 1.1347505 -0.3710209 -1.5825756 1.1916723 -0.2012991 0.1078222 0.4231460 -0.1882477 0.9112736 -1.6571025 0.9421206 -0.2328698 -0.3473091 -0.1989556 -0.1173376 0.3287737 -0.6367261 -0.1147079 -0.0809166 0.5419325 -0.3079067 -1.1923582 0.4921173 0.3670093 -0.0149351 -0.9679805 NaN NaN NaN 0.0127773 -0.9716850 1.3141446 0.0336052 -0.7764134 0.3232005 1.2331397 -0.691608 NaN NaN NaN 1.7883209 -0.2336615 0.5305483 Vasco -0.1858236 -0.3590924 1.1575599 -0.202653 -0.3066542 0.1213749 -0.2657668 -0.2236625 0.2125344 -1.2914930 0.7687019 -0.7832664 1.1460030 -0.0627196 -0.5591642 1.0662416 0.2504333 -0.4894439 0.9112736 1.6571025 -0.2355302 -0.2328698 -0.3473091 -0.1989556 -0.7040257 -0.4682535 0.2950682 -0.1147079 0.1213749 -0.2322568 -0.7477733 -0.7739869 1.1708998 0.3670093 0.2837668 -0.1613301 NaN NaN NaN -0.3066542 -0.1619475 0.1714102 -0.4144641 -0.7764134 0.3232005 -0.0156094 -0.691608 NaN NaN NaN 1.4476883 2.5702766 -0.7958224 Atletico Mineiro -0.2457668 -0.1880960 -0.2893900 0.350037 0.0766635 0.5259577 -0.1771778 -0.2236625 -0.5844696 1.3805614 -0.3294437 0.0412245 0.0545716 -0.0627196 0.1565660 1.3058464 -0.0949920 -0.0376495 -0.5467642 -1.1836446 0.3532952 -0.2328698 -0.3473091 -0.1989556 1.6427266 -0.2689967 -0.6367261 -0.3441236 0.5259577 -1.0064461 1.0116933 0.8994983 0.4921173 0.6861477 -0.0149351 -0.1613301 NaN NaN NaN 0.0766635 -0.4318600 1.3141446 -0.4144641 1.0504417 -0.8009750 -0.0156094 1.037412 NaN NaN NaN 0.4257907 0.7009845 0.5305483 Fluminense -0.3656530 -0.3590924 0.0723475 0.350037 -0.3705404 0.2225206 -0.3543557 -0.3613010 -0.8501377 0.9352190 0.4026534 0.4534700 -1.0368599 0.2508784 -0.7380967 -0.6109924 0.4231460 0.7153411 -0.5467642 0.3314205 0.9421206 1.3195954 -0.8816307 0.7958224 -0.1173376 -0.2689967 1.2268625 -0.5735393 0.2225206 0.5419325 0.5718267 -1.1923582 -0.8654477 1.3244247 -0.0149351 0.6453204 NaN NaN NaN -0.3705404 -0.7017725 -0.3999570 1.1537784 0.1370141 -1.0820189 -0.9521712 -0.691608 NaN NaN NaN 0.0851581 -0.2336615 -0.7958224 Botafogo -0.5454823 -0.1880960 -2.0980773 1.271187 -0.8177444 0.1213749 -0.6201224 -0.5677587 -0.5844696 0.4898766 0.4026534 0.0412245 1.1460030 -0.6899155 -0.6486304 -0.1317827 -0.9585552 0.2635467 0.1822547 0.8995699 -0.2355302 -0.7503581 -0.3473091 -1.1937336 0.4693505 -0.8667671 -0.3261280 0.1147079 0.1213749 0.1548379 -0.3079067 -0.7739869 -0.8654477 1.6435632 0.2837668 -0.1613301 NaN NaN NaN -0.8177444 -0.9716850 0.7427774 -0.4144641 -1.0808892 0.0421566 -1.2643584 -0.691608 NaN NaN NaN -1.2773721 -1.1683075 -0.7958224 Ceara -0.7852548 -0.7010852 -0.2893900 0.902727 -0.4983130 -0.2832080 -0.2214723 -0.7742164 -0.3188016 0.4898766 0.0366049 -1.1955119 -1.0368599 1.5052702 -0.2907654 -0.8505972 -0.7858425 0.1129486 0.1822547 0.0473458 -0.8243555 -0.7503581 -0.8816307 -0.1989556 -0.1173376 -0.8667671 -0.3261280 1.0323708 -0.2832080 -1.7806354 1.0116933 1.7362409 -0.8654477 -1.2286832 -0.0149351 1.4519708 NaN NaN NaN -0.4983130 -0.7017725 0.7427774 -0.4144641 -1.3853651 -0.8009750 0.6087652 0.461072 NaN NaN NaN -0.2554744 1.6356306 -0.7958224 Cruzeiro -0.9650841 -1.2140744 1.8810348 0.350037 -1.0732896 0.2225206 -0.8415947 -0.9806742 -0.8501377 0.0445342 1.1347505 -1.1955119 -1.0368599 1.5052702 -1.1854280 -0.1317827 -0.6131299 0.4141449 -1.2757830 0.3314205 1.5309460 -0.7503581 -0.8816307 1.7906005 1.0560385 0.7272873 -0.6367261 1.4912023 0.2225206 -0.2322568 0.1319600 -0.3556156 -0.1866652 0.3670093 0.5824687 0.6453204 NaN NaN NaN -1.0732896 -0.4318600 -2.1140587 -0.6384987 -0.1674617 -0.5199312 -1.5765457 -0.691608 NaN NaN NaN 0.0851581 -0.2336615 1.8569190 CSA -1.2048566 -1.0430780 -0.6511274 1.455417 -1.2649484 1.4362691 -1.5060116 -1.1871319 -1.1158057 1.3805614 0.4026534 -1.1955119 1.1460030 0.2508784 -0.8275630 1.5454513 -1.8221184 1.1671355 -0.5467642 0.8995699 0.3532952 -0.7503581 -0.8816307 0.7958224 1.0560385 -0.8667671 -0.6367261 0.1147079 1.4362691 1.7032165 0.5718267 0.4811270 0.4921173 -0.2712677 2.0759782 -0.1613301 NaN NaN NaN -1.2649484 -1.2415975 -2.1140587 -1.0865680 -1.0808892 0.0421566 -0.9521712 -0.115268 NaN NaN NaN -1.2773721 -1.1683075 -0.7958224 Chapecoense -1.2048566 -1.2140744 0.4340850 1.086957 -0.8177444 0.8293948 -0.9301837 -1.1871319 -1.3814737 0.0445342 1.8668476 -0.7832664 0.6002873 0.2508784 -0.9170292 1.0662416 -0.4404172 0.5647430 -1.2757830 -0.6154952 -0.8243555 0.8021070 -0.8816307 -0.1989556 0.4693505 -0.8667671 -0.0155299 -0.3441236 0.8293948 0.1548379 -1.1876400 0.0627557 2.5284648 -0.5904062 0.8811706 1.4519708 NaN NaN NaN -0.8177444 0.3778775 -0.9713242 -0.8625334 -0.7764134 -1.3630628 -0.3277966 -0.115268 NaN NaN NaN -1.2773721 -1.1683075 -0.7958224 Avai -1.9241739 -1.8980600 0.4340850 1.823877 -1.6482661 1.8408519 -1.9489562 -1.9441435 -2.1784777 1.8259038 1.5007990 -1.1955119 -1.5825756 1.8188682 -1.4538268 1.5454513 -1.6494057 1.7695280 -1.2757830 -0.7101868 -0.2355302 2.8720605 -0.8816307 -0.1989556 2.8161028 -1.0660239 -0.3261280 3.5559439 1.8408519 0.9290272 1.0116933 1.3178696 0.4921173 0.6861477 1.7772763 0.6453204 NaN NaN NaN -1.6482661 -1.2415975 -0.3999570 -1.5346373 -0.7764134 -1.6441066 -1.2643584 -0.691608 NaN NaN NaN 0.0851581 -0.2336615 -0.7958224 Vamos remover as colunas com NAN. camp.bras19.stan&lt;-camp.bras19.stan[ , -which(colnames(camp.bras19.stan) %in% c(&quot;GS.91.105&quot;,&quot;GS.106.120&quot;,&quot;GS.120&quot;,&quot;GM.91.105&quot;,&quot;GM.106.120&quot;,&quot;GM.120&quot;))] # Devem haver outras formas de fazer camp.bras19.stan %&gt;% knitr::kable() P V E D GP GC SG Aprov. VC EC DC VF EF DF GPC GCC GPF GCF RVV A X2A VE VCS ECS DCS JSSP JSP JSG GS GS.1.15 GS.16.30 GS.31.45 GS.46.60 GS.61.75 GS.76.90 GS.90 G GM.1.15 GM.16.30 GM.31.45 GM.46.60 GM.61.75 GM.76.90 GM.90 PEN PENF PEND Flamengo 2.2718440 2.3768498 -1.3746024 -1.860723 2.6960012 -0.6877908 2.1704285 2.2538301 2.0722105 -1.2914930 -1.7936379 2.5146974 -0.4911441 -1.6307094 2.6616214 0.1078222 2.1502724 -1.0918365 3.0983303 0.4261121 -0.2355302 -0.7503581 2.3242992 -1.1937336 -1.2907138 3.3176256 -0.6367261 -0.3441236 -0.6877908 -0.6193514 0.1319600 -0.3556156 -0.1866652 -0.2712677 -0.9110408 -0.1613301 2.6960012 1.4575275 -0.9713242 3.1700902 1.9638692 2.5715514 2.1697015 1.037412 0.7664232 0.7009845 1.8569190 Santos 1.3127542 1.3508715 -0.6511274 -1.123803 1.0349578 -1.0923737 1.1959504 1.2903607 1.2752065 -0.4008082 -1.4275893 1.2779610 -0.4911441 -0.6899155 1.5880262 -0.6109924 -0.2677046 -1.2424346 0.1822547 2.1305603 2.1197714 0.8021070 1.7899775 -1.1937336 -0.7040257 0.1295169 -0.3261280 -0.5735393 -1.0923737 -1.0064461 -0.3079067 -1.1923582 0.8315086 -0.9095447 -1.5084446 0.6453204 1.0349578 1.9973525 0.7427774 0.4816745 1.0504417 1.1663321 -0.0156094 -1.267948 0.4257907 0.7009845 0.5305483 Palmeiras 1.3127542 1.1798751 0.4340850 -1.492263 1.0988441 -1.1935194 1.2845393 1.2903607 1.0095385 -0.4008082 -1.0615408 1.2779610 1.1460030 -1.6307094 1.2301612 -1.0902021 0.5958586 -1.0918365 -0.5467642 -1.1836446 -0.8243555 0.2846186 1.7899775 1.7906005 -0.1173376 0.5280305 -0.0155299 -0.5735393 -1.1935194 0.5419325 0.1319600 -0.7739869 -1.2048389 -0.9095447 -1.2097427 -0.9679805 1.0988441 1.7274400 0.1714102 0.0336052 1.3549175 0.3232005 1.2331397 0.461072 0.4257907 -0.2336615 0.5305483 Gremio 0.7732662 0.8378823 -0.6511274 -0.571113 1.2905029 -0.4854994 1.1073615 0.8086261 0.7438704 -0.8461506 -0.3294437 0.8657155 0.0545716 -0.6899155 1.0512286 0.1078222 1.4594218 -0.7906402 0.1822547 -0.4261121 -0.8243555 -0.7503581 0.7213342 0.7958224 -0.7040257 -0.0697399 -0.6367261 -0.3441236 -0.4854994 0.9290272 -0.7477733 1.3178696 -0.1866652 -1.2286832 -1.2097427 -0.1613301 1.2905029 1.1876150 0.7427774 1.1537784 0.1370141 1.1663321 0.9209524 1.037412 1.1070558 0.7009845 -0.7958224 Athletico Paranaense 0.7133230 0.6668859 0.0723475 -0.755343 0.4599812 -1.1935194 0.8415947 0.7398068 0.7438704 -0.8461506 -0.3294437 0.4534700 1.1460030 -1.0035135 -0.0223666 -1.5694118 1.2867092 -0.7906402 0.9112736 -0.3314205 -0.8243555 -1.2678465 0.1870126 -1.1937336 -0.7040257 1.1258009 3.4010493 -0.3441236 -1.1935194 0.9290272 -1.1876400 -0.3556156 -1.8836214 -1.8669601 0.2837668 -0.1613301 0.4599812 -0.7017725 0.7427774 0.2576398 1.0504417 0.3232005 0.2965779 1.037412 -0.2554744 -0.2336615 1.8569190 Sao Paulo 0.6533799 0.4958895 0.7958224 -0.939573 -0.3066542 -1.3958108 0.3986501 0.6709876 0.2125344 0.4898766 -0.6954922 0.8657155 0.6002873 -1.0035135 -0.2907654 -1.3298069 -0.2677046 -1.2424346 -0.5467642 0.0473458 -0.2355302 0.8021070 0.7213342 1.7906005 -0.7040257 0.3287737 -0.0155299 -0.5735393 -1.3958108 -0.6193514 -1.6275067 0.4811270 -0.1866652 -0.9095447 -1.2097427 -1.7746310 -0.3066542 0.3778775 -0.9713242 -0.4144641 1.0504417 -1.0820189 -0.6399839 -0.115268 -0.2554744 -0.2336615 -0.7958224 Internacional 0.2937213 0.3248931 -0.2893900 -0.202653 0.0127773 -0.4854994 0.2214723 0.3268914 0.4782024 0.4898766 -1.0615408 0.0412245 -1.0368599 0.5644763 0.1565660 -0.6109924 -0.2677046 -0.3388458 -0.5467642 0.7101868 -1.4131809 0.2846186 0.1870126 -0.1989556 -0.7040257 -0.6675103 -0.3261280 -0.5735393 -0.4854994 -0.6193514 -0.7477733 -1.1923582 -0.1866652 1.3244247 -0.3136370 -0.9679805 0.0127773 -0.4318600 0.1714102 -0.4144641 0.1370141 0.0421566 1.2331397 -0.691608 -0.9367395 0.7009845 0.5305483 Corinthians 0.2337781 -0.0170996 1.5192974 -0.755343 -0.1149953 -0.9912279 0.3543557 0.2580721 0.4782024 -1.2914930 0.4026534 -0.3710209 0.6002873 -0.0627196 -0.1118328 -1.0902021 -0.0949920 -0.7906402 0.1822547 -1.5624109 -1.4131809 -0.7503581 -0.3473091 -0.1989556 -0.7040257 0.5280305 -0.6367261 -0.3441236 -0.9912279 -1.7806354 0.1319600 0.4811270 -0.1866652 -0.2712677 -1.2097427 -0.9679805 -0.1149953 -0.4318600 0.7427774 -0.1904294 -0.1674617 0.0421566 -0.0156094 -0.115268 -1.2773721 -1.1683075 -0.7958224 Fortaleza 0.0539488 0.1538968 -0.6511274 0.165807 0.3960950 0.5259577 0.0442945 0.0516144 0.4782024 -0.8461506 0.0366049 -0.3710209 -0.4911441 0.5644763 -0.0223666 -0.1317827 1.1139965 0.8659393 0.1822547 0.0473458 1.5309460 -0.7503581 -0.8816307 -1.1937336 -0.7040257 -0.0697399 1.5374606 -0.5735393 0.5259577 1.7032165 -0.3079067 -0.3556156 -0.8654477 1.3244247 0.5824687 -0.9679805 0.3960950 0.9177025 0.1714102 0.4816745 0.4414900 0.8852882 -0.6399839 -1.267948 1.4476883 -0.2336615 0.5305483 Goias -0.0059943 0.1538968 -1.0128649 0.350037 0.1405498 2.0431433 -0.7973003 -0.0172048 0.2125344 0.9352190 -1.0615408 -0.3710209 1.1460030 -0.3763176 0.4249648 1.3058464 -0.4404172 2.2213224 0.1822547 0.1420374 0.3532952 0.8021070 0.1870126 -0.1989556 -0.1173376 -0.6675103 -0.3261280 -0.5735393 2.0431433 -0.2322568 2.7711600 1.7362409 1.1708998 0.3670093 0.8811706 2.2586212 0.1405498 0.3778775 0.1714102 0.0336052 -1.3853651 0.0421566 -0.0156094 2.766432 -1.2773721 -1.1683075 -0.7958224 Bahia -0.1858236 -0.3590924 1.1575599 -0.202653 0.0127773 -0.0809166 0.0442945 -0.2236625 -0.0531336 -1.2914930 1.1347505 -0.3710209 -1.5825756 1.1916723 -0.2012991 0.1078222 0.4231460 -0.1882477 0.9112736 -1.6571025 0.9421206 -0.2328698 -0.3473091 -0.1989556 -0.1173376 0.3287737 -0.6367261 -0.1147079 -0.0809166 0.5419325 -0.3079067 -1.1923582 0.4921173 0.3670093 -0.0149351 -0.9679805 0.0127773 -0.9716850 1.3141446 0.0336052 -0.7764134 0.3232005 1.2331397 -0.691608 1.7883209 -0.2336615 0.5305483 Vasco -0.1858236 -0.3590924 1.1575599 -0.202653 -0.3066542 0.1213749 -0.2657668 -0.2236625 0.2125344 -1.2914930 0.7687019 -0.7832664 1.1460030 -0.0627196 -0.5591642 1.0662416 0.2504333 -0.4894439 0.9112736 1.6571025 -0.2355302 -0.2328698 -0.3473091 -0.1989556 -0.7040257 -0.4682535 0.2950682 -0.1147079 0.1213749 -0.2322568 -0.7477733 -0.7739869 1.1708998 0.3670093 0.2837668 -0.1613301 -0.3066542 -0.1619475 0.1714102 -0.4144641 -0.7764134 0.3232005 -0.0156094 -0.691608 1.4476883 2.5702766 -0.7958224 Atletico Mineiro -0.2457668 -0.1880960 -0.2893900 0.350037 0.0766635 0.5259577 -0.1771778 -0.2236625 -0.5844696 1.3805614 -0.3294437 0.0412245 0.0545716 -0.0627196 0.1565660 1.3058464 -0.0949920 -0.0376495 -0.5467642 -1.1836446 0.3532952 -0.2328698 -0.3473091 -0.1989556 1.6427266 -0.2689967 -0.6367261 -0.3441236 0.5259577 -1.0064461 1.0116933 0.8994983 0.4921173 0.6861477 -0.0149351 -0.1613301 0.0766635 -0.4318600 1.3141446 -0.4144641 1.0504417 -0.8009750 -0.0156094 1.037412 0.4257907 0.7009845 0.5305483 Fluminense -0.3656530 -0.3590924 0.0723475 0.350037 -0.3705404 0.2225206 -0.3543557 -0.3613010 -0.8501377 0.9352190 0.4026534 0.4534700 -1.0368599 0.2508784 -0.7380967 -0.6109924 0.4231460 0.7153411 -0.5467642 0.3314205 0.9421206 1.3195954 -0.8816307 0.7958224 -0.1173376 -0.2689967 1.2268625 -0.5735393 0.2225206 0.5419325 0.5718267 -1.1923582 -0.8654477 1.3244247 -0.0149351 0.6453204 -0.3705404 -0.7017725 -0.3999570 1.1537784 0.1370141 -1.0820189 -0.9521712 -0.691608 0.0851581 -0.2336615 -0.7958224 Botafogo -0.5454823 -0.1880960 -2.0980773 1.271187 -0.8177444 0.1213749 -0.6201224 -0.5677587 -0.5844696 0.4898766 0.4026534 0.0412245 1.1460030 -0.6899155 -0.6486304 -0.1317827 -0.9585552 0.2635467 0.1822547 0.8995699 -0.2355302 -0.7503581 -0.3473091 -1.1937336 0.4693505 -0.8667671 -0.3261280 0.1147079 0.1213749 0.1548379 -0.3079067 -0.7739869 -0.8654477 1.6435632 0.2837668 -0.1613301 -0.8177444 -0.9716850 0.7427774 -0.4144641 -1.0808892 0.0421566 -1.2643584 -0.691608 -1.2773721 -1.1683075 -0.7958224 Ceara -0.7852548 -0.7010852 -0.2893900 0.902727 -0.4983130 -0.2832080 -0.2214723 -0.7742164 -0.3188016 0.4898766 0.0366049 -1.1955119 -1.0368599 1.5052702 -0.2907654 -0.8505972 -0.7858425 0.1129486 0.1822547 0.0473458 -0.8243555 -0.7503581 -0.8816307 -0.1989556 -0.1173376 -0.8667671 -0.3261280 1.0323708 -0.2832080 -1.7806354 1.0116933 1.7362409 -0.8654477 -1.2286832 -0.0149351 1.4519708 -0.4983130 -0.7017725 0.7427774 -0.4144641 -1.3853651 -0.8009750 0.6087652 0.461072 -0.2554744 1.6356306 -0.7958224 Cruzeiro -0.9650841 -1.2140744 1.8810348 0.350037 -1.0732896 0.2225206 -0.8415947 -0.9806742 -0.8501377 0.0445342 1.1347505 -1.1955119 -1.0368599 1.5052702 -1.1854280 -0.1317827 -0.6131299 0.4141449 -1.2757830 0.3314205 1.5309460 -0.7503581 -0.8816307 1.7906005 1.0560385 0.7272873 -0.6367261 1.4912023 0.2225206 -0.2322568 0.1319600 -0.3556156 -0.1866652 0.3670093 0.5824687 0.6453204 -1.0732896 -0.4318600 -2.1140587 -0.6384987 -0.1674617 -0.5199312 -1.5765457 -0.691608 0.0851581 -0.2336615 1.8569190 CSA -1.2048566 -1.0430780 -0.6511274 1.455417 -1.2649484 1.4362691 -1.5060116 -1.1871319 -1.1158057 1.3805614 0.4026534 -1.1955119 1.1460030 0.2508784 -0.8275630 1.5454513 -1.8221184 1.1671355 -0.5467642 0.8995699 0.3532952 -0.7503581 -0.8816307 0.7958224 1.0560385 -0.8667671 -0.6367261 0.1147079 1.4362691 1.7032165 0.5718267 0.4811270 0.4921173 -0.2712677 2.0759782 -0.1613301 -1.2649484 -1.2415975 -2.1140587 -1.0865680 -1.0808892 0.0421566 -0.9521712 -0.115268 -1.2773721 -1.1683075 -0.7958224 Chapecoense -1.2048566 -1.2140744 0.4340850 1.086957 -0.8177444 0.8293948 -0.9301837 -1.1871319 -1.3814737 0.0445342 1.8668476 -0.7832664 0.6002873 0.2508784 -0.9170292 1.0662416 -0.4404172 0.5647430 -1.2757830 -0.6154952 -0.8243555 0.8021070 -0.8816307 -0.1989556 0.4693505 -0.8667671 -0.0155299 -0.3441236 0.8293948 0.1548379 -1.1876400 0.0627557 2.5284648 -0.5904062 0.8811706 1.4519708 -0.8177444 0.3778775 -0.9713242 -0.8625334 -0.7764134 -1.3630628 -0.3277966 -0.115268 -1.2773721 -1.1683075 -0.7958224 Avai -1.9241739 -1.8980600 0.4340850 1.823877 -1.6482661 1.8408519 -1.9489562 -1.9441435 -2.1784777 1.8259038 1.5007990 -1.1955119 -1.5825756 1.8188682 -1.4538268 1.5454513 -1.6494057 1.7695280 -1.2757830 -0.7101868 -0.2355302 2.8720605 -0.8816307 -0.1989556 2.8161028 -1.0660239 -0.3261280 3.5559439 1.8408519 0.9290272 1.0116933 1.3178696 0.4921173 0.6861477 1.7772763 0.6453204 -1.6482661 -1.2415975 -0.3999570 -1.5346373 -0.7764134 -1.6441066 -1.2643584 -0.691608 0.0851581 -0.2336615 -0.7958224 O próximo passo é calcular a matriz distância ou (dis)similaridade entre os objetos. Nós queremos saber o qunato odesempenho de cada time se assemelha ou diferencia de qualquer outro time. Existem muitos métodos de calcular as distância entre os objetos. Neste artigo ou neste livro Alboukadel Kassambara (2017) Alboukadel Kassambara, quem já produziu importantes materiais sobre Análise Multivariada, discute os principais métodos ou os mais comuns. Você deve ter uma ideia de como seus dados se comportam, se são presença ausência, linearmente relacionados ou possuem outra relação. POr isso é importante conhecer bem seus dados. Temos uma lista de pacotes e, obviamente, comandos para computar as ditâncias. Veja Executando os comandos abaixo e veja em cada um a lista de métodos de cálculos disponíveis. 9.1.1.1 Métodos de medida de (dis)similaridade/semelhança/distância Mas uma pergunta importante é: Qual o melhor índice? Esta resposta depende de algumas informações. 1. Você vai fazer comparações entre amostras ou entre descritores? 2. Como são seus dados (binários (presença-ausência), abundância, contínuos, ordianis e etc)? 3. Sua tabela é homogênea ou heterogênea? Existem índices mais adequados que outros para cada tipo de dado. para saber mais detalhes sobre a escolha do índice leia Valentin (1995), Albuquerque et al. (2016), Gower (1986), Daniel Borcard (2018) e tanto outros que encontrarem. ?dist # Do pacote stats ?vegan::vegdist # Do pacote vegan ?analogue::distance # Do pacote analogue ?factorextra::get_dist # Do pacote factorextra No nosso caso eu vou utilizar a distância euclidiana do pactote vegan, pois temos apenas dados numéricos e há certa linearidade entre os dados. Caso o resultado fique “estranho” poderei voltar e testar outros métodos. Vejam que o pacote veganoferece diferentes ,étodos de standardização. ?vegan::decostand Com o heatmap abaixo temos uma ideia da semelhança do desempenho entre os clubes. Quando temos o valor 0 (zero) temos que desempenhos idênticos e quanto maior a diferença entre os times maior será o número (distância). Ainda assim fica difícil comparar todos os clubes de um só vez. Por isto, vamos focar em construir um dendograma ou agrupar nossos times. camp.bras19.stan.ch &lt;- vegdist(camp.bras19.stan, &quot;euc&quot;) fviz_dist(camp.bras19.stan.ch) 9.1.1.2 Métodos de “linkagem” No entanto, o agrupamento a ser produzido também depende de algumas decisões a serem tomadas. Como vamos juntar os times? Vamos utilizar juntar aqueles com menor distância até que todos estejam agrupados (Single Linkage)? Vamos utlizar a maior (Complete Linkage)? Vamos utilizar a distância média aritmética (UPGMA ou WPGMA) ou centroid (UPGMC ou WPGMC)? Vamos utilizar a mínima variância (ward ou ward.D2)? Por isso temos diferentes métods de *linkagem Single e Complete par(mfrow=c(1,2)) camp.bras19.stan.ch.single &lt;- hclust(camp.bras19.stan.ch, method=&quot;single&quot;) summary(camp.bras19.stan.ch.single) ## Length Class Mode ## merge 38 -none- numeric ## height 19 -none- numeric ## order 20 -none- numeric ## labels 20 -none- character ## method 1 -none- character ## call 3 -none- call ## dist.method 1 -none- character plot(camp.bras19.stan.ch.single, main = &quot;Single-linkage&quot;) rect.hclust(camp.bras19.stan.ch.single,k = 4) camp.bras19.stan.ch.complete &lt;- hclust(camp.bras19.stan.ch, method=&quot;complete&quot;) summary(camp.bras19.stan.ch.complete) ## Length Class Mode ## merge 38 -none- numeric ## height 19 -none- numeric ## order 20 -none- numeric ## labels 20 -none- character ## method 1 -none- character ## call 3 -none- call ## dist.method 1 -none- character plot(camp.bras19.stan.ch.complete, main = &quot;Complete-linkage&quot;) rect.hclust(camp.bras19.stan.ch.complete,k = 4) Distância Média par(mfrow=c(1,2)) camp.bras19.stan.ch.UPGMA.average &lt;- hclust(camp.bras19.stan.ch, method=&quot;average&quot;) summary(camp.bras19.stan.ch.UPGMA.average) ## Length Class Mode ## merge 38 -none- numeric ## height 19 -none- numeric ## order 20 -none- numeric ## labels 20 -none- character ## method 1 -none- character ## call 3 -none- call ## dist.method 1 -none- character plot(camp.bras19.stan.ch.UPGMA.average, main = &quot;UPGMA-linkage&quot;) rect.hclust(camp.bras19.stan.ch.UPGMA.average,k = 4) camp.bras19.stan.ch.UPGMA.centroid &lt;- hclust(camp.bras19.stan.ch, method=&quot;centroid&quot;) summary(camp.bras19.stan.ch.UPGMA.centroid) ## Length Class Mode ## merge 38 -none- numeric ## height 19 -none- numeric ## order 20 -none- numeric ## labels 20 -none- character ## method 1 -none- character ## call 3 -none- call ## dist.method 1 -none- character plot(camp.bras19.stan.ch.UPGMA.centroid, main = &quot;UPGMA-centroid&quot;) rect.hclust(camp.bras19.stan.ch.UPGMA.centroid,k = 4) par(mfrow=c(1,2)) camp.bras19.stan.ch.WPGMA.median &lt;- hclust(camp.bras19.stan.ch, method=&quot;median&quot;) summary(camp.bras19.stan.ch.WPGMA.median) ## Length Class Mode ## merge 38 -none- numeric ## height 19 -none- numeric ## order 20 -none- numeric ## labels 20 -none- character ## method 1 -none- character ## call 3 -none- call ## dist.method 1 -none- character plot(camp.bras19.stan.ch.WPGMA.median, main = &quot;WPGMA-median&quot;) rect.hclust(camp.bras19.stan.ch.WPGMA.median,k = 4) camp.bras19.stan.ch.WPGMA.mcquitty &lt;- hclust(camp.bras19.stan.ch, method=&quot;mcquitty&quot;) summary(camp.bras19.stan.ch.WPGMA.mcquitty) ## Length Class Mode ## merge 38 -none- numeric ## height 19 -none- numeric ## order 20 -none- numeric ## labels 20 -none- character ## method 1 -none- character ## call 3 -none- call ## dist.method 1 -none- character plot(camp.bras19.stan.ch.WPGMA.mcquitty, main = &quot;WPGMA-mcquitty&quot;) rect.hclust(camp.bras19.stan.ch.WPGMA.mcquitty,k = 4) Mínima Variância par(mfrow=c(1,2)) camp.bras19.stan.ch.ward &lt;- hclust(camp.bras19.stan.ch, method=&quot;ward.D&quot;) summary(camp.bras19.stan.ch.ward) ## Length Class Mode ## merge 38 -none- numeric ## height 19 -none- numeric ## order 20 -none- numeric ## labels 20 -none- character ## method 1 -none- character ## call 3 -none- call ## dist.method 1 -none- character plot(camp.bras19.stan.ch.ward, main=&quot;Ward.D&quot;, cex=0.6) rect.hclust(camp.bras19.stan.ch.ward,k = 5) camp.bras19.stan.ch.ward2 &lt;- hclust(camp.bras19.stan.ch, method=&quot;ward.D2&quot;) summary(camp.bras19.stan.ch.ward2) ## Length Class Mode ## merge 38 -none- numeric ## height 19 -none- numeric ## order 20 -none- numeric ## labels 20 -none- character ## method 1 -none- character ## call 3 -none- call ## dist.method 1 -none- character plot(camp.bras19.stan.ch.ward2, main=&quot;Ward.D2&quot;, cex=0.6) rect.hclust(camp.bras19.stan.ch.ward2,k = 5) 9.1.1.3 Escolha do método de “linkagem” 9.1.1.3.1 Distância Cofenética Diante de tantos métodos fica difícil e até meio incomodo decidir qual métodos de “linkagem” utilizar baseando-se apenas na intuição (embora não deva ser descartada). Podemos utilizar alguns métodos para nos auxiliar na decisão de qual link utilizar como a distância cofenética. A distância cofenética entre dois objetos em um dendrograma é a distância em que os dois objetos se tornam membros do mesmo grupo. Localize dois objetos quaisquer, comece de um e “suba na árvore” até o primeiro nó que leva ao segundo objeto: o nível desse nó ao longo da escala de distância é a distância cofenética entre os dois objetos. Uma matriz cofenética é uma matriz que representa as distâncias cofenéticas entre todos os pares de objetos. Uma correlação r de Pearson, chamada de correlação cofenética neste contexto, pode ser calculada entre a matriz de dissimilaridade original e a matriz cofenética. O método com maior correlação cofenética pode ser visto como aquele que produz o modelo de agrupamento que retém a maior parte das informações contidas na matriz de dissimilaridade. Isso não significa necessariamente, no entanto, que esse modelo de agrupamento seja o mais adequado para o objetivo do pesquisador. Daniel Borcard (2018) Leia mais em Comparison of hierarchical cluster analysis methods by cophenetic correlation # Cophenetic correlations e Shepard-like diagrams par(mfrow = c(1,2 )) camp.bras19.stan.ch.single.coph &lt;- cophenetic(camp.bras19.stan.ch.single) cor(camp.bras19.stan.ch, camp.bras19.stan.ch.single.coph) ## [1] 0.7290224 plot(camp.bras19.stan.ch,camp.bras19.stan.ch.single.coph, xlab = &quot;Distância Euclidiana&quot;, ylab = &quot;distância cofenética&quot;, asp = 1, xlim = c(0, 21), ylim = c(0, 10), main = c(&quot;Single linkage&quot;, paste(&quot;correlação cofenética =&quot;, round(cor(camp.bras19.stan.ch, camp.bras19.stan.ch.single.coph),3)))) abline(0, 1) lines(lowess(camp.bras19.stan.ch, camp.bras19.stan.ch.single.coph), col = &quot;red&quot;) camp.bras19.stan.ch.comp.coph &lt;- cophenetic(camp.bras19.stan.ch.complete) cor(camp.bras19.stan.ch, camp.bras19.stan.ch.comp.coph) ## [1] 0.4648164 plot(camp.bras19.stan.ch,camp.bras19.stan.ch.comp.coph, xlab = &quot;Distância Euclidiana&quot;, ylab = &quot;distância cofenética&quot;, asp = 1, xlim = c(0, 21), ylim = c(0, 25), main = c(&quot;Complete linkage&quot;, paste(&quot;correlação cofenética =&quot;, round(cor(camp.bras19.stan.ch, camp.bras19.stan.ch.comp.coph),3)))) abline(0, 1) lines(lowess(camp.bras19.stan.ch, camp.bras19.stan.ch.comp.coph), col = &quot;red&quot;) camp.bras19.stan.ch.UPGMA.average.coph &lt;- cophenetic(camp.bras19.stan.ch.UPGMA.average) cor(camp.bras19.stan.ch, camp.bras19.stan.ch.UPGMA.average.coph) ## [1] 0.7511187 plot(camp.bras19.stan.ch,camp.bras19.stan.ch.UPGMA.average.coph, xlab = &quot;Distância Euclidiana&quot;, ylab = &quot;distância cofenética&quot;, asp = 1, xlim = c(0, 21), ylim = c(0, 20), main = c(&quot;UPGMA Average&quot;, paste(&quot;correlação cofenética =&quot;, round(cor(camp.bras19.stan.ch, camp.bras19.stan.ch.UPGMA.average.coph),3)))) abline(0, 1) lines(lowess(camp.bras19.stan.ch, camp.bras19.stan.ch.UPGMA.average.coph), col = &quot;red&quot;) camp.bras19.stan.ch.UPGMA.centroid.coph &lt;- cophenetic(camp.bras19.stan.ch.UPGMA.centroid) cor(camp.bras19.stan.ch, camp.bras19.stan.ch.UPGMA.centroid.coph) ## [1] 0.7224266 plot(camp.bras19.stan.ch,camp.bras19.stan.ch.UPGMA.centroid.coph, xlab = &quot;Distância Euclidiana&quot;, ylab = &quot;distância cofenética&quot;, asp = 1, xlim = c(0, 21), ylim = c(0, 10), main = c(&quot;UPGMA centroid&quot;, paste(&quot;correlação cofenética =&quot;, round(cor(camp.bras19.stan.ch, camp.bras19.stan.ch.UPGMA.centroid.coph),3)))) abline(0, 1) lines(lowess(camp.bras19.stan.ch, camp.bras19.stan.ch.UPGMA.centroid.coph), col = &quot;red&quot;) camp.bras19.stan.ch.WPGMA.median.coph &lt;- cophenetic(camp.bras19.stan.ch.WPGMA.median) cor(camp.bras19.stan.ch, camp.bras19.stan.ch.WPGMA.median.coph) ## [1] 0.5137852 plot(camp.bras19.stan.ch,camp.bras19.stan.ch.WPGMA.median.coph, xlab = &quot;Distância Euclidiana&quot;, ylab = &quot;distância cofenética&quot;, asp = 1, xlim = c(0, 21), ylim = c(0, 10), main = c(&quot;WPGMA median&quot;, paste(&quot;correlação cofenética =&quot;, round(cor(camp.bras19.stan.ch, camp.bras19.stan.ch.WPGMA.median.coph),3)))) abline(0, 1) lines(lowess(camp.bras19.stan.ch, camp.bras19.stan.ch.WPGMA.median.coph), col = &quot;red&quot;) camp.bras19.stan.ch.WPGMA.mcquitty.coph &lt;- cophenetic(camp.bras19.stan.ch.WPGMA.mcquitty) cor(camp.bras19.stan.ch, camp.bras19.stan.ch.WPGMA.mcquitty.coph) ## [1] 0.4999633 plot(camp.bras19.stan.ch,camp.bras19.stan.ch.WPGMA.mcquitty.coph, xlab = &quot;Distância Euclidiana&quot;, ylab = &quot;distância cofenética&quot;, asp = 1, xlim = c(0, 21), ylim = c(0, 20), main = c(&quot;WPGMA mcquitty&quot;, paste(&quot;correlação cofenética =&quot;, round(cor(camp.bras19.stan.ch, camp.bras19.stan.ch.WPGMA.mcquitty.coph),3)))) abline(0, 1) lines(lowess(camp.bras19.stan.ch, camp.bras19.stan.ch.WPGMA.mcquitty.coph), col = &quot;red&quot;) camp.bras19.stan.ch.ward.coph &lt;- cophenetic(camp.bras19.stan.ch.ward) cor(camp.bras19.stan.ch, camp.bras19.stan.ch.ward.coph) ## [1] 0.4769175 plot(camp.bras19.stan.ch,camp.bras19.stan.ch.ward.coph, xlab = &quot;Distância Euclidiana&quot;, ylab = &quot;distância cofenética&quot;, asp = 1, xlim = c(0, 21), ylim = c(0, 35), main = c(&quot;Ward&quot;, paste(&quot;correlação cofenética =&quot;, round(cor(camp.bras19.stan.ch, camp.bras19.stan.ch.ward.coph),3)))) abline(0, 1) lines(lowess(camp.bras19.stan.ch, camp.bras19.stan.ch.ward.coph), col = &quot;red&quot;) camp.bras19.stan.ch.ward2.coph &lt;- cophenetic(camp.bras19.stan.ch.ward2) cor(camp.bras19.stan.ch, camp.bras19.stan.ch.ward2.coph) ## [1] 0.4877169 cor(camp.bras19.stan.ch, camp.bras19.stan.ch.ward2.coph, method=&quot;spearman&quot;) ## [1] 0.5368379 plot(camp.bras19.stan.ch,camp.bras19.stan.ch.ward2.coph, xlab = &quot;Distância Euclidiana&quot;, ylab = &quot;distância cofenética&quot;, asp = 1, xlim = c(0, 21), ylim = c(0, 25), main = c(&quot;ward2&quot;, paste(&quot;correlação cofenética =&quot;, round(cor(camp.bras19.stan.ch, camp.bras19.stan.ch.ward2.coph),3)))) abline(0, 1) lines(lowess(camp.bras19.stan.ch, camp.bras19.stan.ch.ward2.coph), col = &quot;red&quot;) camp.bras19.stan.ch.ward2.coph &lt;- cophenetic(camp.bras19.stan.ch.ward2) cor(camp.bras19.stan.ch, camp.bras19.stan.ch.ward2.coph) ## [1] 0.4877169 cor(camp.bras19.stan.ch, camp.bras19.stan.ch.ward2.coph, method=&quot;spearman&quot;) ## [1] 0.5368379 plot(camp.bras19.stan.ch,camp.bras19.stan.ch.ward2.coph, xlab = &quot;Distância Euclidiana&quot;, ylab = &quot;distância cofenética&quot;, asp = 1, xlim = c(0, 21), ylim = c(0, 25), main = c(&quot;ward2&quot;, paste(&quot;correlação cofenética =&quot;, round(cor(camp.bras19.stan.ch, camp.bras19.stan.ch.ward2.coph, method=&quot;spearman&quot;),3)))) abline(0, 1) lines(lowess(camp.bras19.stan.ch, camp.bras19.stan.ch.ward2.coph), col = &quot;red&quot;) 9.1.1.3.2 Distância de Gower Outra estatística possível para a comparação dos resultados de agrupamento é a distância de Gower (1983), calculada como a soma das diferenças quadradas entre as dissimilaridades originais e as distâncias cofenéticas. O método de agrupamento que produz a menor distância de Gower pode ser visto como aquele que fornece o melhor modelo de agrupamento da matriz de dissimilaridade. A correlação cofenética e os critérios de distância de Gower nem sempre designam o mesmo resultado de agrupamento como o melhor. Daniel Borcard (2018) Atenção! Não confunda com medida de dissimilaridade de Gower disponível em ?vegan::vegdist. # Gower (1983) distance gow.dist.single &lt;- sum((camp.bras19.stan.ch-camp.bras19.stan.ch.single.coph)^2) gow.dist.comp &lt;- sum((camp.bras19.stan.ch-camp.bras19.stan.ch.comp.coph)^2) gow.dist.UPGMA.average &lt;- sum((camp.bras19.stan.ch-camp.bras19.stan.ch.UPGMA.average.coph)^2) gow.dist.UPGMA.centroid &lt;- sum((camp.bras19.stan.ch-camp.bras19.stan.ch.UPGMA.centroid.coph)^2) gow.dist.WPGMA.median &lt;- sum((camp.bras19.stan.ch-camp.bras19.stan.ch.WPGMA.median.coph)^2) gow.dist.WPGMA.mcquitty &lt;- sum((camp.bras19.stan.ch-camp.bras19.stan.ch.WPGMA.mcquitty.coph)^2) gow.dist.ward &lt;- sum((camp.bras19.stan.ch-camp.bras19.stan.ch.ward.coph)^2) gow.dist.ward2 &lt;- sum((camp.bras19.stan.ch-camp.bras19.stan.ch.ward2.coph)^2) Gower Distance para Single Linkage é 1782.5363281. Gower Distance para Complete Linkage é 12473.9494. Gower Distance para UPGMA average é 541.7935889. Gower Distance para UPGMA centroid é 3003.7463194. Gower Distance para WPGMA median é 3191.3726267. Gower Distance para WPGMA mcquitty é 3359.1155035. Gower Distance para Ward é 37449.9793551. Gower Distance para Ward 2 é 16453.7138985. 9.1.2 Quantos grupos reter Uma vez definido o método de “linkagen” o próximo passo é definir quantos cluster vamos manter. Deve ser um número que permita uma interpretação clara. No final das contas nós vamos tomar a decisão de onde cortar a nossa árvores, em qual altura. Podemos nos guiar por alguns procedimentos ou por uma inspeção visual 9.1.2.1 Gráfico de valores de fusão de níveis O nível dos valores de fusões de um dendograma são a dissimilaridade onde a fusão entre 2 galhos ocorrem. par(mfrow=c(2,2)) plot(camp.bras19.stan.ch.single$height, nrow(camp.bras19):2, type=&quot;S&quot;, main=&quot;Fusion levels - euc \\nSingle&quot;, ylab=&quot;k (number of clusters)&quot;, xlab=&quot;h (node height)&quot;, col=&quot;grey&quot;) text(camp.bras19.stan.ch.single$height, nrow(camp.bras19):2, nrow(camp.bras19):2, col=&quot;red&quot;, cex=0.8) plot(camp.bras19.stan.ch.complete$height, nrow(camp.bras19):2, type=&quot;S&quot;, main=&quot;Fusion levels - euc \\nComplete&quot;, ylab=&quot;k (number of clusters)&quot;, xlab=&quot;h (node height)&quot;, col=&quot;grey&quot;) text(camp.bras19.stan.ch.complete$height, nrow(camp.bras19):2, nrow(camp.bras19):2, col=&quot;red&quot;, cex=0.8) plot(camp.bras19.stan.ch.UPGMA.average$height, nrow(camp.bras19):2, type=&quot;S&quot;, main=&quot;Fusion levels - euc \\nUPGMA.average&quot;, ylab=&quot;k (number of clusters)&quot;, xlab=&quot;h (node height)&quot;, col=&quot;grey&quot;) text(camp.bras19.stan.ch.UPGMA.average$height, nrow(camp.bras19):2, nrow(camp.bras19):2, col=&quot;red&quot;, cex=0.8) plot(camp.bras19.stan.ch.UPGMA.centroid$height, nrow(camp.bras19):2, type=&quot;S&quot;, main=&quot;Fusion levels - euc \\nUPGMA.centroid&quot;, ylab=&quot;k (number of clusters)&quot;, xlab=&quot;h (node height)&quot;, col=&quot;grey&quot;) text(camp.bras19.stan.ch.UPGMA.centroid$height, nrow(camp.bras19):2, nrow(camp.bras19):2, col=&quot;red&quot;, cex=0.8) plot(camp.bras19.stan.ch.WPGMA.median$height, nrow(camp.bras19):2, type=&quot;S&quot;, main=&quot;Fusion levels - euc \\nWPGMA.median&quot;, ylab=&quot;k (number of clusters)&quot;, xlab=&quot;h (node height)&quot;, col=&quot;grey&quot;) text(camp.bras19.stan.ch.WPGMA.median$height, nrow(camp.bras19):2, nrow(camp.bras19):2, col=&quot;red&quot;, cex=0.8) plot(camp.bras19.stan.ch.WPGMA.mcquitty$height, nrow(camp.bras19):2, type=&quot;S&quot;, main=&quot;Fusion levels - euc \\nWPGMA.mcquitty&quot;, ylab=&quot;k (number of clusters)&quot;, xlab=&quot;h (node height)&quot;, col=&quot;grey&quot;) text(camp.bras19.stan.ch.WPGMA.mcquitty$height, nrow(camp.bras19):2, nrow(camp.bras19):2, col=&quot;red&quot;, cex=0.8) plot(camp.bras19.stan.ch.ward$height, nrow(camp.bras19):2, type=&quot;S&quot;, main=&quot;Fusion levels - euc \\nWard&quot;, ylab=&quot;k (number of clusters)&quot;, xlab=&quot;h (node height)&quot;, col=&quot;grey&quot;) text(camp.bras19.stan.ch.ward$height, nrow(camp.bras19):2, nrow(camp.bras19):2, col=&quot;red&quot;, cex=0.8) plot(camp.bras19.stan.ch.ward2$height, nrow(camp.bras19):2, type=&quot;S&quot;, main=&quot;Fusion levels - euc - Ward2&quot;, ylab=&quot;k (number of clusters)&quot;, xlab=&quot;h (node height)&quot;, col=&quot;grey&quot;) text(camp.bras19.stan.ch.ward2$height, nrow(camp.bras19):2, nrow(camp.bras19):2, col=&quot;red&quot;, cex=0.8) k &lt;- 4 camp.bras2019.bc.single.g &lt;- cutree(camp.bras19.stan.ch.single , k) camp.bras2019.bc.complete.g &lt;- cutree(camp.bras19.stan.ch.complete, k) camp.bras2019.bc.UPGMA.average.g &lt;- cutree(camp.bras19.stan.ch.UPGMA.average, k) camp.bras2019.bc.UPGMA.centroid.g &lt;- cutree(camp.bras19.stan.ch.UPGMA.centroid, k) camp.bras2019.bc.WPGMA.median.g &lt;- cutree(camp.bras19.stan.ch.WPGMA.median, k) camp.bras2019.bc.WPGMA.mcquitty.g &lt;- cutree(camp.bras19.stan.ch.WPGMA.mcquitty, k) camp.bras2019.bc.ward.g &lt;- cutree(camp.bras19.stan.ch.ward, k) camp.bras2019.bc.ward2.g &lt;- cutree(camp.bras19.stan.ch.ward2, k) camp.bras2019.bc&lt;-cbind(camp.bras2019.bc.single.g,camp.bras2019.bc.complete.g, camp.bras2019.bc.UPGMA.average.g,camp.bras2019.bc.UPGMA.centroid.g, camp.bras2019.bc.WPGMA.median.g,camp.bras2019.bc.WPGMA.mcquitty.g, camp.bras2019.bc.ward.g,camp.bras2019.bc.ward2.g ) colnames(camp.bras2019.bc)&lt;-c(&quot;Single&quot;,&quot;Complete&quot;,&quot;UPGMA.Ave&quot;,&quot;UPGMA.Cent&quot;,&quot;WPGMA.medi&quot;,&quot;WPGMA.mcq&quot;,&quot;Ward&quot;,&quot;Ward2&quot;) camp.bras2019.bc %&gt;% knitr::kable() Single Complete UPGMA.Ave UPGMA.Cent WPGMA.medi WPGMA.mcq Ward Ward2 Flamengo 1 1 1 1 1 1 1 1 Santos 2 1 2 2 2 2 2 2 Palmeiras 3 1 2 2 3 2 2 2 Gremio 3 1 2 2 3 2 2 2 Athletico Paranaense 3 2 2 2 4 2 2 2 Sao Paulo 3 2 2 2 3 2 2 2 Internacional 3 2 2 2 3 2 2 2 Corinthians 3 2 2 2 3 2 2 2 Fortaleza 3 2 3 2 3 3 3 3 Goias 3 3 3 3 3 3 3 3 Bahia 3 2 3 2 3 3 3 3 Vasco 3 2 3 2 3 3 3 3 Atletico Mineiro 3 3 3 2 3 3 3 3 Fluminense 3 3 3 2 3 3 3 3 Botafogo 3 3 3 2 3 3 3 3 Ceara 3 3 3 2 3 3 3 3 Cruzeiro 3 4 3 2 3 3 4 4 CSA 3 4 3 2 3 3 4 4 Chapecoense 3 4 3 2 3 3 4 4 Avai 4 4 4 4 3 4 4 4 asw &lt;- numeric(nrow(camp.bras19.stan)) for (k in 2:(nrow(camp.bras19.stan)-1)) { sil &lt;- silhouette(cutree(camp.bras19.stan.ch.ward, k=k), camp.bras19.stan.ch) asw[k] &lt;- summary(sil)$avg.width } k.best &lt;- which.max(asw) plot(1:nrow(camp.bras19.stan), asw, type=&quot;h&quot;, main=&quot;Número ótimo de cluster de acordo com Silhouette e Ward&quot;, xlab=&quot;k (número de grupos)&quot;, ylab=&quot;Silhouette width média&quot;) axis(1, k.best, paste(&quot;optimum&quot;,k.best,sep=&quot;\\n&quot;), col=&quot;red&quot;, font=2, col.axis=&quot;red&quot;) points(k.best, max(asw), pch=16, col=&quot;red&quot;, cex=1.5) cat(&quot;&quot;, &quot;Número ótimo de cluster de acordo com Silhouette k =&quot;, k.best, &quot;\\n&quot;, &quot;com Silhouette width média com&quot;, max(asw), &quot;\\n&quot;) ## Número ótimo de cluster de acordo com Silhouette k = 2 ## com Silhouette width média com 0.1976803 9.1.2.1.1 Comparando dois Agrupamentos Aqui vamos comparar dendogramas utilizando a função tangelgram() do pacote dendextend, pois estamos na dúvida sobre qual utilizar. # Objects of class &quot;hclust&quot; must be first converted into objects of # class &quot;dendrogram&quot; library(dendextend) ## Registered S3 method overwritten by &#39;dendextend&#39;: ## method from ## rev.hclust vegan ## ## --------------------- ## Welcome to dendextend version 1.17.1 ## Type citation(&#39;dendextend&#39;) for how to cite the package. ## ## Type browseVignettes(package = &#39;dendextend&#39;) for the package vignette. ## The github page is: https://github.com/talgalili/dendextend/ ## ## Suggestions and bug-reports can be submitted at: https://github.com/talgalili/dendextend/issues ## You may ask questions at stackoverflow, use the r and dendextend tags: ## https://stackoverflow.com/questions/tagged/dendextend ## ## To suppress this message use: suppressPackageStartupMessages(library(dendextend)) ## --------------------- ## ## Attaching package: &#39;dendextend&#39; ## The following object is masked from &#39;package:gclus&#39;: ## ## order.hclust ## The following object is masked from &#39;package:mosaic&#39;: ## ## shuffle ## The following object is masked from &#39;package:ggpubr&#39;: ## ## rotate ## The following object is masked from &#39;package:permute&#39;: ## ## shuffle ## The following object is masked from &#39;package:stats&#39;: ## ## cutree class(camp.bras19.stan.ch.UPGMA.average) # [1] &quot;hclust&quot; ## [1] &quot;hclust&quot; dend1 &lt;- as.dendrogram(camp.bras19.stan.ch.UPGMA.average) class(dend1) # [1] &quot;dendrogram&quot; ## [1] &quot;dendrogram&quot; dend2 &lt;- as.dendrogram(camp.bras19.stan.ch.ward2) dend12 &lt;- dendlist(dend1, dend2) tanglegram( untangle(dend12), sort = TRUE, common_subtrees_color_branches = TRUE, main_left = &quot;Método Ward2&quot;, main_right = &quot;Métodos UPGMA.average&quot; ) 9.1.2.2 Comparando agrupamentos flexíveis Daniel Borcard (2018) traz um método proposto por Lance and Williams (1966, 1967) que compara todos os métodos apresentados até agora através da implementação da função agnes() do pacote cluster. # Compute beta-flexible clustering using cluster::agnes() # beta = -0.1 camp.bras19.stan.ch.beta1 &lt;- agnes(camp.bras19.stan.ch, method = &quot;flexible&quot;, par.method = 0.55) # beta = -0.25 camp.bras19.stan.ch.beta2 &lt;- agnes(camp.bras19.stan.ch, method = &quot;flexible&quot;, par.method = 0.625) # beta = -0.5 camp.bras19.stan.ch.beta3 &lt;- agnes(camp.bras19.stan.ch, method = &quot;flexible&quot;, par.method = 0.75) # Change the class of agnes objects class(camp.bras19.stan.ch.beta1) ## [1] &quot;agnes&quot; &quot;twins&quot; camp.bras19.stan.ch.beta1 &lt;- as.hclust(camp.bras19.stan.ch.beta1) class(camp.bras19.stan.ch.beta1) ## [1] &quot;hclust&quot; camp.bras19.stan.ch.beta2 &lt;- as.hclust(camp.bras19.stan.ch.beta2) camp.bras19.stan.ch.beta3 &lt;- as.hclust(camp.bras19.stan.ch.beta3) par(mfrow=c(1,3)) plot(camp.bras19.stan.ch.beta1, labels = rownames(camp.bras19), main = &quot;Chord - Beta-flexible (beta=-0.1)&quot;) plot(camp.bras19.stan.ch.beta2, labels = rownames(camp.bras19), main = &quot;Chord - Beta-flexible (beta=-0.25)&quot;) plot(camp.bras19.stan.ch.beta3, labels = rownames(camp.bras19), main = &quot;Chord - Beta-flexible (beta=-0.5)&quot;) k &lt;- 4 cutg &lt;- cutree(camp.bras19.stan.ch.ward2, k=k) sil &lt;- silhouette(cutg, camp.bras19.stan.ch) rownames(sil) &lt;- row.names(camp.bras19.stan.ch) plot(sil, main=&quot;Silhouette plot - euc - Ward&quot;, cex.names=0.8, col=2:(k+1), nmax=100) camp.bras2019.chwo&lt;-reorder(camp.bras19.stan.ch.ward2, camp.bras19.stan.ch) plot(camp.bras2019.chwo, hang = -1,xlab = &quot;2 grupos&quot;,sub = &quot;&quot;, ylab = &quot;Height&quot;,main = &quot;euc - Ward (reordered)&quot;, labels = cutree(camp.bras2019.chwo, k = k) ) library(gclus) camp.bras19.chwo &lt;- reorder.hclust(camp.bras19.stan.ch.ward2, camp.bras19.stan.ch) # Plot reordered dendrogram with group labels plot(camp.bras19.chwo,hang = -1,xlab = &quot;4 groupos&quot;,sub = &quot;&quot;, ylab = &quot;Altura&quot;, main = &quot;Euclidean - Ward2 (reordered)&quot;, labels = cutree(camp.bras19.chwo, k = k)) rect.hclust(camp.bras19.chwo, k = k) # Plot the final dendrogram with group colors (RGBCMY...) # Fast method using the additional hcoplot() function: source(&quot;J:/ENG 792/ENG_792-AVDR/hcoplot.R&quot;) hcoplot(camp.bras19.stan.ch.ward2, camp.bras19.stan.ch, lab = rownames(camp.bras19), k = 4) dend &lt;- as.dendrogram(camp.bras19.chwo) # Plot the dendrogram with coloured branches dend %&gt;% set(&quot;branches_k_color&quot;, k = k) %&gt;% plot # Use standard colours for clusters clusters &lt;- cutree(dend, k)[order.dendrogram(dend)] dend %&gt;% set(&quot;branches_k_color&quot;, k = k, value = unique(clusters) + 1) %&gt;% plot # Add a coloured bar colored_bars(clusters + 1, y_shift = -0.5, rowLabels = paste(k, &quot;clusters&quot;)) heatmap(as.matrix(camp.bras19.stan.ch),Rowv = dend, symm = TRUE,margin = c(3, 3)) 9.1.3 Cluster não hierárquico No procedimento de construção de clusters não hierárquicos o número de grupos é inicialmente conhecido. Desta forma, vamos particionando nossos objetos até que todos estejam agrupados de acordo com suas semelhanças. 9.1.3.0.1 K-means É o método unsipervised mais utilizado principalmente em machine learning. O K representa o número de grupos a priori definidos. No métodos de K-means cada cluster é representado por seu centro (centroid) que corresponde à média dos pontos definidos para o cluster. A primeira coisa que devemos estabelelcer é o número de clusters. O algorítmo vai selecionar aleatoriamente k objetos da base de dados para servir como centros iniciais. Os objetos são atribuídos ao seu centroid mais próximo. Os centroid são recalculados a cada iteração. Iterativamente minimiza o total da soma dos quadrados dentro dos grupos iterando os passos 3 e 4 até que as distribuições parem ou o máximo número de iterações pe alcançado. kmeans(x, centers, iter.max = 10, nstart = 1) Identificando o melhor número de clusters. Vamos calcular o agrupamento k-means usando diferentes valores dos clusters k. Em seguida, o wss (soma dos quadrado dentro dos grupos) é calculado de acordo com o número de clusters. A localização da quebra no gráfico é geralmente considerada como um indicador do número apropriado de grupos. K-means é um dos procedimentos mais comuns na condução da análise de agrupamento, pois na maioria das vezes temos uma ideia de quantos grupos temos em nossos dados. camp.bras19.stan.ch.kmeans&lt;- kmeans(camp.bras19.stan.ch, centers = 4, nstart=100) camp.bras19.stan.ch.kmeans ## K-means clustering with 4 clusters of sizes 1, 5, 5, 9 ## ## Cluster means: ## Flamengo Santos Palmeiras Gremio Athletico Paranaense Sao Paulo ## 1 0.00000 9.017424 9.276192 9.012423 10.765812 12.469662 ## 2 17.29050 13.065349 12.839576 11.655762 12.514955 10.839846 ## 3 10.10830 6.363613 5.159455 5.445392 6.376761 5.790060 ## 4 13.40827 9.361033 9.182023 8.052378 8.868434 7.901566 ## Internacional Corinthians Fortaleza Goias Bahia Vasco ## 1 11.979384 12.601243 12.214794 14.569269 12.882355 13.363198 ## 2 9.779751 10.245117 9.880310 7.622401 9.672697 9.349673 ## 3 7.371374 7.497392 8.385889 11.167998 8.738761 8.697107 ## 4 5.883992 6.547480 6.455535 9.186120 6.174801 6.345399 ## Atletico Mineiro Fluminense Botafogo Ceara Cruzeiro CSA ## 1 13.328485 14.295353 14.966763 15.042892 16.381046 17.704587 ## 2 8.191093 8.177561 8.274471 8.660244 6.829590 5.896205 ## 3 8.718693 9.007088 9.765503 9.875975 11.044724 12.296911 ## 4 6.195042 6.153444 6.465339 6.728513 8.189876 8.932694 ## Chapecoense Avai ## 1 16.950703 20.846912 ## 2 6.067514 7.204532 ## 3 11.108793 15.297062 ## 4 8.149719 11.225433 ## ## Clustering vector: ## Flamengo Santos Palmeiras ## 1 3 3 ## Gremio Athletico Paranaense Sao Paulo ## 3 3 3 ## Internacional Corinthians Fortaleza ## 4 4 4 ## Goias Bahia Vasco ## 2 4 4 ## Atletico Mineiro Fluminense Botafogo ## 4 4 4 ## Ceara Cruzeiro CSA ## 4 2 2 ## Chapecoense Avai ## 2 2 ## ## Within cluster sum of squares by cluster: ## [1] 0.0000 469.7166 281.8806 520.5676 ## (between_SS / total_SS = 63.3 %) ## ## Available components: ## ## [1] &quot;cluster&quot; &quot;centers&quot; &quot;totss&quot; &quot;withinss&quot; &quot;tot.withinss&quot; ## [6] &quot;betweenss&quot; &quot;size&quot; &quot;iter&quot; &quot;ifault&quot; #install.packages(&quot;factoextra&quot;) library(factoextra) library(NbClust) #silhouette camp.bras19.standart&lt;-decostand(camp.bras19[,2:54],method=&quot;standardize&quot;) ## Warning in decostand(camp.bras19[, 2:54], method = &quot;standardize&quot;): result contains NaN, perhaps due to impossible mathematical ## operation camp.bras19.standart&lt;-camp.bras19.standart[ , -which(colnames(camp.bras19.standart) %in% c(&quot;GS.91.105&quot;,&quot;GS.106.120&quot;,&quot;GS.120&quot;,&quot;GM.91.105&quot;,&quot;GM.106.120&quot;,&quot;GM.120&quot;))] fviz_nbclust(camp.bras19.standart, kmeans, method = &quot;wss&quot;) + geom_vline(xintercept = 2, linetype = 2) #elbow fviz_nbclust(camp.bras19.standart, kmeans, method = &quot;silhouette&quot;)+ labs(subtitle = &quot;Silhouette method&quot;) camp.bras2019.kmeans &lt;- kmeans(camp.bras19.standart, 4, nstart = 100) print(camp.bras2019.kmeans) ## K-means clustering with 4 clusters of sizes 4, 9, 1, 6 ## ## Cluster means: ## P V E D GP GC SG ## 1 -1.3247428 -1.3423217 0.5245193 1.179072 -1.2010621 1.0822591 -1.3066866 ## 2 -0.2191254 -0.1690964 -0.2491969 0.309097 -0.1504877 0.3011894 -0.2362371 ## 3 2.2718440 2.3768498 -1.3746024 -1.860723 2.6960012 -0.6877908 2.1704285 ## 4 0.8332093 0.7523841 0.2532162 -0.939573 0.5771061 -1.0586584 0.8637420 ## Aprov. VC EC DC VF EF DF ## 1 -1.3247704 -1.3814737 0.8238834 1.22626263 -1.0924505 -0.2182863 0.9564738 ## 2 -0.2236625 -0.1121709 0.1434992 0.03660485 -0.2794108 -0.1879687 0.3205668 ## 3 2.2538301 2.0722105 -1.2914930 -1.79363787 2.5146974 -0.4911441 -1.6307094 ## 4 0.8430357 0.7438704 -0.5492556 -0.57347605 0.7283003 0.5093347 -0.8467145 ## GPC GCC GPF GCF RVV A ## 1 -1.0959618 1.0063404 -1.13126781 0.9788879 -1.09352832 -0.02367289 ## 2 -0.1913584 0.1610677 -0.03742107 0.3472124 0.10125262 0.11047350 ## 3 2.6616214 0.1078222 2.15027240 -1.0918365 3.09833025 0.42611207 ## 4 0.5740752 -0.9304655 0.45193142 -0.9914377 0.06075157 -0.22094700 ## X2A VE VCS ECS DCS JSSP ## 1 0.2060889 0.54336280 -0.8816307 0.5471279 1.34938257 -0.5180677 ## 2 0.1570201 -0.06037364 -0.4066781 -0.3094865 -0.05215005 -0.4239742 ## 3 -0.2355302 -0.75035815 2.3242992 -1.1937336 -1.29071377 3.3176256 ## 4 -0.3336677 -0.14662171 0.8103878 0.2984334 -0.60624435 0.4284021 ## JSP JSG GS GS.1.15 GS.16.30 GS.31.45 ## 1 -0.4037775 1.2044326 1.0822591 0.6387062 0.1319600 0.376534172 ## 2 0.0534919 -0.1911798 0.3011894 -0.1032252 0.3274563 -0.123187106 ## 3 -0.6367261 -0.3441236 -0.6877908 -0.6193514 0.1319600 -0.355615607 ## 4 0.2950682 -0.4588315 -1.0586584 -0.1677410 -0.6011511 -0.006972855 ## GS.46.60 GS.61.75 GS.76.90 GS.90 G GM.1.15 ## 1 0.83150856 0.04787077 1.3292234 0.6453204 -1.2010621 -0.6342944 ## 2 -0.03582463 0.68614773 0.1841995 0.1075534 -0.1504877 -0.3418892 ## 3 -0.18666519 -0.27126771 -0.9110408 -0.1613301 2.6960012 1.4575275 ## 4 -0.46949123 -1.01592416 -1.0106081 -0.5646553 0.5771061 0.6927754 ## GM.16.30 GM.31.45 GM.46.60 GM.61.75 GM.76.90 GM.90 ## 1 -1.3998496 -1.03055935 -0.7002944 -0.8712360 -1.03021797 -0.40343802 ## 2 0.4888364 -0.04107302 -0.4042763 -0.1139789 0.01907811 -0.05123023 ## 3 -0.9713242 3.17009017 1.9638692 2.5715514 2.16970148 1.03741206 ## 4 0.3618659 0.22030073 0.7459658 0.3232005 0.29657790 0.17290201 ## PEN PENF PEND ## 1 -0.59610696 -0.70098453 -0.13263707 ## 2 0.16085426 0.28558629 -0.20632433 ## 3 0.76642324 0.70098453 1.85691899 ## 4 0.02838605 -0.07788717 0.08842471 ## ## Clustering vector: ## Flamengo Santos Palmeiras ## 3 4 4 ## Gremio Athletico Paranaense Sao Paulo ## 4 4 4 ## Internacional Corinthians Fortaleza ## 2 4 2 ## Goias Bahia Vasco ## 2 2 2 ## Atletico Mineiro Fluminense Botafogo ## 2 2 2 ## Ceara Cruzeiro CSA ## 2 1 1 ## Chapecoense Avai ## 1 1 ## ## Within cluster sum of squares by cluster: ## [1] 88.90631 230.07437 0.00000 137.91395 ## (between_SS / total_SS = 48.8 %) ## ## Available components: ## ## [1] &quot;cluster&quot; &quot;centers&quot; &quot;totss&quot; &quot;withinss&quot; &quot;tot.withinss&quot; ## [6] &quot;betweenss&quot; &quot;size&quot; &quot;iter&quot; &quot;ifault&quot; camp.bras2019.clustered &lt;- cbind(camp.bras19, cluster = camp.bras2019.kmeans$cluster) head(camp.bras2019.clustered) ## Posicao P V E D GP GC SG Aprov. VC EC DC VF EF DF GPC ## Flamengo 1 90 28 6 4 86 37 49 78 17 2 0 11 4 4 56 ## Santos 2 74 22 8 8 60 33 27 64 14 4 1 8 4 7 44 ## Palmeiras 3 74 21 11 6 61 32 29 64 13 4 2 8 7 4 40 ## Gremio 4 65 19 8 11 64 39 25 57 12 3 4 7 5 7 38 ## Athletico Paranaense 5 64 18 10 10 51 32 19 56 12 3 4 6 7 6 26 ## Sao Paulo 6 63 17 12 9 39 30 9 55 10 6 3 7 6 6 23 ## GCC GPF GCF RVV A X2A VE VCS ECS DCS JSSP JSP JSG GS ## Flamengo 18 30 19 6 90 2 1 8 1 1 24 0 1 37 ## Santos 15 16 18 2 108 6 4 7 1 2 8 1 0 33 ## Palmeiras 13 21 19 1 73 1 3 7 4 3 10 2 0 32 ## Gremio 18 26 21 2 81 1 1 5 3 2 7 0 1 39 ## Athletico Paranaense 11 25 21 3 82 1 0 4 1 2 13 13 1 32 ## Sao Paulo 12 16 18 1 86 2 4 5 4 2 9 2 0 30 ## GS.1.15 GS.16.30 GS.31.45 GS.46.60 GS.61.75 GS.76.90 GS.90 ## Flamengo 4 5 8 6 6 5 3 ## Santos 3 4 6 9 4 3 4 ## Palmeiras 7 5 7 3 4 4 2 ## Gremio 8 3 12 6 3 4 3 ## Athletico Paranaense 8 2 8 1 1 9 3 ## Sao Paulo 4 1 10 6 4 4 1 ## GS.91.105 GS.106.120 GS.120 G GM.1.15 GM.16.30 GM.31.45 ## Flamengo 0 0 0 86 11 3 23 ## Santos 0 0 0 60 13 6 11 ## Palmeiras 0 0 0 61 12 5 9 ## Gremio 0 0 0 64 10 6 14 ## Athletico Paranaense 0 0 0 51 3 6 10 ## Sao Paulo 0 0 0 39 7 3 7 ## GM.46.60 GM.61.75 GM.76.90 GM.90 GM.91.105 GM.106.120 ## Flamengo 13 16 15 5 0 0 ## Santos 10 11 8 1 0 0 ## Palmeiras 11 8 12 4 0 0 ## Gremio 7 11 11 5 0 0 ## Athletico Paranaense 10 8 9 5 0 0 ## Sao Paulo 10 3 6 3 0 0 ## GM.120 PEN PENF PEND Destino cluster ## Flamengo 0 6 2 2 Libertadores 3 ## Santos 0 5 2 1 Libertadores 4 ## Palmeiras 0 5 1 1 Libertadores 4 ## Gremio 0 7 2 0 Libertadores 4 ## Athletico Paranaense 0 3 1 2 Libertadores 4 ## Sao Paulo 0 3 1 0 Libertadores 4 tail(camp.bras2019.clustered) ## Posicao P V E D GP GC SG Aprov. VC EC DC VF EF DF GPC GCC GPF ## Botafogo 15 43 13 4 21 31 45 -14 37 7 6 6 5 7 7 19 17 12 ## Ceara 16 39 10 9 19 36 41 -5 34 8 6 5 2 3 14 23 14 13 ## Cruzeiro 17 36 7 15 16 27 46 -19 31 6 5 8 2 3 14 13 17 14 ## CSA 18 32 8 8 22 24 58 -34 28 5 8 6 2 7 10 17 24 7 ## Chapecoense 19 32 7 11 20 31 52 -21 28 4 5 10 3 6 10 16 22 15 ## Avai 20 20 3 11 24 18 62 -44 17 1 9 9 2 2 15 10 24 8 ## GCF RVV A X2A VE VCS ECS DCS JSSP JSP JSG GS GS.1.15 GS.16.30 ## Botafogo 28 2 95 2 1 3 1 4 3 1 3 45 6 4 ## Ceara 27 2 86 1 1 2 2 3 3 1 7 41 1 7 ## Cruzeiro 29 0 89 5 1 2 4 5 11 0 9 46 5 5 ## CSA 34 1 95 3 1 2 3 5 3 0 3 58 10 6 ## Chapecoense 30 0 79 1 4 2 2 4 3 2 1 52 6 2 ## Avai 38 0 78 2 8 2 2 8 2 1 18 62 8 7 ## GS.31.45 GS.46.60 GS.61.75 GS.76.90 GS.90 GS.91.105 GS.106.120 ## Botafogo 7 4 12 9 3 0 0 ## Ceara 13 4 3 8 5 0 0 ## Cruzeiro 8 6 8 10 4 0 0 ## CSA 10 8 6 15 3 0 0 ## Chapecoense 9 14 5 11 5 0 0 ## Avai 12 8 9 14 4 0 0 ## GS.120 G GM.1.15 GM.16.30 GM.31.45 GM.46.60 GM.61.75 GM.76.90 ## Botafogo 0 31 2 6 7 3 7 4 ## Ceara 0 36 3 6 7 2 4 10 ## Cruzeiro 0 27 4 1 6 6 5 3 ## CSA 0 24 1 1 4 3 7 5 ## Chapecoense 0 31 7 3 5 4 2 7 ## Avai 0 18 1 4 2 4 1 4 ## GM.90 GM.91.105 GM.106.120 GM.120 PEN PENF PEND Destino ## Botafogo 2 0 0 0 0 0 0 &lt;NA&gt; ## Ceara 4 0 0 0 3 3 0 &lt;NA&gt; ## Cruzeiro 2 0 0 0 4 1 2 Rebaixamento ## CSA 3 0 0 0 0 0 0 Rebaixamento ## Chapecoense 3 0 0 0 0 0 0 Rebaixamento ## Avai 2 0 0 0 4 1 0 Rebaixamento ## cluster ## Botafogo 2 ## Ceara 2 ## Cruzeiro 1 ## CSA 1 ## Chapecoense 1 ## Avai 1 aggregate(camp.bras19.standart, by=list(cluster=camp.bras2019.kmeans$cluster), mean) ## cluster P V E D GP GC ## 1 1 -1.3247428 -1.3423217 0.5245193 1.179072 -1.2010621 1.0822591 ## 2 2 -0.2191254 -0.1690964 -0.2491969 0.309097 -0.1504877 0.3011894 ## 3 3 2.2718440 2.3768498 -1.3746024 -1.860723 2.6960012 -0.6877908 ## 4 4 0.8332093 0.7523841 0.2532162 -0.939573 0.5771061 -1.0586584 ## SG Aprov. VC EC DC VF EF ## 1 -1.3066866 -1.3247704 -1.3814737 0.8238834 1.22626263 -1.0924505 -0.2182863 ## 2 -0.2362371 -0.2236625 -0.1121709 0.1434992 0.03660485 -0.2794108 -0.1879687 ## 3 2.1704285 2.2538301 2.0722105 -1.2914930 -1.79363787 2.5146974 -0.4911441 ## 4 0.8637420 0.8430357 0.7438704 -0.5492556 -0.57347605 0.7283003 0.5093347 ## DF GPC GCC GPF GCF RVV ## 1 0.9564738 -1.0959618 1.0063404 -1.13126781 0.9788879 -1.09352832 ## 2 0.3205668 -0.1913584 0.1610677 -0.03742107 0.3472124 0.10125262 ## 3 -1.6307094 2.6616214 0.1078222 2.15027240 -1.0918365 3.09833025 ## 4 -0.8467145 0.5740752 -0.9304655 0.45193142 -0.9914377 0.06075157 ## A X2A VE VCS ECS DCS ## 1 -0.02367289 0.2060889 0.54336280 -0.8816307 0.5471279 1.34938257 ## 2 0.11047350 0.1570201 -0.06037364 -0.4066781 -0.3094865 -0.05215005 ## 3 0.42611207 -0.2355302 -0.75035815 2.3242992 -1.1937336 -1.29071377 ## 4 -0.22094700 -0.3336677 -0.14662171 0.8103878 0.2984334 -0.60624435 ## JSSP JSP JSG GS GS.1.15 GS.16.30 ## 1 -0.5180677 -0.4037775 1.2044326 1.0822591 0.6387062 0.1319600 ## 2 -0.4239742 0.0534919 -0.1911798 0.3011894 -0.1032252 0.3274563 ## 3 3.3176256 -0.6367261 -0.3441236 -0.6877908 -0.6193514 0.1319600 ## 4 0.4284021 0.2950682 -0.4588315 -1.0586584 -0.1677410 -0.6011511 ## GS.31.45 GS.46.60 GS.61.75 GS.76.90 GS.90 G ## 1 0.376534172 0.83150856 0.04787077 1.3292234 0.6453204 -1.2010621 ## 2 -0.123187106 -0.03582463 0.68614773 0.1841995 0.1075534 -0.1504877 ## 3 -0.355615607 -0.18666519 -0.27126771 -0.9110408 -0.1613301 2.6960012 ## 4 -0.006972855 -0.46949123 -1.01592416 -1.0106081 -0.5646553 0.5771061 ## GM.1.15 GM.16.30 GM.31.45 GM.46.60 GM.61.75 GM.76.90 ## 1 -0.6342944 -1.3998496 -1.03055935 -0.7002944 -0.8712360 -1.03021797 ## 2 -0.3418892 0.4888364 -0.04107302 -0.4042763 -0.1139789 0.01907811 ## 3 1.4575275 -0.9713242 3.17009017 1.9638692 2.5715514 2.16970148 ## 4 0.6927754 0.3618659 0.22030073 0.7459658 0.3232005 0.29657790 ## GM.90 PEN PENF PEND ## 1 -0.40343802 -0.59610696 -0.70098453 -0.13263707 ## 2 -0.05123023 0.16085426 0.28558629 -0.20632433 ## 3 1.03741206 0.76642324 0.70098453 1.85691899 ## 4 0.17290201 0.02838605 -0.07788717 0.08842471 dd &lt;- cbind(camp.bras19.standart, cluster = camp.bras2019.kmeans$cluster) head(dd) ## P V E D GP ## Flamengo 2.2718440 2.3768498 -1.37460237 -1.860723 2.6960012 ## Santos 1.3127542 1.3508715 -0.65112744 -1.123803 1.0349578 ## Palmeiras 1.3127542 1.1798751 0.43408496 -1.492263 1.0988441 ## Gremio 0.7732662 0.8378823 -0.65112744 -0.571113 1.2905029 ## Athletico Paranaense 0.7133230 0.6668859 0.07234749 -0.755343 0.4599812 ## Sao Paulo 0.6533799 0.4958895 0.79582243 -0.939573 -0.3066542 ## GC SG Aprov. VC EC ## Flamengo -0.6877908 2.1704285 2.2538301 2.0722105 -1.2914930 ## Santos -1.0923737 1.1959504 1.2903607 1.2752065 -0.4008082 ## Palmeiras -1.1935194 1.2845393 1.2903607 1.0095385 -0.4008082 ## Gremio -0.4854994 1.1073615 0.8086261 0.7438704 -0.8461506 ## Athletico Paranaense -1.1935194 0.8415947 0.7398068 0.7438704 -0.8461506 ## Sao Paulo -1.3958108 0.3986501 0.6709876 0.2125344 0.4898766 ## DC VF EF DF GPC ## Flamengo -1.7936379 2.5146974 -0.49114414 -1.6307094 2.66162141 ## Santos -1.4275893 1.2779610 -0.49114414 -0.6899155 1.58802622 ## Palmeiras -1.0615408 1.2779610 1.14600300 -1.6307094 1.23016116 ## Gremio -0.3294437 0.8657155 0.05457157 -0.6899155 1.05122862 ## Athletico Paranaense -0.3294437 0.4534700 1.14600300 -1.0035135 -0.02236657 ## Sao Paulo -0.6954922 0.8657155 0.60028729 -1.0035135 -0.29076536 ## GCC GPF GCF RVV A ## Flamengo 0.1078222 2.1502724 -1.0918365 3.0983303 0.42611207 ## Santos -0.6109924 -0.2677046 -1.2424346 0.1822547 2.13056035 ## Palmeiras -1.0902021 0.5958586 -1.0918365 -0.5467642 -1.18364464 ## Gremio 0.1078222 1.4594218 -0.7906402 0.1822547 -0.42611207 ## Athletico Paranaense -1.5694118 1.2867092 -0.7906402 0.9112736 -0.33142050 ## Sao Paulo -1.3298069 -0.2677046 -1.2424346 -0.5467642 0.04734579 ## X2A VE VCS ECS DCS ## Flamengo -0.2355302 -0.7503581 2.3242992 -1.1937336 -1.2907138 ## Santos 2.1197714 0.8021070 1.7899775 -1.1937336 -0.7040257 ## Palmeiras -0.8243555 0.2846186 1.7899775 1.7906005 -0.1173376 ## Gremio -0.8243555 -0.7503581 0.7213342 0.7958224 -0.7040257 ## Athletico Paranaense -0.8243555 -1.2678465 0.1870126 -1.1937336 -0.7040257 ## Sao Paulo -0.2355302 0.8021070 0.7213342 1.7906005 -0.7040257 ## JSSP JSP JSG GS GS.1.15 ## Flamengo 3.31762563 -0.63672612 -0.3441236 -0.6877908 -0.6193514 ## Santos 0.12951692 -0.32612801 -0.5735393 -1.0923737 -1.0064461 ## Palmeiras 0.52803051 -0.01552991 -0.5735393 -1.1935194 0.5419325 ## Gremio -0.06973988 -0.63672612 -0.3441236 -0.4854994 0.9290272 ## Athletico Paranaense 1.12580089 3.40104930 -0.3441236 -1.1935194 0.9290272 ## Sao Paulo 0.32877371 -0.01552991 -0.5735393 -1.3958108 -0.6193514 ## GS.16.30 GS.31.45 GS.46.60 GS.61.75 GS.76.90 ## Flamengo 0.1319600 -0.3556156 -0.1866652 -0.2712677 -0.9110408 ## Santos -0.3079067 -1.1923582 0.8315086 -0.9095447 -1.5084446 ## Palmeiras 0.1319600 -0.7739869 -1.2048389 -0.9095447 -1.2097427 ## Gremio -0.7477733 1.3178696 -0.1866652 -1.2286832 -1.2097427 ## Athletico Paranaense -1.1876400 -0.3556156 -1.8836214 -1.8669601 0.2837668 ## Sao Paulo -1.6275067 0.4811270 -0.1866652 -0.9095447 -1.2097427 ## GS.90 G GM.1.15 GM.16.30 GM.31.45 ## Flamengo -0.1613301 2.6960012 1.4575275 -0.9713242 3.1700902 ## Santos 0.6453204 1.0349578 1.9973525 0.7427774 0.4816745 ## Palmeiras -0.9679805 1.0988441 1.7274400 0.1714102 0.0336052 ## Gremio -0.1613301 1.2905029 1.1876150 0.7427774 1.1537784 ## Athletico Paranaense -0.1613301 0.4599812 -0.7017725 0.7427774 0.2576398 ## Sao Paulo -1.7746310 -0.3066542 0.3778775 -0.9713242 -0.4144641 ## GM.46.60 GM.61.75 GM.76.90 GM.90 PEN ## Flamengo 1.9638692 2.5715514 2.16970148 1.037412 0.7664232 ## Santos 1.0504417 1.1663321 -0.01560936 -1.267948 0.4257907 ## Palmeiras 1.3549175 0.3232005 1.23313969 0.461072 0.4257907 ## Gremio 0.1370141 1.1663321 0.92095243 1.037412 1.1070558 ## Athletico Paranaense 1.0504417 0.3232005 0.29657790 1.037412 -0.2554744 ## Sao Paulo 1.0504417 -1.0820189 -0.63998389 -0.115268 -0.2554744 ## PENF PEND cluster ## Flamengo 0.7009845 1.8569190 3 ## Santos 0.7009845 0.5305483 4 ## Palmeiras -0.2336615 0.5305483 4 ## Gremio 0.7009845 -0.7958224 4 ## Athletico Paranaense -0.2336615 1.8569190 4 ## Sao Paulo -0.2336615 -0.7958224 4 camp.bras2019.kmeans$cluster ## Flamengo Santos Palmeiras ## 3 4 4 ## Gremio Athletico Paranaense Sao Paulo ## 4 4 4 ## Internacional Corinthians Fortaleza ## 2 4 2 ## Goias Bahia Vasco ## 2 2 2 ## Atletico Mineiro Fluminense Botafogo ## 2 2 2 ## Ceara Cruzeiro CSA ## 2 1 1 ## Chapecoense Avai ## 1 1 head(camp.bras2019.kmeans$cluster, 4) ## Flamengo Santos Palmeiras Gremio ## 3 4 4 4 row.names(camp.bras19.standart)&lt;-NULL camp.bras2019.res &lt;- kmeans(camp.bras19.standart, 4, nstart = 25) fviz_cluster(camp.bras2019.res, data = camp.bras19.standart, palette = c(&quot;#2E9FDF&quot;, &quot;#00AFBB&quot;, &quot;#E7B800&quot;,&quot;#FF0000&quot;), ellipse.type = &quot;euclid&quot;, # Concentration ellipse star.plot = F, # Add segments from centroids to items repel = TRUE, # Avoid label overplotting (slow) ggtheme = theme_minimal() ) ## Too few points to calculate an ellipse Um método bastante interessante de fazer um cluster é com eclust que premite realizar vários procedimentos de uma só vez. Ele permite a utilização de diferentes métodos de similaridade. df&lt;-camp.bras19[,2:54] df&lt;-df[ , -which(colnames(df) %in% c(&quot;GS.91.105&quot;,&quot;GS.106.120&quot;,&quot;GS.120&quot;,&quot;GM.91.105&quot;,&quot;GM.106.120&quot;,&quot;GM.120&quot;))] rownames(df) &lt;- NULL df &lt;- scale(df) km.res &lt;- eclust(df, &quot;kmeans&quot;, k = 4, nstart = 25, graph = FALSE) fviz_cluster(km.res, geom = &quot;point&quot;, ellipse.type = &quot;norm&quot;, palette = &quot;jco&quot;, ggtheme = theme_minimal()) ## Too few points to calculate an ellipse hc.res &lt;- eclust(df, &quot;hclust&quot;, k = 4, hc_metric = &quot;euclidean&quot;, hc_method = &quot;ward.D2&quot;, graph = FALSE) fviz_dend(hc.res, show_labels = FALSE,palette = &quot;jco&quot;, as.ggplot = TRUE) ## Warning: The `&lt;scale&gt;` argument of `guides()` cannot be `FALSE`. Use &quot;none&quot; instead as ## of ggplot2 3.3.4. ## ℹ The deprecated feature was likely used in the factoextra package. ## Please report the issue at &lt;https://github.com/kassambara/factoextra/issues&gt;. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. #install.packages(&quot;NbClust&quot;) library(NbClust) data(iris) iris ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## 11 5.4 3.7 1.5 0.2 setosa ## 12 4.8 3.4 1.6 0.2 setosa ## 13 4.8 3.0 1.4 0.1 setosa ## 14 4.3 3.0 1.1 0.1 setosa ## 15 5.8 4.0 1.2 0.2 setosa ## 16 5.7 4.4 1.5 0.4 setosa ## 17 5.4 3.9 1.3 0.4 setosa ## 18 5.1 3.5 1.4 0.3 setosa ## 19 5.7 3.8 1.7 0.3 setosa ## 20 5.1 3.8 1.5 0.3 setosa ## 21 5.4 3.4 1.7 0.2 setosa ## 22 5.1 3.7 1.5 0.4 setosa ## 23 4.6 3.6 1.0 0.2 setosa ## 24 5.1 3.3 1.7 0.5 setosa ## 25 4.8 3.4 1.9 0.2 setosa ## 26 5.0 3.0 1.6 0.2 setosa ## 27 5.0 3.4 1.6 0.4 setosa ## 28 5.2 3.5 1.5 0.2 setosa ## 29 5.2 3.4 1.4 0.2 setosa ## 30 4.7 3.2 1.6 0.2 setosa ## 31 4.8 3.1 1.6 0.2 setosa ## 32 5.4 3.4 1.5 0.4 setosa ## 33 5.2 4.1 1.5 0.1 setosa ## 34 5.5 4.2 1.4 0.2 setosa ## 35 4.9 3.1 1.5 0.2 setosa ## 36 5.0 3.2 1.2 0.2 setosa ## 37 5.5 3.5 1.3 0.2 setosa ## 38 4.9 3.6 1.4 0.1 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 40 5.1 3.4 1.5 0.2 setosa ## 41 5.0 3.5 1.3 0.3 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 43 4.4 3.2 1.3 0.2 setosa ## 44 5.0 3.5 1.6 0.6 setosa ## 45 5.1 3.8 1.9 0.4 setosa ## 46 4.8 3.0 1.4 0.3 setosa ## 47 5.1 3.8 1.6 0.2 setosa ## 48 4.6 3.2 1.4 0.2 setosa ## 49 5.3 3.7 1.5 0.2 setosa ## 50 5.0 3.3 1.4 0.2 setosa ## 51 7.0 3.2 4.7 1.4 versicolor ## 52 6.4 3.2 4.5 1.5 versicolor ## 53 6.9 3.1 4.9 1.5 versicolor ## 54 5.5 2.3 4.0 1.3 versicolor ## 55 6.5 2.8 4.6 1.5 versicolor ## 56 5.7 2.8 4.5 1.3 versicolor ## 57 6.3 3.3 4.7 1.6 versicolor ## 58 4.9 2.4 3.3 1.0 versicolor ## 59 6.6 2.9 4.6 1.3 versicolor ## 60 5.2 2.7 3.9 1.4 versicolor ## 61 5.0 2.0 3.5 1.0 versicolor ## 62 5.9 3.0 4.2 1.5 versicolor ## 63 6.0 2.2 4.0 1.0 versicolor ## 64 6.1 2.9 4.7 1.4 versicolor ## 65 5.6 2.9 3.6 1.3 versicolor ## 66 6.7 3.1 4.4 1.4 versicolor ## 67 5.6 3.0 4.5 1.5 versicolor ## 68 5.8 2.7 4.1 1.0 versicolor ## 69 6.2 2.2 4.5 1.5 versicolor ## 70 5.6 2.5 3.9 1.1 versicolor ## 71 5.9 3.2 4.8 1.8 versicolor ## 72 6.1 2.8 4.0 1.3 versicolor ## 73 6.3 2.5 4.9 1.5 versicolor ## 74 6.1 2.8 4.7 1.2 versicolor ## 75 6.4 2.9 4.3 1.3 versicolor ## 76 6.6 3.0 4.4 1.4 versicolor ## 77 6.8 2.8 4.8 1.4 versicolor ## 78 6.7 3.0 5.0 1.7 versicolor ## 79 6.0 2.9 4.5 1.5 versicolor ## 80 5.7 2.6 3.5 1.0 versicolor ## 81 5.5 2.4 3.8 1.1 versicolor ## 82 5.5 2.4 3.7 1.0 versicolor ## 83 5.8 2.7 3.9 1.2 versicolor ## 84 6.0 2.7 5.1 1.6 versicolor ## 85 5.4 3.0 4.5 1.5 versicolor ## 86 6.0 3.4 4.5 1.6 versicolor ## 87 6.7 3.1 4.7 1.5 versicolor ## 88 6.3 2.3 4.4 1.3 versicolor ## 89 5.6 3.0 4.1 1.3 versicolor ## 90 5.5 2.5 4.0 1.3 versicolor ## 91 5.5 2.6 4.4 1.2 versicolor ## 92 6.1 3.0 4.6 1.4 versicolor ## 93 5.8 2.6 4.0 1.2 versicolor ## 94 5.0 2.3 3.3 1.0 versicolor ## 95 5.6 2.7 4.2 1.3 versicolor ## 96 5.7 3.0 4.2 1.2 versicolor ## 97 5.7 2.9 4.2 1.3 versicolor ## 98 6.2 2.9 4.3 1.3 versicolor ## 99 5.1 2.5 3.0 1.1 versicolor ## 100 5.7 2.8 4.1 1.3 versicolor ## 101 6.3 3.3 6.0 2.5 virginica ## 102 5.8 2.7 5.1 1.9 virginica ## 103 7.1 3.0 5.9 2.1 virginica ## 104 6.3 2.9 5.6 1.8 virginica ## 105 6.5 3.0 5.8 2.2 virginica ## 106 7.6 3.0 6.6 2.1 virginica ## 107 4.9 2.5 4.5 1.7 virginica ## 108 7.3 2.9 6.3 1.8 virginica ## 109 6.7 2.5 5.8 1.8 virginica ## 110 7.2 3.6 6.1 2.5 virginica ## 111 6.5 3.2 5.1 2.0 virginica ## 112 6.4 2.7 5.3 1.9 virginica ## 113 6.8 3.0 5.5 2.1 virginica ## 114 5.7 2.5 5.0 2.0 virginica ## 115 5.8 2.8 5.1 2.4 virginica ## 116 6.4 3.2 5.3 2.3 virginica ## 117 6.5 3.0 5.5 1.8 virginica ## 118 7.7 3.8 6.7 2.2 virginica ## 119 7.7 2.6 6.9 2.3 virginica ## 120 6.0 2.2 5.0 1.5 virginica ## 121 6.9 3.2 5.7 2.3 virginica ## 122 5.6 2.8 4.9 2.0 virginica ## 123 7.7 2.8 6.7 2.0 virginica ## 124 6.3 2.7 4.9 1.8 virginica ## 125 6.7 3.3 5.7 2.1 virginica ## 126 7.2 3.2 6.0 1.8 virginica ## 127 6.2 2.8 4.8 1.8 virginica ## 128 6.1 3.0 4.9 1.8 virginica ## 129 6.4 2.8 5.6 2.1 virginica ## 130 7.2 3.0 5.8 1.6 virginica ## 131 7.4 2.8 6.1 1.9 virginica ## 132 7.9 3.8 6.4 2.0 virginica ## 133 6.4 2.8 5.6 2.2 virginica ## 134 6.3 2.8 5.1 1.5 virginica ## 135 6.1 2.6 5.6 1.4 virginica ## 136 7.7 3.0 6.1 2.3 virginica ## 137 6.3 3.4 5.6 2.4 virginica ## 138 6.4 3.1 5.5 1.8 virginica ## 139 6.0 3.0 4.8 1.8 virginica ## 140 6.9 3.1 5.4 2.1 virginica ## 141 6.7 3.1 5.6 2.4 virginica ## 142 6.9 3.1 5.1 2.3 virginica ## 143 5.8 2.7 5.1 1.9 virginica ## 144 6.8 3.2 5.9 2.3 virginica ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica names&lt;-as.matrix(iris[,5]) iris&lt;-as.matrix(iris[,1:4]) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## [1,] 5.1 3.5 1.4 0.2 ## [2,] 4.9 3.0 1.4 0.2 ## [3,] 4.7 3.2 1.3 0.2 ## [4,] 4.6 3.1 1.5 0.2 ## [5,] 5.0 3.6 1.4 0.2 ## [6,] 5.4 3.9 1.7 0.4 row.names(iris)&lt;-names head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## setosa 5.1 3.5 1.4 0.2 ## setosa 4.9 3.0 1.4 0.2 ## setosa 4.7 3.2 1.3 0.2 ## setosa 4.6 3.1 1.5 0.2 ## setosa 5.0 3.6 1.4 0.2 ## setosa 5.4 3.9 1.7 0.4 class(iris) ## [1] &quot;matrix&quot; &quot;array&quot; iris.norm&lt;-decostand(iris,&quot;normalize&quot;) #install.packages(&quot;factoextra&quot;) library(factoextra) #silhouette fviz_nbclust(iris.norm, kmeans, method = &quot;wss&quot;) + geom_vline(xintercept = 2, linetype = 2) #elbow fviz_nbclust(iris.norm, kmeans, method = &quot;silhouette&quot;)+ labs(subtitle = &quot;Silhouette method&quot;) iris.kmeans &lt;- kmeans(iris.norm, 2, nstart = 100) print(iris.kmeans) ## K-means clustering with 2 clusters of sizes 50, 100 ## ## Cluster means: ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 0.8011398 0.5472692 0.2344088 0.03917808 ## 2 0.7265305 0.3341267 0.5649710 0.19201808 ## ## Clustering vector: ## setosa setosa setosa setosa setosa setosa setosa ## 1 1 1 1 1 1 1 ## setosa setosa setosa setosa setosa setosa setosa ## 1 1 1 1 1 1 1 ## setosa setosa setosa setosa setosa setosa setosa ## 1 1 1 1 1 1 1 ## setosa setosa setosa setosa setosa setosa setosa ## 1 1 1 1 1 1 1 ## setosa setosa setosa setosa setosa setosa setosa ## 1 1 1 1 1 1 1 ## setosa setosa setosa setosa setosa setosa setosa ## 1 1 1 1 1 1 1 ## setosa setosa setosa setosa setosa setosa setosa ## 1 1 1 1 1 1 1 ## setosa versicolor versicolor versicolor versicolor versicolor versicolor ## 1 2 2 2 2 2 2 ## versicolor versicolor versicolor versicolor versicolor versicolor versicolor ## 2 2 2 2 2 2 2 ## versicolor versicolor versicolor versicolor versicolor versicolor versicolor ## 2 2 2 2 2 2 2 ## versicolor versicolor versicolor versicolor versicolor versicolor versicolor ## 2 2 2 2 2 2 2 ## versicolor versicolor versicolor versicolor versicolor versicolor versicolor ## 2 2 2 2 2 2 2 ## versicolor versicolor versicolor versicolor versicolor versicolor versicolor ## 2 2 2 2 2 2 2 ## versicolor versicolor versicolor versicolor versicolor versicolor versicolor ## 2 2 2 2 2 2 2 ## versicolor versicolor virginica virginica virginica virginica virginica ## 2 2 2 2 2 2 2 ## virginica virginica virginica virginica virginica virginica virginica ## 2 2 2 2 2 2 2 ## virginica virginica virginica virginica virginica virginica virginica ## 2 2 2 2 2 2 2 ## virginica virginica virginica virginica virginica virginica virginica ## 2 2 2 2 2 2 2 ## virginica virginica virginica virginica virginica virginica virginica ## 2 2 2 2 2 2 2 ## virginica virginica virginica virginica virginica virginica virginica ## 2 2 2 2 2 2 2 ## virginica virginica virginica virginica virginica virginica virginica ## 2 2 2 2 2 2 2 ## virginica virginica virginica ## 2 2 2 ## ## Within cluster sum of squares by cluster: ## [1] 0.109453 0.444952 ## (between_SS / total_SS = 91.7 %) ## ## Available components: ## ## [1] &quot;cluster&quot; &quot;centers&quot; &quot;totss&quot; &quot;withinss&quot; &quot;tot.withinss&quot; ## [6] &quot;betweenss&quot; &quot;size&quot; &quot;iter&quot; &quot;ifault&quot; dend &lt;- as.dendrogram(camp.bras2019.chwo) heatmap(as.matrix(camp.bras19.stan.ch), Rowv=dend, symm=TRUE, margin=c(3,3)) Análise cluster respeitando a sequência dos dados. setwd(&quot;J:/ENG 792/ENG_792-AVDR/ENG.792-AVDR/&quot;) #install.packages(&quot;rioja&quot;) list.files(pattern=&quot;.txt&quot;) ## [1] &quot;Cap_3_Informações - Alunos ENG 792.txt&quot; ## [2] &quot;Cap_3_Notas_2_ENG792.txt&quot; ## [3] &quot;Cap_3_Notas_ENG792.txt&quot; ## [4] &quot;Cap_5_Notas_ENG792.txt&quot; ## [5] &quot;Ciama.txt&quot; ## [6] &quot;env.data.txt&quot; ## [7] &quot;new_G.txt&quot; ## [8] &quot;Pre.txt&quot; library(rioja) ## This is rioja 1.0-5 ## ## Attaching package: &#39;rioja&#39; ## The following object is masked from &#39;package:mosaic&#39;: ## ## dot ## The following objects are masked from &#39;package:analogue&#39;: ## ## crossval, performance Ciama&lt;-read.table(&quot;Ciama.txt&quot;, header=TRUE, sep=&quot;&quot;) Ciama_dist&lt;-vegdist(Ciama, method=&quot;euc&quot;) clust1&lt;-hclust(Ciama_dist, method = &quot;ward.D&quot;) clust&lt;-chclust(Ciama_dist, method = &quot;coniss&quot;) plot(clust1, hang=0.08) rect.hclust(clust, k=5) plot(clust, hang=-1) rect.hclust(clust, k=5) x&lt;-strat.plot(Ciama, scale.percent=T, y.rev=TRUE, clust=clust) addClustZone(x, clust, 5, col=&quot;red&quot;) Outras opções visuais #install.packages(&quot;ape&quot;) library(ape) ## ## Attaching package: &#39;ape&#39; ## The following objects are masked from &#39;package:dendextend&#39;: ## ## ladderize, rotate ## The following object is masked from &#39;package:ggpubr&#39;: ## ## rotate ## The following object is masked from &#39;package:dplyr&#39;: ## ## where grupos&lt;-cutree(clust,k=5) clust.phylo&lt;-as.phylo(clust) par(mfrow=c(1,1)) plot(clust.phylo, type=&quot;phylogram&quot;,tip.color = grupos) plot(clust.phylo, type=&quot;cladogram&quot;,tip.color = grupos) plot(clust.phylo, type=&quot;fan&quot;,tip.color = grupos) plot(clust.phylo, type=&quot;unrooted&quot;,tip.color = grupos) plot(clust.phylo, type=&quot;radial&quot;,tip.color = grupos) De’ath (2002) apresentou uma metodologia interessante de construir dendogramas que ele chamou de Multivariate Regression Tree. Esta metodologia explora a ocorrência de objetos (variáveis dependentes) em relação à condicionantes (variáveis independentes). library(mvpart) ## Registered S3 methods overwritten by &#39;mvpart&#39;: ## method from ## labels.rpart rpart ## model.frame.rpart rpart ## plot.rpart rpart ## predict.rpart rpart ## print.rpart rpart ## residuals.rpart rpart ## summary.rpart rpart ## text.rpart rpart ## ## Attaching package: &#39;mvpart&#39; ## The following object is masked from &#39;package:dendextend&#39;: ## ## prune ## The following object is masked from &#39;package:unikn&#39;: ## ## post library(MVPARTwrap) ## Registered S3 method overwritten by &#39;ade4&#39;: ## method from ## summary.dist labdsv data(spider) result&lt;-mvpart(data.matrix(spider[,1:12]) ~ herbs + reft + moss + sand + twigs + water, spider, xv=&quot;1se&quot;, xval=10, xvmult=100) ## X-Val rep : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 ## Minimum tree sizes ## tabmins ## 4 5 6 7 ## 1 1 24 74 summary(result) ## Call: ## mvpart(form = data.matrix(spider[, 1:12]) ~ herbs + reft + moss + ## sand + twigs + water, data = spider, xv = &quot;1se&quot;, xval = 10, ## xvmult = 100) ## n= 28 ## ## CP nsplit rel error xerror xstd ## 1 0.51864091 0 1.0000000 1.0778963 0.12624119 ## 2 0.14489010 1 0.4813591 0.5702547 0.07715513 ## 3 0.07537481 2 0.3364690 0.4378872 0.07631331 ## ## Node number 1: 28 observations, complexity param=0.5186409 ## Means=0.3571,1.179,1.536,1.964,2.5,1.179,4.5,1.393,2.5,1.5,0.9286,0.4286, Summed MSE=50.64158 ## left son=2 (20 obs) right son=3 (8 obs) ## Primary splits: ## herbs &lt; 8.5 to the left, improve=0.5186409, (0 missing) ## water &lt; 5.5 to the left, improve=0.3015809, (0 missing) ## moss &lt; 6 to the right, improve=0.2483042, (0 missing) ## reft &lt; 7.5 to the right, improve=0.2123679, (0 missing) ## sand &lt; 5.5 to the right, improve=0.2008664, (0 missing) ## ## Node number 2: 20 observations, complexity param=0.1448901 ## Means=0.1,1.3,0.75,0.6,0.5,0.3,2.9,0.8,2.1,1.5,1.2,0.6, Summed MSE=25.7775 ## left son=4 (11 obs) right son=5 (9 obs) ## Primary splits: ## twigs &lt; 3.5 to the left, improve=0.3985045, (0 missing) ## water &lt; 5.5 to the left, improve=0.3985045, (0 missing) ## reft &lt; 3.5 to the right, improve=0.3985045, (0 missing) ## moss &lt; 6 to the right, improve=0.3518347, (0 missing) ## herbs &lt; 6.5 to the left, improve=0.2054174, (0 missing) ## ## Node number 3: 8 observations ## Means=1,0.875,3.5,5.375,7.5,3.375,8.5,2.875,3.5,1.5,0.25,0, Summed MSE=20.875 ## ## Node number 4: 11 observations ## Means=0,0.1818,0.1818,0.3636,0.3636,0.1818,1.364,0.5455,3.364,2.727,2.182,1.091, Summed MSE=17.68595 ## ## Node number 5: 9 observations ## Means=0.2222,2.667,1.444,0.8889,0.6667,0.4444,4.778,1.111,0.5556,0,0,0, Summed MSE=12.83951 printcp(result) ## mvpart(form = data.matrix(spider[, 1:12]) ~ herbs + reft + moss + ## sand + twigs + water, data = spider, xv = &quot;1se&quot;, xval = 10, ## xvmult = 100) ## ## Variables actually used in tree construction: ## [1] herbs twigs ## ## Root node error: 1418/28 = 50.642 ## ## n= 28 ## ## CP nsplit rel error xerror xstd ## 1 0.518641 0 1.00000 1.07790 0.126241 ## 2 0.144890 1 0.48136 0.57025 0.077155 ## 3 0.075375 2 0.33647 0.43789 0.076313 # Resíduos do MRT par(mfrow=c(1,2)) hist(residuals(result), col=&quot;grey&quot;) plot(predict(result, type=&quot;matrix&quot;), residuals(result), main=&quot;Residuals vs Predicted&quot;) # Composição result$where ## [1] 4 4 4 4 4 4 5 4 4 5 4 5 5 5 5 5 5 3 3 3 3 3 3 3 3 3 3 3 # Identidade (groups.mrt &lt;- levels(as.factor(result$where))) ## [1] &quot;3&quot; &quot;4&quot; &quot;5&quot; # Composisção da primeira folha spider[which(result$where==groups.mrt[1]),] ## arct.lute pard.lugu zora.spin pard.nigr pard.pull aulo.albi troc.terr ## 18 0 0 0 1 1 0 1 ## 19 0 0 0 1 2 0 3 ## 20 0 1 2 2 0 1 4 ## 21 0 0 0 0 1 1 2 ## 22 0 0 0 0 0 0 1 ## 23 0 0 0 0 0 0 1 ## 24 0 1 0 0 0 0 1 ## 25 0 0 0 0 0 0 1 ## 26 0 0 0 0 0 0 0 ## 27 0 0 0 0 0 0 0 ## 28 0 0 0 0 0 0 1 ## alop.cune pard.mont alop.acce alop.fabr arct.peri water sand moss reft twigs ## 18 1 5 1 0 0 5 0 9 7 0 ## 19 3 9 4 0 0 5 0 8 8 0 ## 20 1 3 3 3 0 3 7 2 5 0 ## 21 1 9 3 1 0 4 0 9 8 0 ## 22 0 4 1 1 0 4 8 7 8 0 ## 23 0 2 3 3 1 0 7 8 8 0 ## 24 0 2 4 3 2 0 6 9 9 0 ## 25 0 1 2 4 1 1 7 9 8 0 ## 26 0 1 5 3 2 0 5 8 8 0 ## 27 0 1 3 4 2 2 7 9 9 0 ## 28 0 0 1 2 4 0 9 4 9 0 ## herbs ## 18 6 ## 19 8 ## 20 8 ## 21 7 ## 22 5 ## 23 6 ## 24 6 ## 25 0 ## 26 6 ## 27 5 ## 28 2 # Variáveis ambientais da primeira folha spider[,12:18][which(result$where==groups.mrt[1]),] ## arct.peri water sand moss reft twigs herbs ## 18 0 5 0 9 7 0 6 ## 19 0 5 0 8 8 0 8 ## 20 0 3 7 2 5 0 8 ## 21 0 4 0 9 8 0 7 ## 22 0 4 8 7 8 0 5 ## 23 1 0 7 8 8 0 6 ## 24 2 0 6 9 9 0 6 ## 25 1 1 7 9 8 0 0 ## 26 2 0 5 8 8 0 6 ## 27 2 2 7 9 9 0 5 ## 28 4 0 9 4 9 0 2 # Extraindo resultados MRT de um objeto mvpart # Pacotes MVPARTwrap e rdaTest tem que estar carregados spe.ch.mvpart.wrap &lt;- MRT(result, percent=10, species=colnames(spider[,1:12])) summary(spe.ch.mvpart.wrap) ## Length Class Mode ## nodes 2 -none- numeric ## pourct 24 -none- numeric ## R2 24 -none- numeric ## obj 13 rpart list ## percent 1 -none- numeric ## MOYs 48 -none- numeric ## RWHERE 2 -none- list ## LWHERE 2 -none- list ## TABLE1 52 -none- numeric ## LABELS 1 -none- logical ## mat_labels 6 -none- character # Procura or Indicator species resultado do MRT library(labdsv) ## Carregando pacotes exigidos: mgcv ## Carregando pacotes exigidos: nlme ## ## Attaching package: &#39;nlme&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## collapse ## This is mgcv 1.8-42. For overview type &#39;help(&quot;mgcv-package&quot;)&#39;. ## ## Attaching package: &#39;mgcv&#39; ## The following object is masked from &#39;package:mosaic&#39;: ## ## cnorm ## This is labdsv 2.0-1 ## convert existing ordinations with as.dsvord() ## ## Attaching package: &#39;labdsv&#39; ## The following object is masked from &#39;package:mosaic&#39;: ## ## factorize ## The following object is masked from &#39;package:stats&#39;: ## ## density spe.ch.MRT.indval &lt;- indval(spider, result$where) spe.ch.MRT.indval$pval # Probability ## arct.lute pard.lugu zora.spin pard.nigr pard.pull aulo.albi troc.terr alop.cune ## 0.001 0.006 0.001 0.001 0.001 0.001 0.001 0.002 ## pard.mont alop.acce alop.fabr arct.peri water sand moss reft ## 0.066 0.003 0.001 0.003 0.021 0.001 0.001 0.001 ## twigs herbs ## 0.001 0.001 # Para cada espécie significante, encontra a folha com o maior IndVal spe.ch.MRT.indval$maxcls[which(spe.ch.MRT.indval$pval &lt;= 0.05)] ## arct.lute pard.lugu zora.spin pard.nigr pard.pull aulo.albi troc.terr alop.cune ## 3 2 3 3 3 3 3 3 ## alop.acce alop.fabr arct.peri water sand moss reft twigs ## 1 1 1 2 1 1 1 2 ## herbs ## 3 # Valor de IndVal na melhor folha para cada espécie significante spe.ch.MRT.indval$indcls[which(spe.ch.MRT.indval$pval &lt;= 0.05)] ## arct.lute pard.lugu zora.spin pard.nigr pard.pull aulo.albi troc.terr alop.cune ## 0.6136364 0.6366000 0.6827586 0.8110116 0.8792185 0.8434837 0.5805450 0.6344386 ## alop.acce alop.fabr arct.peri water sand moss reft twigs ## 0.6451613 0.7340697 0.5454545 0.4554600 0.6148802 0.6087225 0.5574938 0.9212828 ## herbs ## 0.5053885 9.1.3.1 Leitura Complementar Data transformations Transforming Data Normalizar ou padronizar as variáveis? Transformations for community composition data Cluster Analysis (1) Hierarchical Cluster Analysis 2.3. Clustering What is cluster analysis? When should you use it for your survey results? K-means Cluster Analysis Cluster Analysis Cluster Analysis What is clustering analysis? Cluster Analysis in Practice: Dealing with Outliers in Managerial Research Conduct and Interpret a Cluster Analysis Clustering Distance Measures Cophenetic Correlation Coefficient Comparison of hierarchical cluster analysis methods by cophenetic correlation Practical Guide To Cluster Analysis in R Para entender sobre MRT leia De’ath (2002). Alboukadel Kassambara (2017) Silva (2015) Perlin (2018) "]]
